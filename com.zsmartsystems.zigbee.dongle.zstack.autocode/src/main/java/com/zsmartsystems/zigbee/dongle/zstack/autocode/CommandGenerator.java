/**
 * Copyright (c) 2016-2019 by the respective copyright holders.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zigbee.dongle.zstack.autocode;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import com.zsmartsystems.zigbee.dongle.zstack.autocode.xml.Command;
import com.zsmartsystems.zigbee.dongle.zstack.autocode.xml.Command.ZstackRequestType;
import com.zsmartsystems.zigbee.dongle.zstack.autocode.xml.Enumeration;
import com.zsmartsystems.zigbee.dongle.zstack.autocode.xml.Parameter;
import com.zsmartsystems.zigbee.dongle.zstack.autocode.xml.Protocol;
import com.zsmartsystems.zigbee.dongle.zstack.autocode.xml.Structure;
import com.zsmartsystems.zigbee.dongle.zstack.autocode.xml.Value;

/**
 *
 * @author Chris Jackson
 *
 */
public class CommandGenerator extends ClassGenerator {
    protected final String zssPackage = "com.zsmartsystems.zigbee";
    protected final String zstackCommandPackage = "com.zsmartsystems.zigbee.dongle.zstack.api";

    private List<Enumeration> enumerations;

    public void go(Protocol protocol) throws FileNotFoundException {
        enumerations = protocol.enumerations;

        String className;
        for (Command command : protocol.commands) {
            String name = camelCaseToUpperCamelCase(command.name);
            if (command.requestType == ZstackRequestType.ASYNC) {
                className = "Zstack" + name + "Areq";
                createCommandClass(className, command, command.request_parameters);
            } else if (command.requestType == ZstackRequestType.ASYNCMD) {
                className = "Zstack" + name + "Acmd";
                createCommandClass(className, command, command.request_parameters);
            } else {
                if (command.request_parameters != null) {
                    className = "Zstack" + name + "Sreq";
                    createCommandClass(className, command, command.request_parameters);
                }

                if (command.response_parameters != null) {
                    className = "Zstack" + name + "Srsp";
                    createCommandClass(className, command, command.response_parameters);
                }
            }
        }

        createZstackFrameFactory(protocol);

        for (Structure structure : protocol.structures) {
            // createStructureClass(structure);
        }

        for (Enumeration enumeration : protocol.enumerations) {
            createEnumClass(enumeration);
        }
    }

    private void createCommandClass(String className, Command command, List<Parameter> parameters)
            throws FileNotFoundException {

        System.out.println("Processing command class " + command.name + "  [" + className + "()]");

        StringWriter stringWriter = new StringWriter();
        PrintWriter out = new PrintWriter(stringWriter);

        clearImports();

        out.println("/**");
        out.println(" * Class to implement the Z-Stack command <b>" + command.name + "</b>.");
        out.println(" * <p>");
        if (command.description != null && !command.description.isEmpty()) {
            outputWithLinebreak(out, "", command.description);
            out.println(" * <p>");
        }
        out.println(" * Note that this code is autogenerated. Manual changes may be overwritten.");
        out.println(" *");
        out.println(" * @author Chris Jackson");
        out.println(" */");

        if (className.endsWith("Srsp") || className.endsWith("Areq")) {
            addImport(zstackCommandPackage + ".ZstackFrameResponse");
            out.println("public class " + className + " extends ZstackFrameResponse {");
        } else {
            addImport(zstackCommandPackage + ".ZstackFrameRequest");
            out.println("public class " + className + " extends ZstackFrameRequest {");
        }

        for (Parameter parameter : parameters) {
            if (parameter.auto_size != null) {
                continue;
            }

            out.println();
            out.println("    /**");
            if (parameter.description != null && !parameter.description.isEmpty()) {
                outputWithLinebreak(out, "    ", parameter.description);
            }
            if (parameter.multiple) {
                out.println("     * <p>");
                out.println("     * Parameter allows multiple options so implemented as a {@link Set}.");
            }
            out.println("     */");
            if (parameter.multiple) {
                addImport("java.util.Set");
                addImport("java.util.HashSet");
                out.println("    private Set<" + getTypeClass(command.subsystem, parameter.data_type) + "> "
                        + camelCaseToLowerCamelCase(parameter.name) + " = new HashSet<>();");
            } else {
                out.println("    private " + getTypeClass(command.subsystem, parameter.data_type) + " "
                        + camelCaseToLowerCamelCase(parameter.name) + ";");
            }

            // out.println(" private " + getTypeClass(command.subsystem, parameter.data_type) + " "
            // + camelCaseToLowerCamelCase(parameter.name) + ";");
        }

        if (className.endsWith("Srsp") || className.endsWith("Areq")) {
            out.println();
            out.println("    /**");
            out.println("     * Response and Handler constructor");
            out.println("     */");
            out.println("    public " + className + "(int[] inputBuffer) {");
            out.println("        // Super creates deserializer and reads header fields");
            out.println("        super(inputBuffer);");
            if (className.endsWith("Srsp")) {
                out.println();
                out.println("        synchronousCommand = true;");
            }
            out.println();
            out.println("        // Deserialize the fields");
            Map<String, String> autoSizers = new HashMap<String, String>();
            for (Parameter parameter : parameters) {
                if (parameter.auto_size != null) {
                    out.println("        int " + camelCaseToLowerCamelCase(parameter.name) + " = deserialize"
                            + getTypeSerializer(command.subsystem, parameter.data_type) + "();");
                    autoSizers.put(parameter.auto_size, camelCaseToLowerCamelCase(parameter.name));
                    continue;
                }
                if (autoSizers.get(parameter.name) != null) {
                    out.println("        " + camelCaseToLowerCamelCase(parameter.name) + " = deserialize"
                            + getTypeSerializer(command.subsystem, parameter.data_type) + "("
                            + autoSizers.get(parameter.name) + ");");
                    continue;
                }
                if (parameter.data_type.contains("[") && parameter.data_type.contains("]")
                        && !parameter.data_type.contains("[]")) {
                    int length = Integer.parseInt(parameter.data_type.substring(parameter.data_type.indexOf("[") + 1,
                            parameter.data_type.indexOf("]")));
                    out.println("        " + camelCaseToLowerCamelCase(parameter.name) + " = deserialize"
                            + getTypeSerializer(command.subsystem, parameter.data_type) + "(" + length + ");");
                    continue;
                }
                if (getDataType(parameter.data_type) != parameter.data_type) {
                    if (parameter.multiple) {
                        out.println("        " + getTypeClass(command.subsystem, getDataType(parameter.data_type))
                                + " tmp" + upperCaseFirstCharacter(parameter.name) + " = deserialize"
                                + getTypeSerializer(command.subsystem, parameter.data_type) + "();");
                        out.println("        for (" + getTypeClass(parameter.data_type) + " value : "
                                + getTypeClass(parameter.data_type) + ".values()) {");
                        out.println("            if ((tmp" + upperCaseFirstCharacter(parameter.name)
                                + " & value.getKey()) != 0) {");
                        out.println("                " + camelCaseToLowerCamelCase(parameter.name) + ".add(value);");
                        out.println("            }");
                        out.println("        }");
                    } else {
                        out.println("        " + camelCaseToLowerCamelCase(parameter.name) + " = " + parameter.data_type
                                + ".valueOf(deserialize" + getTypeSerializer(command.subsystem, parameter.data_type)
                                + "());");
                    }
                } else {
                    out.println("        " + camelCaseToLowerCamelCase(parameter.name) + " = deserialize"
                            + getTypeSerializer(command.subsystem, parameter.data_type) + "();");
                }
            }
            out.println("    }");
        } else {
            out.println();
            out.println("    /**");
            out.println("     * Request constructor");
            out.println("     */");
            out.println("    public " + className + "() {");
            if (className.endsWith("Sreq")) {
                out.println("        synchronousCommand = true;");
            }
            out.println("    }");
        }

        for (Parameter parameter : parameters) {
            if (parameter.auto_size != null) {
                continue;
            }

            out.println();
            out.println("    /**");
            outputWithLinebreak(out, "    ", parameter.description);
            out.println("     *");
            if (parameter.multiple) {
                out.println("     * @return the current " + camelCaseToLowerCamelCase(parameter.name)
                        + " as {@link Set} of {@link " + getTypeClass(command.subsystem, parameter.data_type) + "}");
            } else {
                out.println("     * @return the current " + camelCaseToLowerCamelCase(parameter.name) + " as {@link "
                        + getTypeClass(command.subsystem, parameter.data_type) + "}");
            }
            out.println("     */");
            if (parameter.multiple) {
                out.println("    public Set<" + getTypeClass(command.subsystem, parameter.data_type) + "> get"
                        + upperCaseFirstCharacter(parameter.name) + "() {");
            } else {
                out.println("    public " + getTypeClass(command.subsystem, parameter.data_type) + " get"
                        + upperCaseFirstCharacter(parameter.name) + "() {");
            }

            out.println("        return " + camelCaseToLowerCamelCase(parameter.name) + ";");
            out.println("    }");
            out.println();

            if (parameter.multiple) {
                out.println("    /**");
                outputWithLinebreak(out, "    ", parameter.description);
                out.println("     *");
                out.println("     * @param " + camelCaseToLowerCamelCase(parameter.name) + " the " + parameter.name
                        + " to add to the {@link Set} as {@link " + getTypeClass(command.subsystem, parameter.data_type)
                        + "}");
                out.println("     */");
                out.println("    public void add" + upperCaseFirstCharacter(parameter.name) + "("
                        + getTypeClass(command.subsystem, parameter.data_type) + " "
                        + camelCaseToLowerCamelCase(parameter.name) + ") {");
                out.println("        this." + camelCaseToLowerCamelCase(parameter.name) + ".add("
                        + camelCaseToLowerCamelCase(parameter.name) + ");");
                out.println("    }");
                out.println();
                out.println("    /**");
                outputWithLinebreak(out, "    ", parameter.description);
                out.println("     *");
                out.println("     * @param " + camelCaseToLowerCamelCase(parameter.name) + " the " + parameter.name
                        + " to remove to the {@link Set} as {@link "
                        + getTypeClass(command.subsystem, parameter.data_type) + "}");
                out.println("     */");
                out.println("    public void remove" + upperCaseFirstCharacter(parameter.name) + "("
                        + getTypeClass(command.subsystem, parameter.data_type) + " "
                        + camelCaseToLowerCamelCase(parameter.name) + ") {");
                out.println("        this." + camelCaseToLowerCamelCase(parameter.name) + ".remove("
                        + camelCaseToLowerCamelCase(parameter.name) + ");");
                out.println("    }");
            } else {
                out.println("    /**");
                outputWithLinebreak(out, "    ", parameter.description);
                out.println("     *");
                out.println("     * @param " + camelCaseToLowerCamelCase(parameter.name) + " the " + parameter.name
                        + " to set as {@link " + getTypeClass(command.subsystem, parameter.data_type) + "}");
                out.println("     */");
                out.println("    public void set" + upperCaseFirstCharacter(parameter.name) + "("
                        + getTypeClass(command.subsystem, parameter.data_type) + " "
                        + camelCaseToLowerCamelCase(parameter.name) + ") {");
                out.println("        this." + camelCaseToLowerCamelCase(parameter.name) + " = "
                        + camelCaseToLowerCamelCase(parameter.name) + ";");
                out.println("    }");
            }
        }

        if (className.endsWith("Srsp") || className.endsWith("Areq")) {
        } else {
            if (className.endsWith("Sreq")) {
                addImport(zstackCommandPackage + ".rpc.ZstackRpcSreqErrorSrsp");
                out.println();
                out.println("    @Override");
                out.println("    public boolean matchSreqError(ZstackRpcSreqErrorSrsp response) {");
                out.println("        return (((response.getReqCmd0() & 0x1F) == ZSTACK_" + command.subsystem
                        + ") && (response.getReqCmd1() == " + String.format("0x%02X", command.id) + "));");
                out.println("    }");
            }

            out.println();
            out.println("    @Override");
            out.println("    public int[] serialize() {");
            out.println("        // Serialize the header");
            out.println("        serializeHeader(ZSTACK_" + className.substring(className.length() - 4).toUpperCase()
                    + ", ZSTACK_" + command.subsystem + ", " + String.format("0x%02X", command.id) + ");");
            out.println();
            out.println("        // Serialize the fields");
            for (Parameter parameter : parameters) {
                String enumModifier = "";
                if (getDataType(parameter.data_type) != parameter.data_type) {
                    enumModifier = ".getKey()";
                }
                if (parameter.auto_size != null) {
                    out.println("        serialize" + getTypeSerializer(command.subsystem, parameter.data_type) + "("
                            + camelCaseToLowerCamelCase(parameter.auto_size) + ".length);");
                    continue;
                }
                if (parameter.multiple) {
                    out.println("        " + getTypeClass(command.subsystem, getDataType(parameter.data_type)) + " tmp"
                            + upperCaseFirstCharacter(parameter.name) + " = 0;");
                    out.println("        for (" + getTypeClass(parameter.data_type) + " value : "
                            + camelCaseToLowerCamelCase(parameter.name) + ") {");
                    out.println("            tmp" + upperCaseFirstCharacter(parameter.name) + " += value.getKey();");
                    out.println("        }");
                    out.println("        serialize" + getTypeSerializer(command.subsystem, parameter.data_type) + "("
                            + "tmp" + upperCaseFirstCharacter(parameter.name) + ");");
                } else {
                    out.println("        serialize" + getTypeSerializer(command.subsystem, parameter.data_type) + "("
                            + camelCaseToLowerCamelCase(parameter.name) + enumModifier + ");");
                }
            }
            out.println("        return getPayload();");
            out.println("    }");
        }

        out.println();
        out.println("    @Override");
        out.println("    public String toString() {");

        if (parameters == null || parameters.size() == 0) {
            out.println("        return \"" + className + " []\";");
        } else {
            out.println("        final StringBuilder builder = new StringBuilder("
                    + (className.length() + 3 + parameters.size() * 25) + ");");
            boolean first = true;
            for (Parameter parameter : parameters) {
                if (parameter.auto_size != null) {
                    continue;
                }

                if (first) {
                    out.println("        builder.append(\"" + className + " ["
                            + camelCaseToLowerCamelCase(parameter.name) + "=\");");
                } else {
                    out.println("        builder.append(\", " + camelCaseToLowerCamelCase(parameter.name) + "=\");");
                }
                first = false;
                if (parameter.data_type.contains("[")) {
                    out.println("        for (int c = 0; c < " + camelCaseToLowerCamelCase(parameter.name)
                            + ".length; c++) {");
                    out.println("            if (c > 0) {");
                    out.println("                builder.append(' ');");
                    out.println("            }");
                    out.println("            builder.append(String.format(\"%02X\", " + formatParameterString(parameter)
                            + "[c]));");
                    out.println("        }");
                } else {
                    out.println("        builder.append(" + formatParameterString(parameter) + ");");
                }
            }
            out.println("        builder.append(']');");
            out.println("        return builder.toString();");
        }
        out.println("    }");

        out.println("}");

        out.flush();

        String cmdPackage = zstackCommandPackage + "." + command.subsystem.toLowerCase().replace("_", "");
        File packageFile = new File(sourceRootPath + cmdPackage.replace(".", "/"));
        packageFile.mkdirs();
        PrintWriter outFile = getClassOut(packageFile, className);

        outputCopywrite(outFile);
        outFile.println("package " + cmdPackage + ";");

        outFile.println();

        outputImports(outFile);

        outFile.println();
        outFile.print(stringWriter.toString());

        outFile.flush();
        outFile.close();

        out.close();
    }

    private void createEnumClass(Enumeration enumeration) throws FileNotFoundException {
        String className = upperCaseFirstCharacter(enumeration.name);
        System.out.println("Processing enum class " + enumeration.name + "  [" + className + "()]");

        StringWriter stringWriter = new StringWriter();
        PrintWriter out = new PrintWriter(stringWriter);

        clearImports();

        addImport("java.util.Map");
        addImport("java.util.HashMap");

        out.println("/**");
        out.println(" * Class to implement the Z-Stack Enumeration <b>" + enumeration.name + "</b>.");
        if (enumeration.description != null && enumeration.description.trim().length() > 0) {
            out.println(" * <p>");
            outputWithLinebreak(out, "", enumeration.description);
        }
        out.println(" * <p>");
        out.println(" * Note that this code is autogenerated. Manual changes may be overwritten.");
        out.println(" *");
        out.println(" * @author Chris Jackson");
        out.println(" */");

        out.println("public enum " + className + " {");

        out.println("    /**");
        out.println("     * Default unknown value");
        out.println("     */");
        out.println("    UNKNOWN(-1),");

        boolean first = true;
        for (Value value : enumeration.values) {
            if (!first) {
                out.println(",");
            }
            first = false;
            out.println();
            out.println("    /**");
            outputWithLinebreak(out, "    ", value.description);
            out.println("     */");
            out.print("    " + super.stringToConstant(value.name) + "(0x" + String.format("%04X", value.enum_value)
                    + ")");
        }

        out.println(";");

        out.println();
        out.println("    /**");
        out.println("     * A mapping between the integer code and its corresponding type to");
        out.println("     * facilitate lookup by code.");
        out.println("     */");
        out.println("    private static Map<Integer, " + className + "> codeMapping;");
        out.println();

        out.println("    private int key;");
        out.println();

        out.println("    static {");
        out.println("        codeMapping = new HashMap<Integer, " + className + ">();");
        out.println("        for (" + className + " s : values()) {");
        out.println("            codeMapping.put(s.key, s);");
        out.println("        }");
        out.println("    }");
        out.println();

        out.println("    private " + className + "(int key) {");
        out.println("        this.key = key;");
        out.println("    }");
        out.println();

        out.println("    /**");
        out.println("     * Lookup function based on the type code. Returns null if the code does not exist.");
        out.println("     *");
        out.println("     * @param code the code to lookup");
        out.println("     * @return enumeration value of the alarm type.");
        out.println("     */");
        out.println("    public static " + className + " valueOf(int code) {");
        out.println("        if (codeMapping.get(code) == null) {");
        out.println("            return UNKNOWN;");
        out.println("        }");
        out.println();

        out.println("        return codeMapping.get(code);");
        out.println("    }");
        out.println();
        out.println("    /**");
        out.println("     * Returns the Z-Stack protocol defined value for this enumeration.");
        out.println("     *");
        out.println("     * @return the Z-Stack protocol key");
        out.println("     */");
        out.println("    public int getKey() {");
        out.println("        return key;");
        out.println("    }");

        out.println("}");

        out.flush();

        String packageName = zstackCommandPackage;
        if (!enumeration.subsystem.isEmpty()) {
            packageName += "." + enumeration.subsystem.toLowerCase().replace("_", "");
        }

        File packageFile = new File(sourceRootPath + packageName.replace(".", "/"));
        PrintWriter outFile = getClassOut(packageFile, className);

        outputCopywrite(outFile);
        outFile.println("package " + packageName + ";");

        outFile.println();

        outputImports(outFile);

        outFile.println();
        outFile.print(stringWriter.toString());

        outFile.flush();
        outFile.close();

        out.close();
    }

    protected String getDataType(String dataType) {
        for (Enumeration enumeration : enumerations) {
            if (enumeration.name.equals(dataType) && enumeration.data_type != null) {
                return enumeration.data_type;
            }
        }

        return dataType;
    }

    protected String getTypeClass(String dataType) {
        return getTypeClass("", dataType);
    }

    protected String getTypeClass(String subsystem, String dataType) {
        if (dataType == null || dataType.isEmpty()) {
            throw new IllegalArgumentException("dataType cannot be empty");
        }
        String dataTypeLocal = new String(dataType);
        if (dataType.contains("[")) {
            dataTypeLocal = dataTypeLocal.substring(0, dataTypeLocal.indexOf("[") + 1);
        }

        for (Enumeration enumeration : enumerations) {
            if (enumeration.name.equals(dataType) && !enumeration.subsystem.equals(subsystem)) {
                String packageName = zstackCommandPackage;
                if (!enumeration.subsystem.isEmpty()) {
                    packageName += "." + enumeration.subsystem.toLowerCase().replace("_", "");
                }

                addImport(packageName + "." + dataTypeLocal);
            }
        }

        switch (dataTypeLocal) {
            case "int8":
            case "uint8":
            case "uint16":
            case "uint32":
                return "int";
            case "uint8[":
            case "uint16[":
                return "int[]";
            case "IeeeAddress":
                addImport(zssPackage + "." + dataTypeLocal);
                return dataTypeLocal;
            case "ZigBeeKey":
                addImport(zssPackage + ".security." + dataTypeLocal);
                return dataTypeLocal;
            case "":
                addImport(zstackCommandPackage + "." + dataTypeLocal);
                return dataTypeLocal;
            case "AfDataOptions":
                addImport(zstackCommandPackage + ".af." + dataTypeLocal);
                return dataTypeLocal;
            default:
                return dataType;
        }
    }

    protected String getTypeSerializer(String subsystem, String dataType) {
        String dataTypeLocal = new String(dataType);
        if (dataType.contains("[")) {
            dataTypeLocal = dataTypeLocal.substring(0, dataTypeLocal.indexOf("[") + 1);
        }

        for (Enumeration enumeration : enumerations) {
            if (enumeration.name.equals(dataType) && enumeration.data_type != null) {
                dataTypeLocal = enumeration.data_type;
            }
        }

        switch (dataTypeLocal) {
            case "int8":
            case "uint8":
                return "UInt8";
            case "uint16":
                return "UInt16";
            case "uint32":
                return "UInt32";
            case "uint8[":
                return "UInt8Array";
            case "uint16[":
                return "UInt16Array";
            case "boolean":
                return "Boolean";
            case "AF_DISCV_ROUTE":
            case "AfDataOptions":
                return dataTypeLocal;
            default:
                return dataType;
        }
    }

    private void createZstackFrameFactory(Protocol protocol) throws FileNotFoundException {
        StringWriter stringWriter = new StringWriter();
        PrintWriter out = new PrintWriter(stringWriter);

        clearImports();

        addImport("java.lang.reflect.Constructor");
        addImport("java.lang.reflect.InvocationTargetException");
        addImport("java.util.HashMap");
        addImport("java.util.Map");
        addImport("org.slf4j.Logger");
        addImport("org.slf4j.LoggerFactory");

        Map<String, Command> commandMap = new TreeMap<>();
        for (Command command : protocol.commands) {
            commandMap.put(command.name, command);
        }

        out.println();

        out.println("/**");
        out.println(
                " * Factory class to create Z-Stack commands from incoming data. This will only create {@link ZstackFrameResponse}s.");
        out.println(" * <p>");
        out.println(" * Note that this code is autogenerated. Manual changes may be overwritten.");
        out.println(" *");
        out.println(" * @author Chris Jackson");
        out.println(" */");
        out.println("public class ZstackFrameFactory {");
        out.println("    /**");
        out.println("     * Logger");
        out.println("     */");
        out.println("    private static Logger logger = LoggerFactory.getLogger(ZstackFrameFactory.class);");

        out.println();

        out.println("    /*");
        out.println("     * Subsystem definitions");
        out.println("     */");
        out.println("    public static int ZSTACK_RPC = 0x0000;");
        out.println("    public static int ZSTACK_SYS = 0x0100;");
        out.println("    public static int ZSTACK_MAC = 0x0200;");
        out.println("    public static int ZSTACK_AF = 0x0400;");
        out.println("    public static int ZSTACK_ZDO = 0x0500;");
        out.println("    public static int ZSTACK_SAPI = 0x0600;");
        out.println("    public static int ZSTACK_UTIL = 0x0700;");
        out.println("    public static int ZSTACK_APP_CNF = 0x0F00;");
        out.println("    public static int ZSTACK_SBL = 0x0D00;");
        out.println();
        out.println("    /**");
        out.println("     * Subsystem definition mask");
        out.println("     */");
        out.println("    private static int ZSTACK_SUBSYSTEM_MASK = 0x1F;");
        out.println();

        for (Command command : commandMap.values()) {
            if (command.requestType == ZstackRequestType.ASYNCMD) {
                continue;
            }

            String reference = camelCaseToConstant(
                    command.name.substring(0, 1).toUpperCase() + command.name.substring(1));
            out.println(
                    "    private static final int " + reference + " = 0x" + String.format("%02X", command.id) + ";");
        }

        out.println();
        out.println("    private static Map<Integer, Class<?>> zstackFrameMap = new HashMap<Integer, Class<?>>();");
        out.println();
        out.println("    static {");
        for (Command command : commandMap.values()) {
            String name = camelCaseToUpperCamelCase(command.name);
            String className;

            String cmdPackage = zstackCommandPackage + "." + command.subsystem.toLowerCase().replace("_", "");

            if (command.requestType == ZstackRequestType.ASYNC) {
                className = "Zstack" + name + "Areq";
                addImport(cmdPackage + "." + className);

                String reference = camelCaseToConstant(
                        command.name.substring(0, 1).toUpperCase() + command.name.substring(1));
                out.println("        zstackFrameMap.put(ZSTACK_" + command.subsystem + " + " + reference + ", "
                        + className + ".class);");
            } else if (command.requestType == ZstackRequestType.ASYNCMD) {
                // className = "Zstack" + name + "Acmd";
                // addImport(cmdPackage + "." + className);

                // String reference = camelCaseToConstant(
                // command.name.substring(0, 1).toUpperCase() + command.name.substring(1));
                // out.println(" zstackFrameMap.put(ZSTACK_" + command.subsystem + " + " + reference + ", "
                // + className + ".class);");
            } else {
                // className = "Zstack" + name + "Sreq";
                // addImport(cmdPackage + "." + className);

                // String reference = camelCaseToConstant(
                // command.name.substring(0, 1).toUpperCase() + command.name.substring(1));
                // out.println(" zstackFrameMap.put(ZSTACK_" + command.subsystem + " + " + reference + ", "
                // + className + ".class);");

                className = "Zstack" + name + "Srsp";
                addImport(cmdPackage + "." + className);

                String reference = camelCaseToConstant(
                        command.name.substring(0, 1).toUpperCase() + command.name.substring(1));
                out.println("        zstackFrameMap.put(ZSTACK_" + command.subsystem + " + " + reference + ", "
                        + className + ".class);");
            }
        }

        out.println("    }");
        out.println();

        out.println("    /**");
        out.println("     * Creates and {@link ZstackFrameResponse} from the incoming data.");
        out.println("     *");
        out.println("     * @param data the int[] containing the ZStack data from which to generate the frame");
        out.println("     * @return the {@link ZstackFrameResponse} or null if the response can't be created.");
        out.println("     */");
        out.println("    public static ZstackFrameResponse createFrame(int[] data) {");
        out.println("        if (data.length < 2) {");
        out.println("            return null;");
        out.println("        }");
        out.println();
        out.println("        int cmdId = ((data[0] & ZSTACK_SUBSYSTEM_MASK) << 8) + data[1];");
        out.println("        Class<?> zstackClass = zstackFrameMap.get(cmdId);");
        out.println();
        out.println("        if (zstackClass == null) {");
        out.println("            return null;");
        out.println("        }");
        out.println();
        out.println("        Constructor<?> ctor;");
        out.println("        try {");
        out.println("            ctor = zstackClass.getConstructor(int[].class);");
        out.println("            return (ZstackFrameResponse) ctor.newInstance(data);");
        out.println(
                "        } catch (SecurityException | NoSuchMethodException | IllegalArgumentException | InstantiationException");
        out.println("                | IllegalAccessException | InvocationTargetException e) {");
        out.println("            logger.debug(\"Error creating instance of ZstackCommand\", e);");
        out.println("        }");
        out.println();
        out.println("        return null;");
        out.println("    }");
        out.println();

        out.println();
        out.println("}");

        out.flush();

        File packageFile = new File(sourceRootPath + zstackCommandPackage.replace(".", "/"));
        PrintWriter outFile = getClassOut(packageFile, "ZstackFrameFactory");

        outputCopywrite(outFile);

        outFile.println("package " + zstackCommandPackage + ";");
        outFile.println();
        outputImports(outFile);

        outFile.println();
        outFile.print(stringWriter.toString());

        outFile.flush();
        outFile.close();

        out.close();
    }
}
