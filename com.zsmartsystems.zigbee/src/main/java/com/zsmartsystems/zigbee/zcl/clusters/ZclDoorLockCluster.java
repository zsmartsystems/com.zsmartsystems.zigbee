/**
 * Copyright (c) 2016-2019 by the respective copyright holders.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zigbee.zcl.clusters;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Future;

import javax.annotation.Generated;

import com.zsmartsystems.zigbee.CommandResult;
import com.zsmartsystems.zigbee.ZigBeeEndpoint;
import com.zsmartsystems.zigbee.zcl.ZclAttribute;
import com.zsmartsystems.zigbee.zcl.ZclCluster;
import com.zsmartsystems.zigbee.zcl.ZclCommand;
import com.zsmartsystems.zigbee.zcl.clusters.doorlock.LockDoorCommand;
import com.zsmartsystems.zigbee.zcl.clusters.doorlock.LockDoorResponse;
import com.zsmartsystems.zigbee.zcl.clusters.doorlock.Toggle;
import com.zsmartsystems.zigbee.zcl.clusters.doorlock.ToggleResponse;
import com.zsmartsystems.zigbee.zcl.clusters.doorlock.UnlockDoorCommand;
import com.zsmartsystems.zigbee.zcl.clusters.doorlock.UnlockDoorResponse;
import com.zsmartsystems.zigbee.zcl.clusters.doorlock.UnlockWithTimeout;
import com.zsmartsystems.zigbee.zcl.clusters.doorlock.UnlockWithTimeoutResponse;
import com.zsmartsystems.zigbee.zcl.field.ByteArray;
import com.zsmartsystems.zigbee.zcl.protocol.ZclClusterType;
import com.zsmartsystems.zigbee.zcl.protocol.ZclDataType;

/**
 * <b>Door Lock</b> cluster implementation (<i>Cluster ID 0x0101</i>).
 * <p>
 * The door lock cluster provides an interface to a generic way to secure a door. The physical
 * object that provides the locking functionality is abstracted from the cluster. The cluster
 * has a small list of mandatory attributes and functions and a list of optional features.
 * <p>
 * Generally the door lock itself implements the server side of this cluster. The attributes
 * and commands listed in this cluster were developed to be implemented by a door lock which has
 * the ability to keep track of multiple users and schedules.
 * <p>
 * The door lock cluster provides several alarms which can be sent when there is a critical state
 * on the door lock. The alarms available for the door lock cluster are listed in the section
 * below outlining the alarm mask at- tribute. The Alarm cluster is used to generate the actual
 * alarms.
 * <p>
 * The event mechanism in the door lock centers on the transmission of two commands
 * autonomously generated by the server and sent to a bound device. The assumption is that the
 * binding mechanism will be used to commission the server to send these commands.
 * <p>
 * Door locks have the ability to require the use of APS encryption for sending and receiving of
 * all cluster messages. The Security Level attribute is used to specify the type of encryption
 * required by the door lock.
 * <p>
 * Code is auto-generated. Modifications may be overwritten!
 */
@Generated(value = "com.zsmartsystems.zigbee.autocode.ZigBeeCodeGenerator", date = "2019-02-09T15:23:12Z")
public class ZclDoorLockCluster extends ZclCluster {
    /**
     * The ZigBee Cluster Library Cluster ID
     */
    public static final int CLUSTER_ID = 0x0101;

    /**
     * The ZigBee Cluster Library Cluster Name
     */
    public static final String CLUSTER_NAME = "Door Lock";

    // Attribute constants
    /**
     * Provides the current lock state
     */
    public static final int ATTR_LOCKSTATE = 0x0000;
    /**
     * Defines the type of lock
     */
    public static final int ATTR_LOCKTYPE = 0x0001;
    /**
     * Boolean indicating the enabled/disabled state of the lock
     */
    public static final int ATTR_ACTUATORENABLED = 0x0002;
    /**
     * The current state of the door lock
     */
    public static final int ATTR_DOORSTATE = 0x0003;
    /**
     * This attribute holds the number of door open events that have occurred since it was last
     * zeroed.
     */
    public static final int ATTR_DOOROPENEVENTS = 0x0004;
    /**
     * This attribute holds the number of door closed events that have occurred since it was
     * last zeroed.
     */
    public static final int ATTR_DOORCLOSEDEVENTS = 0x0005;
    /**
     * This attribute holds the number of minutes the door has been open since the last time it
     * transitioned from closed to open.
     */
    public static final int ATTR_OPENPERIOD = 0x0006;
    /**
     * The number of available log records.
     */
    public static final int ATTR_NUMLOCKRECORDSSUPPORTED = 0x0010;
    /**
     * Number of total users supported by the lock. This value is equal to the higher one of [# of
     * PIN Users Supported] and [# of RFID Users Supported]
     */
    public static final int ATTR_NUMTOTALUSERSSUPPORTED = 0x0011;
    /**
     * The number of PIN users supported.
     */
    public static final int ATTR_NUMPINUSERSSUPPORTED = 0x0012;
    /**
     * The number of RFID users supported.
     */
    public static final int ATTR_NUMRFIDUSERSSUPPORTED = 0x0013;
    /**
     * The number of configurable week day schedule supported per user.
     */
    public static final int ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER = 0x0014;
    /**
     * The number of configurable year day schedule supported per user
     */
    public static final int ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER = 0x0015;
    /**
     * The number of holiday schedules supported for the entire door lock device.
     */
    public static final int ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER = 0x0016;
    /**
     * An 8 bit value indicates the maximum length in bytes of a PIN Code on this device. The
     * default is set to 8 since most lock manufacturers currently allow PIN Codes of 8 bytes or
     * less.
     */
    public static final int ATTR_MAXPINLENGTH = 0x0017;
    /**
     * An 8 bit value indicates the minimum length in bytes of a PIN Code on this device. The
     * default is set to 4 since most lock manufacturers do not support PIN Codes that are
     * shorter than 4 bytes.
     */
    public static final int ATTR_MINPINLENGTH = 0x0018;
    /**
     * An 8 bit value indicates the maximum length in bytes of a RFID Code on this device. The
     * value depends on the RFID code range specified by the manufacturer, if media
     * anti-collision identifiers (UID) are used as RFID code, a value of 20 (equals 10 Byte ISO
     * 14443A UID) is recommended.
     */
    public static final int ATTR_MAXRFIDCODELENGTH = 0x0019;
    /**
     * An 8 bit value indicates the minimum length in bytes of a RFID Code on this device. The
     * value depends on the RFID code range specified by the manufacturer, if media
     * anti-collision identifiers (UID) are used as RFID code, a value of 8 (equals 4 Byte ISO
     * 14443A UID) is recommended.
     */
    public static final int ATTR_MINRFIDCODELENGTH = 0x001A;
    /**
     * Enable/disable event logging. When event logging is enabled, all event messages are
     * stored on the lock for retrieval. Logging events can be but not limited to Tamper Alarm,
     * Lock, Unlock, Autolock, User Code Added, User Code Deleted, Schedule Added, and
     * Schedule Deleted. For a full detail of all the possible alarms and events, please refer
     * to the full list in the Alarm and Event Masks Attribute Set.
     */
    public static final int ATTR_ENABLELOGGING = 0x0020;
    /**
     * Modifies the language for the on-screen or audible user interface using three bytes
     * from ISO-639-1. It consists of one byte of length and two bytes for the language code. For
     * example if the language is set to English, the value would be "02 65 6E" for the language
     * code "en"
     */
    public static final int ATTR_LANGUAGE = 0x0021;
    /**
     * The settings for the LED support three different modes
     */
    public static final int ATTR_LEDSETTINGS = 0x0022;
    /**
     * The number of seconds to wait after unlocking a lock before it automatically locks
     * again. 0=disabled. If set, unlock operations from any source will be timed. For one time
     * unlock with timeout use the specific command.
     */
    public static final int ATTR_AUTORELOCKTIME = 0x0023;
    /**
     * The sound volume on a door lock has three possible settings: silent, low and high volumes
     */
    public static final int ATTR_SOUNDVOLUME = 0x0024;
    /**
     * Shows the current operating mode
     */
    public static final int ATTR_OPERATINGMODE = 0x0025;
    /**
     * This bitmap contains all operating bits of the Operating Mode Attribute supported by
     * the lock. The value of the enumeration in “Operating Mode” defines the related bit to be
     * set, as shown in Table 7-16. All bits supported by a lock shall be set to zero.
     */
    public static final int ATTR_SUPPORTEDOPERATINGMODES = 0x0026;
    /**
     * This attribute represents the default configurations as they are physically set on the
     * device (example: hardware dip switch setting, etc…) and represents the default
     * setting for some of the attributes within this Operational Setting Attribute Set (for
     * example: LED, Auto Lock, Sound Volume, and Operating Mode attributes).
     * <p>
     * This is a read-only attribute and is intended to allow clients to determine what changes
     * may need to be made without having to query all the included attributes. It may be
     * beneficial for the clients to know what the device’s original settings were in the event
     * that the device needs to be restored to factory default settings.
     */
    public static final int ATTR_DEFAULTCONFIGURATIONREGISTER = 0x0027;
    /**
     * Enable/disable local programming on the door lock. The local programming features
     * includes but not limited to adding new user codes, deleting existing user codes, add new
     * schedule, deleting existing schedule on the local door lock interfaces. If this value
     * is set to 0x01 or TRUE then local programming is enabled on the door lock. If it is set to
     * 0x00 or FALSE then local programming is disabled on the door lock. Local programming is
     * enabled by default.
     */
    public static final int ATTR_ENABLELOCALPROGRAMMING = 0x0028;
    /**
     * Enable/disable the ability to lock the door lock with a single touch on the door lock.
     */
    public static final int ATTR_ENABLEONETOUCHLOCKING = 0x0029;
    /**
     * Enable/disable an inside LED that allows the user to see at a glance if the door is locked.
     */
    public static final int ATTR_ENABLEINSIDESTATUSLED = 0x002A;
    /**
     * Enable/disable a button inside the door that is used to put the lock into privacy mode.
     * When the lock is in privacy mode it cannot be manipulated from the outside.
     */
    public static final int ATTR_ENABLEPRIVACYMODEBUTTON = 0x002B;
    /**
     * The number of incorrect codes or RFID presentment attempts a user is allowed to enter
     * before the door will enter a lockout state. The lockout state will be for the duration of
     * UserCodeTemporaryDisableTime.
     */
    public static final int ATTR_WRONGCODEENTRYLIMIT = 0x0030;
    /**
     * The number of seconds that the lock shuts down following wrong code entry. 1-255
     * seconds. Device can shutdown to lock user out for specified amount of time. (Makes it
     * difficult to try and guess a PIN for the device.)
     */
    public static final int ATTR_USERCODETEMPORARYDISABLETIME = 0x0031;
    /**
     * Boolean set to True if it is ok for the door lock server to send PINs over the air. This
     * attribute determines the behavior of the server’s TX operation. If it is false, then it
     * is not ok for the device to send PIN in any messages over the air.
     * <p>
     * The PIN field within any door lock cluster message shall keep the first octet unchanged
     * and masks the actual code by replacing with 0xFF. For example (PIN "1234" ): If the
     * attribute value is True, 0x04 0x31 0x32 0x33 0x34 shall be used in the PIN field in any door
     * lock cluster message payload. If the attribute value is False, 0x04 0xFF 0xFF 0xFF 0xFF
     * shall be used.
     */
    public static final int ATTR_SENDPINOVERTHEAIR = 0x0032;
    /**
     * Boolean set to True if the door lock server requires that an optional PINs be included in
     * the payload of RF lock operation events like Lock, Unlock and Toggle in order to
     * function.
     */
    public static final int ATTR_REQUIREPINFORRFOPERATION = 0x0033;
    /**
     * Door locks may sometimes wish to implement a higher level of security within the
     * application protocol in additional to the default network security. For instance a
     * door lock may wish to use additional APS security for cluster transactions. This
     * protects the door lock against being controlled by any other devices which have access
     * to the network key.
     * <p>
     * The Security Level attribute allows the door lock manufacturer to indicate what level
     * of security the doorlock requires.
     */
    public static final int ATTR_ZIGBEESECURITYLEVEL = 0x0034;
    /**
     * The alarm mask is used to turn on/off alarms for particular functions. Alarms for an
     * alarm group are enabled if the associated alarm mask bit is set. Each bit represents a
     * group of alarms. Entire alarm groups can be turned on or off by setting or clearing the
     * associated bit in the alarm mask.
     */
    public static final int ATTR_ALARMMASK = 0x0040;
    /**
     * Event mask used to turn on and off the transmission of keypad operation events. This mask
     * DOES NOT apply to the storing of events in the report table.
     */
    public static final int ATTR_KEYPADOPERATIONEVENTMASK = 0x0041;
    /**
     * Event mask used to turn on and off the transmission of RF operation events. This mask DOES
     * NOT apply to the storing of events in the report table.
     */
    public static final int ATTR_RFOPERATIONEVENTMASK = 0x0042;
    /**
     * Event mask used to turn on and off manual operation events. This mask DOES NOT apply to the
     * storing of events in the report table.
     */
    public static final int ATTR_MANUALOPERATIONEVENTMASK = 0x0043;
    /**
     * Event mask used to turn on and off RFID operation events. This mask DOES NOT apply to the
     * storing of events in the report table.
     */
    public static final int ATTR_RFIDOPERATIONEVENTMASK = 0x0044;
    /**
     * Event mask used to turn on and off keypad programming events. This mask DOES NOT apply to
     * the storing of events in the report table.
     */
    public static final int ATTR_KEYPADPROGRAMMINGEVENTMASK = 0x0045;
    /**
     * Event mask used to turn on and off RF programming events. This mask DOES NOT apply to the
     * storing of events in the report table.
     */
    public static final int ATTR_RFPROGRAMMINGEVENTMASK = 0x0046;
    /**
     * Event mask used to turn on and off RFID programming events. This mask DOES NOT apply to the
     * storing of events in the report table.
     */
    public static final int ATTR_RFIDPROGRAMMINGEVENTMASK = 0x0047;

    // Attribute initialisation
    @Override
    protected Map<Integer, ZclAttribute> initializeAttributes() {
        Map<Integer, ZclAttribute> attributeMap = new ConcurrentHashMap<Integer, ZclAttribute>(43);

        attributeMap.put(ATTR_LOCKSTATE, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_LOCKSTATE, "Lock State", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_LOCKTYPE, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_LOCKTYPE, "Lock Type", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_ACTUATORENABLED, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_ACTUATORENABLED, "Actuator Enabled", ZclDataType.BOOLEAN, true, true, false, false));
        attributeMap.put(ATTR_DOORSTATE, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_DOORSTATE, "Door State", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_DOOROPENEVENTS, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_DOOROPENEVENTS, "Door Open Events", ZclDataType.UNSIGNED_32_BIT_INTEGER, false, true, true, true));
        attributeMap.put(ATTR_DOORCLOSEDEVENTS, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_DOORCLOSEDEVENTS, "Door Closed Events", ZclDataType.UNSIGNED_32_BIT_INTEGER, false, true, true, true));
        attributeMap.put(ATTR_OPENPERIOD, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_OPENPERIOD, "Open Period", ZclDataType.UNSIGNED_16_BIT_INTEGER, false, true, true, true));
        attributeMap.put(ATTR_NUMLOCKRECORDSSUPPORTED, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_NUMLOCKRECORDSSUPPORTED, "Num Lock Records Supported", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_NUMTOTALUSERSSUPPORTED, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_NUMTOTALUSERSSUPPORTED, "Num Total Users Supported", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_NUMPINUSERSSUPPORTED, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_NUMPINUSERSSUPPORTED, "Num PIN Users Supported", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_NUMRFIDUSERSSUPPORTED, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_NUMRFIDUSERSSUPPORTED, "Num RFID Users Supported", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER, "Num Weekday Schedules Supported Per User", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER, "Num Yearday Schedules Supported Per User", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER, "Num Holiday Schedules Supported Per User", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_MAXPINLENGTH, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_MAXPINLENGTH, "Max PIN Length", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_MINPINLENGTH, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_MINPINLENGTH, "Min PIN Length", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_MAXRFIDCODELENGTH, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_MAXRFIDCODELENGTH, "Max RFID Code Length", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_MINRFIDCODELENGTH, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_MINRFIDCODELENGTH, "Min RFID Code Length", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_ENABLELOGGING, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_ENABLELOGGING, "Enable Logging", ZclDataType.BOOLEAN, false, true, true, true));
        attributeMap.put(ATTR_LANGUAGE, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_LANGUAGE, "Language", ZclDataType.CHARACTER_STRING, false, true, true, true));
        attributeMap.put(ATTR_LEDSETTINGS, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_LEDSETTINGS, "LED Settings", ZclDataType.UNSIGNED_8_BIT_INTEGER, false, true, true, true));
        attributeMap.put(ATTR_AUTORELOCKTIME, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_AUTORELOCKTIME, "Auto Relock Time", ZclDataType.UNSIGNED_32_BIT_INTEGER, false, true, true, true));
        attributeMap.put(ATTR_SOUNDVOLUME, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_SOUNDVOLUME, "Sound Volume", ZclDataType.UNSIGNED_8_BIT_INTEGER, false, true, true, true));
        attributeMap.put(ATTR_OPERATINGMODE, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_OPERATINGMODE, "Operating Mode", ZclDataType.ENUMERATION_8_BIT, false, true, true, true));
        attributeMap.put(ATTR_SUPPORTEDOPERATINGMODES, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_SUPPORTEDOPERATINGMODES, "Supported Operating Modes", ZclDataType.BITMAP_16_BIT, true, true, false, false));
        attributeMap.put(ATTR_DEFAULTCONFIGURATIONREGISTER, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_DEFAULTCONFIGURATIONREGISTER, "Default Configuration Register", ZclDataType.BITMAP_16_BIT, true, true, false, false));
        attributeMap.put(ATTR_ENABLELOCALPROGRAMMING, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_ENABLELOCALPROGRAMMING, "Enable Local Programming", ZclDataType.BOOLEAN, false, true, true, true));
        attributeMap.put(ATTR_ENABLEONETOUCHLOCKING, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_ENABLEONETOUCHLOCKING, "Enable One Touch Locking", ZclDataType.BOOLEAN, false, true, true, true));
        attributeMap.put(ATTR_ENABLEINSIDESTATUSLED, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_ENABLEINSIDESTATUSLED, "Enable Inside Status Led", ZclDataType.BOOLEAN, false, true, true, true));
        attributeMap.put(ATTR_ENABLEPRIVACYMODEBUTTON, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_ENABLEPRIVACYMODEBUTTON, "Enable Privacy Mode Button", ZclDataType.BOOLEAN, false, true, true, true));
        attributeMap.put(ATTR_WRONGCODEENTRYLIMIT, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_WRONGCODEENTRYLIMIT, "Wrong Code Entry Limit", ZclDataType.UNSIGNED_8_BIT_INTEGER, false, true, true, true));
        attributeMap.put(ATTR_USERCODETEMPORARYDISABLETIME, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_USERCODETEMPORARYDISABLETIME, "User Code Temporary Disable Time", ZclDataType.UNSIGNED_8_BIT_INTEGER, false, true, true, true));
        attributeMap.put(ATTR_SENDPINOVERTHEAIR, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_SENDPINOVERTHEAIR, "Send PIN Over The Air", ZclDataType.BOOLEAN, false, true, true, true));
        attributeMap.put(ATTR_REQUIREPINFORRFOPERATION, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_REQUIREPINFORRFOPERATION, "Require PIN For RF Operation", ZclDataType.BOOLEAN, false, true, true, true));
        attributeMap.put(ATTR_ZIGBEESECURITYLEVEL, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_ZIGBEESECURITYLEVEL, "ZigBee Security Level", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_ALARMMASK, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_ALARMMASK, "Alarm Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_KEYPADOPERATIONEVENTMASK, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_KEYPADOPERATIONEVENTMASK, "Keypad Operation Event Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_RFOPERATIONEVENTMASK, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_RFOPERATIONEVENTMASK, "RF Operation Event Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_MANUALOPERATIONEVENTMASK, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_MANUALOPERATIONEVENTMASK, "Manual Operation Event Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_RFIDOPERATIONEVENTMASK, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_RFIDOPERATIONEVENTMASK, "RFID Operation Event Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_KEYPADPROGRAMMINGEVENTMASK, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_KEYPADPROGRAMMINGEVENTMASK, "Keypad Programming Event Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_RFPROGRAMMINGEVENTMASK, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_RFPROGRAMMINGEVENTMASK, "RF Programming Event Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_RFIDPROGRAMMINGEVENTMASK, new ZclAttribute(ZclClusterType.DOOR_LOCK, ATTR_RFIDPROGRAMMINGEVENTMASK, "RFID Programming Event Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));

        return attributeMap;
    }

    /**
     * Default constructor to create a Door Lock cluster.
     *
     * @param zigbeeEndpoint the {@link ZigBeeEndpoint} this cluster is contained within
     */
    public ZclDoorLockCluster(final ZigBeeEndpoint zigbeeEndpoint) {
        super(zigbeeEndpoint, CLUSTER_ID, CLUSTER_NAME);
    }

    /**
     * Get the <i>Lock State</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * Provides the current lock state
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getLockStateAsync() {
        return read(attributes.get(ATTR_LOCKSTATE));
    }

    /**
     * Synchronously get the <i>Lock State</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * Provides the current lock state
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getLockState(final long refreshPeriod) {
        if (attributes.get(ATTR_LOCKSTATE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_LOCKSTATE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_LOCKSTATE));
    }

    /**
     * Set reporting for the <i>Lock State</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * Provides the current lock state
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setLockStateReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_LOCKSTATE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Lock Type</i> attribute [attribute ID <b>0x0001</b>].
     * <p>
     * Defines the type of lock
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getLockTypeAsync() {
        return read(attributes.get(ATTR_LOCKTYPE));
    }

    /**
     * Synchronously get the <i>Lock Type</i> attribute [attribute ID <b>0x0001</b>].
     * <p>
     * Defines the type of lock
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getLockType(final long refreshPeriod) {
        if (attributes.get(ATTR_LOCKTYPE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_LOCKTYPE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_LOCKTYPE));
    }

    /**
     * Set reporting for the <i>Lock Type</i> attribute [attribute ID <b>0x0001</b>].
     * <p>
     * Defines the type of lock
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setLockTypeReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_LOCKTYPE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Actuator Enabled</i> attribute [attribute ID <b>0x0002</b>].
     * <p>
     * Boolean indicating the enabled/disabled state of the lock
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getActuatorEnabledAsync() {
        return read(attributes.get(ATTR_ACTUATORENABLED));
    }

    /**
     * Synchronously get the <i>Actuator Enabled</i> attribute [attribute ID <b>0x0002</b>].
     * <p>
     * Boolean indicating the enabled/disabled state of the lock
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Boolean} attribute value, or null on error
     */
    public Boolean getActuatorEnabled(final long refreshPeriod) {
        if (attributes.get(ATTR_ACTUATORENABLED).isLastValueCurrent(refreshPeriod)) {
            return (Boolean) attributes.get(ATTR_ACTUATORENABLED).getLastValue();
        }

        return (Boolean) readSync(attributes.get(ATTR_ACTUATORENABLED));
    }

    /**
     * Set reporting for the <i>Actuator Enabled</i> attribute [attribute ID <b>0x0002</b>].
     * <p>
     * Boolean indicating the enabled/disabled state of the lock
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setActuatorEnabledReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_ACTUATORENABLED), minInterval, maxInterval);
    }

    /**
     * Get the <i>Door State</i> attribute [attribute ID <b>0x0003</b>].
     * <p>
     * The current state of the door lock
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDoorStateAsync() {
        return read(attributes.get(ATTR_DOORSTATE));
    }

    /**
     * Synchronously get the <i>Door State</i> attribute [attribute ID <b>0x0003</b>].
     * <p>
     * The current state of the door lock
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDoorState(final long refreshPeriod) {
        if (attributes.get(ATTR_DOORSTATE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DOORSTATE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DOORSTATE));
    }

    /**
     * Set reporting for the <i>Door State</i> attribute [attribute ID <b>0x0003</b>].
     * <p>
     * The current state of the door lock
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDoorStateReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_DOORSTATE), minInterval, maxInterval);
    }

    /**
     * Set the <i>Door Open Events</i> attribute [attribute ID <b>0x0004</b>].
     * <p>
     * This attribute holds the number of door open events that have occurred since it was last
     * zeroed.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param doorOpenEvents the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDoorOpenEvents(final Integer value) {
        return write(attributes.get(ATTR_DOOROPENEVENTS), value);
    }

    /**
     * Get the <i>Door Open Events</i> attribute [attribute ID <b>0x0004</b>].
     * <p>
     * This attribute holds the number of door open events that have occurred since it was last
     * zeroed.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDoorOpenEventsAsync() {
        return read(attributes.get(ATTR_DOOROPENEVENTS));
    }

    /**
     * Synchronously get the <i>Door Open Events</i> attribute [attribute ID <b>0x0004</b>].
     * <p>
     * This attribute holds the number of door open events that have occurred since it was last
     * zeroed.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDoorOpenEvents(final long refreshPeriod) {
        if (attributes.get(ATTR_DOOROPENEVENTS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DOOROPENEVENTS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DOOROPENEVENTS));
    }

    /**
     * Set the <i>Door Closed Events</i> attribute [attribute ID <b>0x0005</b>].
     * <p>
     * This attribute holds the number of door closed events that have occurred since it was
     * last zeroed.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param doorClosedEvents the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDoorClosedEvents(final Integer value) {
        return write(attributes.get(ATTR_DOORCLOSEDEVENTS), value);
    }

    /**
     * Get the <i>Door Closed Events</i> attribute [attribute ID <b>0x0005</b>].
     * <p>
     * This attribute holds the number of door closed events that have occurred since it was
     * last zeroed.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDoorClosedEventsAsync() {
        return read(attributes.get(ATTR_DOORCLOSEDEVENTS));
    }

    /**
     * Synchronously get the <i>Door Closed Events</i> attribute [attribute ID <b>0x0005</b>].
     * <p>
     * This attribute holds the number of door closed events that have occurred since it was
     * last zeroed.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDoorClosedEvents(final long refreshPeriod) {
        if (attributes.get(ATTR_DOORCLOSEDEVENTS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DOORCLOSEDEVENTS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DOORCLOSEDEVENTS));
    }

    /**
     * Set the <i>Open Period</i> attribute [attribute ID <b>0x0006</b>].
     * <p>
     * This attribute holds the number of minutes the door has been open since the last time it
     * transitioned from closed to open.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param openPeriod the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setOpenPeriod(final Integer value) {
        return write(attributes.get(ATTR_OPENPERIOD), value);
    }

    /**
     * Get the <i>Open Period</i> attribute [attribute ID <b>0x0006</b>].
     * <p>
     * This attribute holds the number of minutes the door has been open since the last time it
     * transitioned from closed to open.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getOpenPeriodAsync() {
        return read(attributes.get(ATTR_OPENPERIOD));
    }

    /**
     * Synchronously get the <i>Open Period</i> attribute [attribute ID <b>0x0006</b>].
     * <p>
     * This attribute holds the number of minutes the door has been open since the last time it
     * transitioned from closed to open.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getOpenPeriod(final long refreshPeriod) {
        if (attributes.get(ATTR_OPENPERIOD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_OPENPERIOD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_OPENPERIOD));
    }

    /**
     * Get the <i>Num Lock Records Supported</i> attribute [attribute ID <b>0x0010</b>].
     * <p>
     * The number of available log records.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNumLockRecordsSupportedAsync() {
        return read(attributes.get(ATTR_NUMLOCKRECORDSSUPPORTED));
    }

    /**
     * Synchronously get the <i>Num Lock Records Supported</i> attribute [attribute ID <b>0x0010</b>].
     * <p>
     * The number of available log records.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNumLockRecordsSupported(final long refreshPeriod) {
        if (attributes.get(ATTR_NUMLOCKRECORDSSUPPORTED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NUMLOCKRECORDSSUPPORTED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NUMLOCKRECORDSSUPPORTED));
    }

    /**
     * Set reporting for the <i>Num Lock Records Supported</i> attribute [attribute ID <b>0x0010</b>].
     * <p>
     * The number of available log records.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNumLockRecordsSupportedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_NUMLOCKRECORDSSUPPORTED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Num Total Users Supported</i> attribute [attribute ID <b>0x0011</b>].
     * <p>
     * Number of total users supported by the lock. This value is equal to the higher one of [# of
     * PIN Users Supported] and [# of RFID Users Supported]
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNumTotalUsersSupportedAsync() {
        return read(attributes.get(ATTR_NUMTOTALUSERSSUPPORTED));
    }

    /**
     * Synchronously get the <i>Num Total Users Supported</i> attribute [attribute ID <b>0x0011</b>].
     * <p>
     * Number of total users supported by the lock. This value is equal to the higher one of [# of
     * PIN Users Supported] and [# of RFID Users Supported]
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNumTotalUsersSupported(final long refreshPeriod) {
        if (attributes.get(ATTR_NUMTOTALUSERSSUPPORTED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NUMTOTALUSERSSUPPORTED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NUMTOTALUSERSSUPPORTED));
    }

    /**
     * Set reporting for the <i>Num Total Users Supported</i> attribute [attribute ID <b>0x0011</b>].
     * <p>
     * Number of total users supported by the lock. This value is equal to the higher one of [# of
     * PIN Users Supported] and [# of RFID Users Supported]
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNumTotalUsersSupportedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_NUMTOTALUSERSSUPPORTED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Num PIN Users Supported</i> attribute [attribute ID <b>0x0012</b>].
     * <p>
     * The number of PIN users supported.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNumPinUsersSupportedAsync() {
        return read(attributes.get(ATTR_NUMPINUSERSSUPPORTED));
    }

    /**
     * Synchronously get the <i>Num PIN Users Supported</i> attribute [attribute ID <b>0x0012</b>].
     * <p>
     * The number of PIN users supported.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNumPinUsersSupported(final long refreshPeriod) {
        if (attributes.get(ATTR_NUMPINUSERSSUPPORTED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NUMPINUSERSSUPPORTED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NUMPINUSERSSUPPORTED));
    }

    /**
     * Set reporting for the <i>Num PIN Users Supported</i> attribute [attribute ID <b>0x0012</b>].
     * <p>
     * The number of PIN users supported.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNumPinUsersSupportedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_NUMPINUSERSSUPPORTED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Num RFID Users Supported</i> attribute [attribute ID <b>0x0013</b>].
     * <p>
     * The number of RFID users supported.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNumRfidUsersSupportedAsync() {
        return read(attributes.get(ATTR_NUMRFIDUSERSSUPPORTED));
    }

    /**
     * Synchronously get the <i>Num RFID Users Supported</i> attribute [attribute ID <b>0x0013</b>].
     * <p>
     * The number of RFID users supported.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNumRfidUsersSupported(final long refreshPeriod) {
        if (attributes.get(ATTR_NUMRFIDUSERSSUPPORTED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NUMRFIDUSERSSUPPORTED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NUMRFIDUSERSSUPPORTED));
    }

    /**
     * Set reporting for the <i>Num RFID Users Supported</i> attribute [attribute ID <b>0x0013</b>].
     * <p>
     * The number of RFID users supported.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNumRfidUsersSupportedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_NUMRFIDUSERSSUPPORTED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Num Weekday Schedules Supported Per User</i> attribute [attribute ID <b>0x0014</b>].
     * <p>
     * The number of configurable week day schedule supported per user.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNumWeekdaySchedulesSupportedPerUserAsync() {
        return read(attributes.get(ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER));
    }

    /**
     * Synchronously get the <i>Num Weekday Schedules Supported Per User</i> attribute [attribute ID <b>0x0014</b>].
     * <p>
     * The number of configurable week day schedule supported per user.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNumWeekdaySchedulesSupportedPerUser(final long refreshPeriod) {
        if (attributes.get(ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER));
    }

    /**
     * Set reporting for the <i>Num Weekday Schedules Supported Per User</i> attribute [attribute ID <b>0x0014</b>].
     * <p>
     * The number of configurable week day schedule supported per user.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNumWeekdaySchedulesSupportedPerUserReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Num Yearday Schedules Supported Per User</i> attribute [attribute ID <b>0x0015</b>].
     * <p>
     * The number of configurable year day schedule supported per user
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNumYeardaySchedulesSupportedPerUserAsync() {
        return read(attributes.get(ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER));
    }

    /**
     * Synchronously get the <i>Num Yearday Schedules Supported Per User</i> attribute [attribute ID <b>0x0015</b>].
     * <p>
     * The number of configurable year day schedule supported per user
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNumYeardaySchedulesSupportedPerUser(final long refreshPeriod) {
        if (attributes.get(ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER));
    }

    /**
     * Set reporting for the <i>Num Yearday Schedules Supported Per User</i> attribute [attribute ID <b>0x0015</b>].
     * <p>
     * The number of configurable year day schedule supported per user
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNumYeardaySchedulesSupportedPerUserReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Num Holiday Schedules Supported Per User</i> attribute [attribute ID <b>0x0016</b>].
     * <p>
     * The number of holiday schedules supported for the entire door lock device.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNumHolidaySchedulesSupportedPerUserAsync() {
        return read(attributes.get(ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER));
    }

    /**
     * Synchronously get the <i>Num Holiday Schedules Supported Per User</i> attribute [attribute ID <b>0x0016</b>].
     * <p>
     * The number of holiday schedules supported for the entire door lock device.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNumHolidaySchedulesSupportedPerUser(final long refreshPeriod) {
        if (attributes.get(ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER));
    }

    /**
     * Set reporting for the <i>Num Holiday Schedules Supported Per User</i> attribute [attribute ID <b>0x0016</b>].
     * <p>
     * The number of holiday schedules supported for the entire door lock device.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNumHolidaySchedulesSupportedPerUserReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Max PIN Length</i> attribute [attribute ID <b>0x0017</b>].
     * <p>
     * An 8 bit value indicates the maximum length in bytes of a PIN Code on this device. The
     * default is set to 8 since most lock manufacturers currently allow PIN Codes of 8 bytes or
     * less.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getMaxPinLengthAsync() {
        return read(attributes.get(ATTR_MAXPINLENGTH));
    }

    /**
     * Synchronously get the <i>Max PIN Length</i> attribute [attribute ID <b>0x0017</b>].
     * <p>
     * An 8 bit value indicates the maximum length in bytes of a PIN Code on this device. The
     * default is set to 8 since most lock manufacturers currently allow PIN Codes of 8 bytes or
     * less.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getMaxPinLength(final long refreshPeriod) {
        if (attributes.get(ATTR_MAXPINLENGTH).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_MAXPINLENGTH).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_MAXPINLENGTH));
    }

    /**
     * Set reporting for the <i>Max PIN Length</i> attribute [attribute ID <b>0x0017</b>].
     * <p>
     * An 8 bit value indicates the maximum length in bytes of a PIN Code on this device. The
     * default is set to 8 since most lock manufacturers currently allow PIN Codes of 8 bytes or
     * less.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setMaxPinLengthReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_MAXPINLENGTH), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Min PIN Length</i> attribute [attribute ID <b>0x0018</b>].
     * <p>
     * An 8 bit value indicates the minimum length in bytes of a PIN Code on this device. The
     * default is set to 4 since most lock manufacturers do not support PIN Codes that are
     * shorter than 4 bytes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getMinPinLengthAsync() {
        return read(attributes.get(ATTR_MINPINLENGTH));
    }

    /**
     * Synchronously get the <i>Min PIN Length</i> attribute [attribute ID <b>0x0018</b>].
     * <p>
     * An 8 bit value indicates the minimum length in bytes of a PIN Code on this device. The
     * default is set to 4 since most lock manufacturers do not support PIN Codes that are
     * shorter than 4 bytes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getMinPinLength(final long refreshPeriod) {
        if (attributes.get(ATTR_MINPINLENGTH).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_MINPINLENGTH).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_MINPINLENGTH));
    }

    /**
     * Set reporting for the <i>Min PIN Length</i> attribute [attribute ID <b>0x0018</b>].
     * <p>
     * An 8 bit value indicates the minimum length in bytes of a PIN Code on this device. The
     * default is set to 4 since most lock manufacturers do not support PIN Codes that are
     * shorter than 4 bytes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setMinPinLengthReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_MINPINLENGTH), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Max RFID Code Length</i> attribute [attribute ID <b>0x0019</b>].
     * <p>
     * An 8 bit value indicates the maximum length in bytes of a RFID Code on this device. The
     * value depends on the RFID code range specified by the manufacturer, if media
     * anti-collision identifiers (UID) are used as RFID code, a value of 20 (equals 10 Byte ISO
     * 14443A UID) is recommended.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getMaxRfidCodeLengthAsync() {
        return read(attributes.get(ATTR_MAXRFIDCODELENGTH));
    }

    /**
     * Synchronously get the <i>Max RFID Code Length</i> attribute [attribute ID <b>0x0019</b>].
     * <p>
     * An 8 bit value indicates the maximum length in bytes of a RFID Code on this device. The
     * value depends on the RFID code range specified by the manufacturer, if media
     * anti-collision identifiers (UID) are used as RFID code, a value of 20 (equals 10 Byte ISO
     * 14443A UID) is recommended.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getMaxRfidCodeLength(final long refreshPeriod) {
        if (attributes.get(ATTR_MAXRFIDCODELENGTH).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_MAXRFIDCODELENGTH).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_MAXRFIDCODELENGTH));
    }

    /**
     * Set reporting for the <i>Max RFID Code Length</i> attribute [attribute ID <b>0x0019</b>].
     * <p>
     * An 8 bit value indicates the maximum length in bytes of a RFID Code on this device. The
     * value depends on the RFID code range specified by the manufacturer, if media
     * anti-collision identifiers (UID) are used as RFID code, a value of 20 (equals 10 Byte ISO
     * 14443A UID) is recommended.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setMaxRfidCodeLengthReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_MAXRFIDCODELENGTH), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Min RFID Code Length</i> attribute [attribute ID <b>0x001A</b>].
     * <p>
     * An 8 bit value indicates the minimum length in bytes of a RFID Code on this device. The
     * value depends on the RFID code range specified by the manufacturer, if media
     * anti-collision identifiers (UID) are used as RFID code, a value of 8 (equals 4 Byte ISO
     * 14443A UID) is recommended.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getMinRfidCodeLengthAsync() {
        return read(attributes.get(ATTR_MINRFIDCODELENGTH));
    }

    /**
     * Synchronously get the <i>Min RFID Code Length</i> attribute [attribute ID <b>0x001A</b>].
     * <p>
     * An 8 bit value indicates the minimum length in bytes of a RFID Code on this device. The
     * value depends on the RFID code range specified by the manufacturer, if media
     * anti-collision identifiers (UID) are used as RFID code, a value of 8 (equals 4 Byte ISO
     * 14443A UID) is recommended.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getMinRfidCodeLength(final long refreshPeriod) {
        if (attributes.get(ATTR_MINRFIDCODELENGTH).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_MINRFIDCODELENGTH).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_MINRFIDCODELENGTH));
    }

    /**
     * Set reporting for the <i>Min RFID Code Length</i> attribute [attribute ID <b>0x001A</b>].
     * <p>
     * An 8 bit value indicates the minimum length in bytes of a RFID Code on this device. The
     * value depends on the RFID code range specified by the manufacturer, if media
     * anti-collision identifiers (UID) are used as RFID code, a value of 8 (equals 4 Byte ISO
     * 14443A UID) is recommended.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setMinRfidCodeLengthReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_MINRFIDCODELENGTH), minInterval, maxInterval, reportableChange);
    }

    /**
     * Set the <i>Enable Logging</i> attribute [attribute ID <b>0x0020</b>].
     * <p>
     * Enable/disable event logging. When event logging is enabled, all event messages are
     * stored on the lock for retrieval. Logging events can be but not limited to Tamper Alarm,
     * Lock, Unlock, Autolock, User Code Added, User Code Deleted, Schedule Added, and
     * Schedule Deleted. For a full detail of all the possible alarms and events, please refer
     * to the full list in the Alarm and Event Masks Attribute Set.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param enableLogging the {@link Boolean} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setEnableLogging(final Boolean value) {
        return write(attributes.get(ATTR_ENABLELOGGING), value);
    }

    /**
     * Get the <i>Enable Logging</i> attribute [attribute ID <b>0x0020</b>].
     * <p>
     * Enable/disable event logging. When event logging is enabled, all event messages are
     * stored on the lock for retrieval. Logging events can be but not limited to Tamper Alarm,
     * Lock, Unlock, Autolock, User Code Added, User Code Deleted, Schedule Added, and
     * Schedule Deleted. For a full detail of all the possible alarms and events, please refer
     * to the full list in the Alarm and Event Masks Attribute Set.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getEnableLoggingAsync() {
        return read(attributes.get(ATTR_ENABLELOGGING));
    }

    /**
     * Synchronously get the <i>Enable Logging</i> attribute [attribute ID <b>0x0020</b>].
     * <p>
     * Enable/disable event logging. When event logging is enabled, all event messages are
     * stored on the lock for retrieval. Logging events can be but not limited to Tamper Alarm,
     * Lock, Unlock, Autolock, User Code Added, User Code Deleted, Schedule Added, and
     * Schedule Deleted. For a full detail of all the possible alarms and events, please refer
     * to the full list in the Alarm and Event Masks Attribute Set.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Boolean} attribute value, or null on error
     */
    public Boolean getEnableLogging(final long refreshPeriod) {
        if (attributes.get(ATTR_ENABLELOGGING).isLastValueCurrent(refreshPeriod)) {
            return (Boolean) attributes.get(ATTR_ENABLELOGGING).getLastValue();
        }

        return (Boolean) readSync(attributes.get(ATTR_ENABLELOGGING));
    }

    /**
     * Set the <i>Language</i> attribute [attribute ID <b>0x0021</b>].
     * <p>
     * Modifies the language for the on-screen or audible user interface using three bytes
     * from ISO-639-1. It consists of one byte of length and two bytes for the language code. For
     * example if the language is set to English, the value would be "02 65 6E" for the language
     * code "en"
     * <p>
     * The attribute is of type {@link String}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param language the {@link String} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setLanguage(final String value) {
        return write(attributes.get(ATTR_LANGUAGE), value);
    }

    /**
     * Get the <i>Language</i> attribute [attribute ID <b>0x0021</b>].
     * <p>
     * Modifies the language for the on-screen or audible user interface using three bytes
     * from ISO-639-1. It consists of one byte of length and two bytes for the language code. For
     * example if the language is set to English, the value would be "02 65 6E" for the language
     * code "en"
     * <p>
     * The attribute is of type {@link String}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getLanguageAsync() {
        return read(attributes.get(ATTR_LANGUAGE));
    }

    /**
     * Synchronously get the <i>Language</i> attribute [attribute ID <b>0x0021</b>].
     * <p>
     * Modifies the language for the on-screen or audible user interface using three bytes
     * from ISO-639-1. It consists of one byte of length and two bytes for the language code. For
     * example if the language is set to English, the value would be "02 65 6E" for the language
     * code "en"
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link String}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link String} attribute value, or null on error
     */
    public String getLanguage(final long refreshPeriod) {
        if (attributes.get(ATTR_LANGUAGE).isLastValueCurrent(refreshPeriod)) {
            return (String) attributes.get(ATTR_LANGUAGE).getLastValue();
        }

        return (String) readSync(attributes.get(ATTR_LANGUAGE));
    }

    /**
     * Set the <i>LED Settings</i> attribute [attribute ID <b>0x0022</b>].
     * <p>
     * The settings for the LED support three different modes
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param ledSettings the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setLedSettings(final Integer value) {
        return write(attributes.get(ATTR_LEDSETTINGS), value);
    }

    /**
     * Get the <i>LED Settings</i> attribute [attribute ID <b>0x0022</b>].
     * <p>
     * The settings for the LED support three different modes
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getLedSettingsAsync() {
        return read(attributes.get(ATTR_LEDSETTINGS));
    }

    /**
     * Synchronously get the <i>LED Settings</i> attribute [attribute ID <b>0x0022</b>].
     * <p>
     * The settings for the LED support three different modes
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getLedSettings(final long refreshPeriod) {
        if (attributes.get(ATTR_LEDSETTINGS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_LEDSETTINGS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_LEDSETTINGS));
    }

    /**
     * Set the <i>Auto Relock Time</i> attribute [attribute ID <b>0x0023</b>].
     * <p>
     * The number of seconds to wait after unlocking a lock before it automatically locks
     * again. 0=disabled. If set, unlock operations from any source will be timed. For one time
     * unlock with timeout use the specific command.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param autoRelockTime the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setAutoRelockTime(final Integer value) {
        return write(attributes.get(ATTR_AUTORELOCKTIME), value);
    }

    /**
     * Get the <i>Auto Relock Time</i> attribute [attribute ID <b>0x0023</b>].
     * <p>
     * The number of seconds to wait after unlocking a lock before it automatically locks
     * again. 0=disabled. If set, unlock operations from any source will be timed. For one time
     * unlock with timeout use the specific command.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getAutoRelockTimeAsync() {
        return read(attributes.get(ATTR_AUTORELOCKTIME));
    }

    /**
     * Synchronously get the <i>Auto Relock Time</i> attribute [attribute ID <b>0x0023</b>].
     * <p>
     * The number of seconds to wait after unlocking a lock before it automatically locks
     * again. 0=disabled. If set, unlock operations from any source will be timed. For one time
     * unlock with timeout use the specific command.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getAutoRelockTime(final long refreshPeriod) {
        if (attributes.get(ATTR_AUTORELOCKTIME).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_AUTORELOCKTIME).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_AUTORELOCKTIME));
    }

    /**
     * Set the <i>Sound Volume</i> attribute [attribute ID <b>0x0024</b>].
     * <p>
     * The sound volume on a door lock has three possible settings: silent, low and high volumes
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param soundVolume the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSoundVolume(final Integer value) {
        return write(attributes.get(ATTR_SOUNDVOLUME), value);
    }

    /**
     * Get the <i>Sound Volume</i> attribute [attribute ID <b>0x0024</b>].
     * <p>
     * The sound volume on a door lock has three possible settings: silent, low and high volumes
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSoundVolumeAsync() {
        return read(attributes.get(ATTR_SOUNDVOLUME));
    }

    /**
     * Synchronously get the <i>Sound Volume</i> attribute [attribute ID <b>0x0024</b>].
     * <p>
     * The sound volume on a door lock has three possible settings: silent, low and high volumes
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getSoundVolume(final long refreshPeriod) {
        if (attributes.get(ATTR_SOUNDVOLUME).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_SOUNDVOLUME).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_SOUNDVOLUME));
    }

    /**
     * Set the <i>Operating Mode</i> attribute [attribute ID <b>0x0025</b>].
     * <p>
     * Shows the current operating mode
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param operatingMode the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setOperatingMode(final Integer value) {
        return write(attributes.get(ATTR_OPERATINGMODE), value);
    }

    /**
     * Get the <i>Operating Mode</i> attribute [attribute ID <b>0x0025</b>].
     * <p>
     * Shows the current operating mode
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getOperatingModeAsync() {
        return read(attributes.get(ATTR_OPERATINGMODE));
    }

    /**
     * Synchronously get the <i>Operating Mode</i> attribute [attribute ID <b>0x0025</b>].
     * <p>
     * Shows the current operating mode
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getOperatingMode(final long refreshPeriod) {
        if (attributes.get(ATTR_OPERATINGMODE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_OPERATINGMODE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_OPERATINGMODE));
    }

    /**
     * Get the <i>Supported Operating Modes</i> attribute [attribute ID <b>0x0026</b>].
     * <p>
     * This bitmap contains all operating bits of the Operating Mode Attribute supported by
     * the lock. The value of the enumeration in “Operating Mode” defines the related bit to be
     * set, as shown in Table 7-16. All bits supported by a lock shall be set to zero.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSupportedOperatingModesAsync() {
        return read(attributes.get(ATTR_SUPPORTEDOPERATINGMODES));
    }

    /**
     * Synchronously get the <i>Supported Operating Modes</i> attribute [attribute ID <b>0x0026</b>].
     * <p>
     * This bitmap contains all operating bits of the Operating Mode Attribute supported by
     * the lock. The value of the enumeration in “Operating Mode” defines the related bit to be
     * set, as shown in Table 7-16. All bits supported by a lock shall be set to zero.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getSupportedOperatingModes(final long refreshPeriod) {
        if (attributes.get(ATTR_SUPPORTEDOPERATINGMODES).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_SUPPORTEDOPERATINGMODES).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_SUPPORTEDOPERATINGMODES));
    }

    /**
     * Set reporting for the <i>Supported Operating Modes</i> attribute [attribute ID <b>0x0026</b>].
     * <p>
     * This bitmap contains all operating bits of the Operating Mode Attribute supported by
     * the lock. The value of the enumeration in “Operating Mode” defines the related bit to be
     * set, as shown in Table 7-16. All bits supported by a lock shall be set to zero.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSupportedOperatingModesReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_SUPPORTEDOPERATINGMODES), minInterval, maxInterval);
    }

    /**
     * Get the <i>Default Configuration Register</i> attribute [attribute ID <b>0x0027</b>].
     * <p>
     * This attribute represents the default configurations as they are physically set on the
     * device (example: hardware dip switch setting, etc…) and represents the default
     * setting for some of the attributes within this Operational Setting Attribute Set (for
     * example: LED, Auto Lock, Sound Volume, and Operating Mode attributes).
     * <p>
     * This is a read-only attribute and is intended to allow clients to determine what changes
     * may need to be made without having to query all the included attributes. It may be
     * beneficial for the clients to know what the device’s original settings were in the event
     * that the device needs to be restored to factory default settings.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDefaultConfigurationRegisterAsync() {
        return read(attributes.get(ATTR_DEFAULTCONFIGURATIONREGISTER));
    }

    /**
     * Synchronously get the <i>Default Configuration Register</i> attribute [attribute ID <b>0x0027</b>].
     * <p>
     * This attribute represents the default configurations as they are physically set on the
     * device (example: hardware dip switch setting, etc…) and represents the default
     * setting for some of the attributes within this Operational Setting Attribute Set (for
     * example: LED, Auto Lock, Sound Volume, and Operating Mode attributes).
     * <p>
     * This is a read-only attribute and is intended to allow clients to determine what changes
     * may need to be made without having to query all the included attributes. It may be
     * beneficial for the clients to know what the device’s original settings were in the event
     * that the device needs to be restored to factory default settings.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDefaultConfigurationRegister(final long refreshPeriod) {
        if (attributes.get(ATTR_DEFAULTCONFIGURATIONREGISTER).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DEFAULTCONFIGURATIONREGISTER).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DEFAULTCONFIGURATIONREGISTER));
    }

    /**
     * Set reporting for the <i>Default Configuration Register</i> attribute [attribute ID <b>0x0027</b>].
     * <p>
     * This attribute represents the default configurations as they are physically set on the
     * device (example: hardware dip switch setting, etc…) and represents the default
     * setting for some of the attributes within this Operational Setting Attribute Set (for
     * example: LED, Auto Lock, Sound Volume, and Operating Mode attributes).
     * <p>
     * This is a read-only attribute and is intended to allow clients to determine what changes
     * may need to be made without having to query all the included attributes. It may be
     * beneficial for the clients to know what the device’s original settings were in the event
     * that the device needs to be restored to factory default settings.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDefaultConfigurationRegisterReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_DEFAULTCONFIGURATIONREGISTER), minInterval, maxInterval);
    }

    /**
     * Set the <i>Enable Local Programming</i> attribute [attribute ID <b>0x0028</b>].
     * <p>
     * Enable/disable local programming on the door lock. The local programming features
     * includes but not limited to adding new user codes, deleting existing user codes, add new
     * schedule, deleting existing schedule on the local door lock interfaces. If this value
     * is set to 0x01 or TRUE then local programming is enabled on the door lock. If it is set to
     * 0x00 or FALSE then local programming is disabled on the door lock. Local programming is
     * enabled by default.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param enableLocalProgramming the {@link Boolean} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setEnableLocalProgramming(final Boolean value) {
        return write(attributes.get(ATTR_ENABLELOCALPROGRAMMING), value);
    }

    /**
     * Get the <i>Enable Local Programming</i> attribute [attribute ID <b>0x0028</b>].
     * <p>
     * Enable/disable local programming on the door lock. The local programming features
     * includes but not limited to adding new user codes, deleting existing user codes, add new
     * schedule, deleting existing schedule on the local door lock interfaces. If this value
     * is set to 0x01 or TRUE then local programming is enabled on the door lock. If it is set to
     * 0x00 or FALSE then local programming is disabled on the door lock. Local programming is
     * enabled by default.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getEnableLocalProgrammingAsync() {
        return read(attributes.get(ATTR_ENABLELOCALPROGRAMMING));
    }

    /**
     * Synchronously get the <i>Enable Local Programming</i> attribute [attribute ID <b>0x0028</b>].
     * <p>
     * Enable/disable local programming on the door lock. The local programming features
     * includes but not limited to adding new user codes, deleting existing user codes, add new
     * schedule, deleting existing schedule on the local door lock interfaces. If this value
     * is set to 0x01 or TRUE then local programming is enabled on the door lock. If it is set to
     * 0x00 or FALSE then local programming is disabled on the door lock. Local programming is
     * enabled by default.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Boolean} attribute value, or null on error
     */
    public Boolean getEnableLocalProgramming(final long refreshPeriod) {
        if (attributes.get(ATTR_ENABLELOCALPROGRAMMING).isLastValueCurrent(refreshPeriod)) {
            return (Boolean) attributes.get(ATTR_ENABLELOCALPROGRAMMING).getLastValue();
        }

        return (Boolean) readSync(attributes.get(ATTR_ENABLELOCALPROGRAMMING));
    }

    /**
     * Set the <i>Enable One Touch Locking</i> attribute [attribute ID <b>0x0029</b>].
     * <p>
     * Enable/disable the ability to lock the door lock with a single touch on the door lock.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param enableOneTouchLocking the {@link Boolean} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setEnableOneTouchLocking(final Boolean value) {
        return write(attributes.get(ATTR_ENABLEONETOUCHLOCKING), value);
    }

    /**
     * Get the <i>Enable One Touch Locking</i> attribute [attribute ID <b>0x0029</b>].
     * <p>
     * Enable/disable the ability to lock the door lock with a single touch on the door lock.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getEnableOneTouchLockingAsync() {
        return read(attributes.get(ATTR_ENABLEONETOUCHLOCKING));
    }

    /**
     * Synchronously get the <i>Enable One Touch Locking</i> attribute [attribute ID <b>0x0029</b>].
     * <p>
     * Enable/disable the ability to lock the door lock with a single touch on the door lock.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Boolean} attribute value, or null on error
     */
    public Boolean getEnableOneTouchLocking(final long refreshPeriod) {
        if (attributes.get(ATTR_ENABLEONETOUCHLOCKING).isLastValueCurrent(refreshPeriod)) {
            return (Boolean) attributes.get(ATTR_ENABLEONETOUCHLOCKING).getLastValue();
        }

        return (Boolean) readSync(attributes.get(ATTR_ENABLEONETOUCHLOCKING));
    }

    /**
     * Set the <i>Enable Inside Status Led</i> attribute [attribute ID <b>0x002A</b>].
     * <p>
     * Enable/disable an inside LED that allows the user to see at a glance if the door is locked.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param enableInsideStatusLed the {@link Boolean} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setEnableInsideStatusLed(final Boolean value) {
        return write(attributes.get(ATTR_ENABLEINSIDESTATUSLED), value);
    }

    /**
     * Get the <i>Enable Inside Status Led</i> attribute [attribute ID <b>0x002A</b>].
     * <p>
     * Enable/disable an inside LED that allows the user to see at a glance if the door is locked.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getEnableInsideStatusLedAsync() {
        return read(attributes.get(ATTR_ENABLEINSIDESTATUSLED));
    }

    /**
     * Synchronously get the <i>Enable Inside Status Led</i> attribute [attribute ID <b>0x002A</b>].
     * <p>
     * Enable/disable an inside LED that allows the user to see at a glance if the door is locked.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Boolean} attribute value, or null on error
     */
    public Boolean getEnableInsideStatusLed(final long refreshPeriod) {
        if (attributes.get(ATTR_ENABLEINSIDESTATUSLED).isLastValueCurrent(refreshPeriod)) {
            return (Boolean) attributes.get(ATTR_ENABLEINSIDESTATUSLED).getLastValue();
        }

        return (Boolean) readSync(attributes.get(ATTR_ENABLEINSIDESTATUSLED));
    }

    /**
     * Set the <i>Enable Privacy Mode Button</i> attribute [attribute ID <b>0x002B</b>].
     * <p>
     * Enable/disable a button inside the door that is used to put the lock into privacy mode.
     * When the lock is in privacy mode it cannot be manipulated from the outside.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param enablePrivacyModeButton the {@link Boolean} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setEnablePrivacyModeButton(final Boolean value) {
        return write(attributes.get(ATTR_ENABLEPRIVACYMODEBUTTON), value);
    }

    /**
     * Get the <i>Enable Privacy Mode Button</i> attribute [attribute ID <b>0x002B</b>].
     * <p>
     * Enable/disable a button inside the door that is used to put the lock into privacy mode.
     * When the lock is in privacy mode it cannot be manipulated from the outside.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getEnablePrivacyModeButtonAsync() {
        return read(attributes.get(ATTR_ENABLEPRIVACYMODEBUTTON));
    }

    /**
     * Synchronously get the <i>Enable Privacy Mode Button</i> attribute [attribute ID <b>0x002B</b>].
     * <p>
     * Enable/disable a button inside the door that is used to put the lock into privacy mode.
     * When the lock is in privacy mode it cannot be manipulated from the outside.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Boolean} attribute value, or null on error
     */
    public Boolean getEnablePrivacyModeButton(final long refreshPeriod) {
        if (attributes.get(ATTR_ENABLEPRIVACYMODEBUTTON).isLastValueCurrent(refreshPeriod)) {
            return (Boolean) attributes.get(ATTR_ENABLEPRIVACYMODEBUTTON).getLastValue();
        }

        return (Boolean) readSync(attributes.get(ATTR_ENABLEPRIVACYMODEBUTTON));
    }

    /**
     * Set the <i>Wrong Code Entry Limit</i> attribute [attribute ID <b>0x0030</b>].
     * <p>
     * The number of incorrect codes or RFID presentment attempts a user is allowed to enter
     * before the door will enter a lockout state. The lockout state will be for the duration of
     * UserCodeTemporaryDisableTime.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param wrongCodeEntryLimit the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setWrongCodeEntryLimit(final Integer value) {
        return write(attributes.get(ATTR_WRONGCODEENTRYLIMIT), value);
    }

    /**
     * Get the <i>Wrong Code Entry Limit</i> attribute [attribute ID <b>0x0030</b>].
     * <p>
     * The number of incorrect codes or RFID presentment attempts a user is allowed to enter
     * before the door will enter a lockout state. The lockout state will be for the duration of
     * UserCodeTemporaryDisableTime.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getWrongCodeEntryLimitAsync() {
        return read(attributes.get(ATTR_WRONGCODEENTRYLIMIT));
    }

    /**
     * Synchronously get the <i>Wrong Code Entry Limit</i> attribute [attribute ID <b>0x0030</b>].
     * <p>
     * The number of incorrect codes or RFID presentment attempts a user is allowed to enter
     * before the door will enter a lockout state. The lockout state will be for the duration of
     * UserCodeTemporaryDisableTime.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getWrongCodeEntryLimit(final long refreshPeriod) {
        if (attributes.get(ATTR_WRONGCODEENTRYLIMIT).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_WRONGCODEENTRYLIMIT).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_WRONGCODEENTRYLIMIT));
    }

    /**
     * Set the <i>User Code Temporary Disable Time</i> attribute [attribute ID <b>0x0031</b>].
     * <p>
     * The number of seconds that the lock shuts down following wrong code entry. 1-255
     * seconds. Device can shutdown to lock user out for specified amount of time. (Makes it
     * difficult to try and guess a PIN for the device.)
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param userCodeTemporaryDisableTime the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setUserCodeTemporaryDisableTime(final Integer value) {
        return write(attributes.get(ATTR_USERCODETEMPORARYDISABLETIME), value);
    }

    /**
     * Get the <i>User Code Temporary Disable Time</i> attribute [attribute ID <b>0x0031</b>].
     * <p>
     * The number of seconds that the lock shuts down following wrong code entry. 1-255
     * seconds. Device can shutdown to lock user out for specified amount of time. (Makes it
     * difficult to try and guess a PIN for the device.)
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getUserCodeTemporaryDisableTimeAsync() {
        return read(attributes.get(ATTR_USERCODETEMPORARYDISABLETIME));
    }

    /**
     * Synchronously get the <i>User Code Temporary Disable Time</i> attribute [attribute ID <b>0x0031</b>].
     * <p>
     * The number of seconds that the lock shuts down following wrong code entry. 1-255
     * seconds. Device can shutdown to lock user out for specified amount of time. (Makes it
     * difficult to try and guess a PIN for the device.)
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getUserCodeTemporaryDisableTime(final long refreshPeriod) {
        if (attributes.get(ATTR_USERCODETEMPORARYDISABLETIME).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_USERCODETEMPORARYDISABLETIME).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_USERCODETEMPORARYDISABLETIME));
    }

    /**
     * Set the <i>Send PIN Over The Air</i> attribute [attribute ID <b>0x0032</b>].
     * <p>
     * Boolean set to True if it is ok for the door lock server to send PINs over the air. This
     * attribute determines the behavior of the server’s TX operation. If it is false, then it
     * is not ok for the device to send PIN in any messages over the air.
     * <p>
     * The PIN field within any door lock cluster message shall keep the first octet unchanged
     * and masks the actual code by replacing with 0xFF. For example (PIN "1234" ): If the
     * attribute value is True, 0x04 0x31 0x32 0x33 0x34 shall be used in the PIN field in any door
     * lock cluster message payload. If the attribute value is False, 0x04 0xFF 0xFF 0xFF 0xFF
     * shall be used.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param sendPinOverTheAir the {@link Boolean} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSendPinOverTheAir(final Boolean value) {
        return write(attributes.get(ATTR_SENDPINOVERTHEAIR), value);
    }

    /**
     * Get the <i>Send PIN Over The Air</i> attribute [attribute ID <b>0x0032</b>].
     * <p>
     * Boolean set to True if it is ok for the door lock server to send PINs over the air. This
     * attribute determines the behavior of the server’s TX operation. If it is false, then it
     * is not ok for the device to send PIN in any messages over the air.
     * <p>
     * The PIN field within any door lock cluster message shall keep the first octet unchanged
     * and masks the actual code by replacing with 0xFF. For example (PIN "1234" ): If the
     * attribute value is True, 0x04 0x31 0x32 0x33 0x34 shall be used in the PIN field in any door
     * lock cluster message payload. If the attribute value is False, 0x04 0xFF 0xFF 0xFF 0xFF
     * shall be used.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSendPinOverTheAirAsync() {
        return read(attributes.get(ATTR_SENDPINOVERTHEAIR));
    }

    /**
     * Synchronously get the <i>Send PIN Over The Air</i> attribute [attribute ID <b>0x0032</b>].
     * <p>
     * Boolean set to True if it is ok for the door lock server to send PINs over the air. This
     * attribute determines the behavior of the server’s TX operation. If it is false, then it
     * is not ok for the device to send PIN in any messages over the air.
     * <p>
     * The PIN field within any door lock cluster message shall keep the first octet unchanged
     * and masks the actual code by replacing with 0xFF. For example (PIN "1234" ): If the
     * attribute value is True, 0x04 0x31 0x32 0x33 0x34 shall be used in the PIN field in any door
     * lock cluster message payload. If the attribute value is False, 0x04 0xFF 0xFF 0xFF 0xFF
     * shall be used.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Boolean} attribute value, or null on error
     */
    public Boolean getSendPinOverTheAir(final long refreshPeriod) {
        if (attributes.get(ATTR_SENDPINOVERTHEAIR).isLastValueCurrent(refreshPeriod)) {
            return (Boolean) attributes.get(ATTR_SENDPINOVERTHEAIR).getLastValue();
        }

        return (Boolean) readSync(attributes.get(ATTR_SENDPINOVERTHEAIR));
    }

    /**
     * Set the <i>Require PIN For RF Operation</i> attribute [attribute ID <b>0x0033</b>].
     * <p>
     * Boolean set to True if the door lock server requires that an optional PINs be included in
     * the payload of RF lock operation events like Lock, Unlock and Toggle in order to
     * function.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param requirePinForRfOperation the {@link Boolean} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setRequirePinForRfOperation(final Boolean value) {
        return write(attributes.get(ATTR_REQUIREPINFORRFOPERATION), value);
    }

    /**
     * Get the <i>Require PIN For RF Operation</i> attribute [attribute ID <b>0x0033</b>].
     * <p>
     * Boolean set to True if the door lock server requires that an optional PINs be included in
     * the payload of RF lock operation events like Lock, Unlock and Toggle in order to
     * function.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getRequirePinForRfOperationAsync() {
        return read(attributes.get(ATTR_REQUIREPINFORRFOPERATION));
    }

    /**
     * Synchronously get the <i>Require PIN For RF Operation</i> attribute [attribute ID <b>0x0033</b>].
     * <p>
     * Boolean set to True if the door lock server requires that an optional PINs be included in
     * the payload of RF lock operation events like Lock, Unlock and Toggle in order to
     * function.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Boolean}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Boolean} attribute value, or null on error
     */
    public Boolean getRequirePinForRfOperation(final long refreshPeriod) {
        if (attributes.get(ATTR_REQUIREPINFORRFOPERATION).isLastValueCurrent(refreshPeriod)) {
            return (Boolean) attributes.get(ATTR_REQUIREPINFORRFOPERATION).getLastValue();
        }

        return (Boolean) readSync(attributes.get(ATTR_REQUIREPINFORRFOPERATION));
    }

    /**
     * Get the <i>ZigBee Security Level</i> attribute [attribute ID <b>0x0034</b>].
     * <p>
     * Door locks may sometimes wish to implement a higher level of security within the
     * application protocol in additional to the default network security. For instance a
     * door lock may wish to use additional APS security for cluster transactions. This
     * protects the door lock against being controlled by any other devices which have access
     * to the network key.
     * <p>
     * The Security Level attribute allows the door lock manufacturer to indicate what level
     * of security the doorlock requires.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getZigbeeSecurityLevelAsync() {
        return read(attributes.get(ATTR_ZIGBEESECURITYLEVEL));
    }

    /**
     * Synchronously get the <i>ZigBee Security Level</i> attribute [attribute ID <b>0x0034</b>].
     * <p>
     * Door locks may sometimes wish to implement a higher level of security within the
     * application protocol in additional to the default network security. For instance a
     * door lock may wish to use additional APS security for cluster transactions. This
     * protects the door lock against being controlled by any other devices which have access
     * to the network key.
     * <p>
     * The Security Level attribute allows the door lock manufacturer to indicate what level
     * of security the doorlock requires.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getZigbeeSecurityLevel(final long refreshPeriod) {
        if (attributes.get(ATTR_ZIGBEESECURITYLEVEL).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ZIGBEESECURITYLEVEL).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ZIGBEESECURITYLEVEL));
    }

    /**
     * Set reporting for the <i>ZigBee Security Level</i> attribute [attribute ID <b>0x0034</b>].
     * <p>
     * Door locks may sometimes wish to implement a higher level of security within the
     * application protocol in additional to the default network security. For instance a
     * door lock may wish to use additional APS security for cluster transactions. This
     * protects the door lock against being controlled by any other devices which have access
     * to the network key.
     * <p>
     * The Security Level attribute allows the door lock manufacturer to indicate what level
     * of security the doorlock requires.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setZigbeeSecurityLevelReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_ZIGBEESECURITYLEVEL), minInterval, maxInterval);
    }

    /**
     * Set the <i>Alarm Mask</i> attribute [attribute ID <b>0x0040</b>].
     * <p>
     * The alarm mask is used to turn on/off alarms for particular functions. Alarms for an
     * alarm group are enabled if the associated alarm mask bit is set. Each bit represents a
     * group of alarms. Entire alarm groups can be turned on or off by setting or clearing the
     * associated bit in the alarm mask.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param alarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_ALARMMASK), value);
    }

    /**
     * Get the <i>Alarm Mask</i> attribute [attribute ID <b>0x0040</b>].
     * <p>
     * The alarm mask is used to turn on/off alarms for particular functions. Alarms for an
     * alarm group are enabled if the associated alarm mask bit is set. Each bit represents a
     * group of alarms. Entire alarm groups can be turned on or off by setting or clearing the
     * associated bit in the alarm mask.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getAlarmMaskAsync() {
        return read(attributes.get(ATTR_ALARMMASK));
    }

    /**
     * Synchronously get the <i>Alarm Mask</i> attribute [attribute ID <b>0x0040</b>].
     * <p>
     * The alarm mask is used to turn on/off alarms for particular functions. Alarms for an
     * alarm group are enabled if the associated alarm mask bit is set. Each bit represents a
     * group of alarms. Entire alarm groups can be turned on or off by setting or clearing the
     * associated bit in the alarm mask.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_ALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ALARMMASK));
    }

    /**
     * Set the <i>Keypad Operation Event Mask</i> attribute [attribute ID <b>0x0041</b>].
     * <p>
     * Event mask used to turn on and off the transmission of keypad operation events. This mask
     * DOES NOT apply to the storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param keypadOperationEventMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setKeypadOperationEventMask(final Integer value) {
        return write(attributes.get(ATTR_KEYPADOPERATIONEVENTMASK), value);
    }

    /**
     * Get the <i>Keypad Operation Event Mask</i> attribute [attribute ID <b>0x0041</b>].
     * <p>
     * Event mask used to turn on and off the transmission of keypad operation events. This mask
     * DOES NOT apply to the storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getKeypadOperationEventMaskAsync() {
        return read(attributes.get(ATTR_KEYPADOPERATIONEVENTMASK));
    }

    /**
     * Synchronously get the <i>Keypad Operation Event Mask</i> attribute [attribute ID <b>0x0041</b>].
     * <p>
     * Event mask used to turn on and off the transmission of keypad operation events. This mask
     * DOES NOT apply to the storing of events in the report table.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getKeypadOperationEventMask(final long refreshPeriod) {
        if (attributes.get(ATTR_KEYPADOPERATIONEVENTMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_KEYPADOPERATIONEVENTMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_KEYPADOPERATIONEVENTMASK));
    }

    /**
     * Set the <i>RF Operation Event Mask</i> attribute [attribute ID <b>0x0042</b>].
     * <p>
     * Event mask used to turn on and off the transmission of RF operation events. This mask DOES
     * NOT apply to the storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param rfOperationEventMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setRfOperationEventMask(final Integer value) {
        return write(attributes.get(ATTR_RFOPERATIONEVENTMASK), value);
    }

    /**
     * Get the <i>RF Operation Event Mask</i> attribute [attribute ID <b>0x0042</b>].
     * <p>
     * Event mask used to turn on and off the transmission of RF operation events. This mask DOES
     * NOT apply to the storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getRfOperationEventMaskAsync() {
        return read(attributes.get(ATTR_RFOPERATIONEVENTMASK));
    }

    /**
     * Synchronously get the <i>RF Operation Event Mask</i> attribute [attribute ID <b>0x0042</b>].
     * <p>
     * Event mask used to turn on and off the transmission of RF operation events. This mask DOES
     * NOT apply to the storing of events in the report table.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getRfOperationEventMask(final long refreshPeriod) {
        if (attributes.get(ATTR_RFOPERATIONEVENTMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_RFOPERATIONEVENTMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_RFOPERATIONEVENTMASK));
    }

    /**
     * Set the <i>Manual Operation Event Mask</i> attribute [attribute ID <b>0x0043</b>].
     * <p>
     * Event mask used to turn on and off manual operation events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param manualOperationEventMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setManualOperationEventMask(final Integer value) {
        return write(attributes.get(ATTR_MANUALOPERATIONEVENTMASK), value);
    }

    /**
     * Get the <i>Manual Operation Event Mask</i> attribute [attribute ID <b>0x0043</b>].
     * <p>
     * Event mask used to turn on and off manual operation events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getManualOperationEventMaskAsync() {
        return read(attributes.get(ATTR_MANUALOPERATIONEVENTMASK));
    }

    /**
     * Synchronously get the <i>Manual Operation Event Mask</i> attribute [attribute ID <b>0x0043</b>].
     * <p>
     * Event mask used to turn on and off manual operation events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getManualOperationEventMask(final long refreshPeriod) {
        if (attributes.get(ATTR_MANUALOPERATIONEVENTMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_MANUALOPERATIONEVENTMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_MANUALOPERATIONEVENTMASK));
    }

    /**
     * Set the <i>RFID Operation Event Mask</i> attribute [attribute ID <b>0x0044</b>].
     * <p>
     * Event mask used to turn on and off RFID operation events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param rfidOperationEventMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setRfidOperationEventMask(final Integer value) {
        return write(attributes.get(ATTR_RFIDOPERATIONEVENTMASK), value);
    }

    /**
     * Get the <i>RFID Operation Event Mask</i> attribute [attribute ID <b>0x0044</b>].
     * <p>
     * Event mask used to turn on and off RFID operation events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getRfidOperationEventMaskAsync() {
        return read(attributes.get(ATTR_RFIDOPERATIONEVENTMASK));
    }

    /**
     * Synchronously get the <i>RFID Operation Event Mask</i> attribute [attribute ID <b>0x0044</b>].
     * <p>
     * Event mask used to turn on and off RFID operation events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getRfidOperationEventMask(final long refreshPeriod) {
        if (attributes.get(ATTR_RFIDOPERATIONEVENTMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_RFIDOPERATIONEVENTMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_RFIDOPERATIONEVENTMASK));
    }

    /**
     * Set the <i>Keypad Programming Event Mask</i> attribute [attribute ID <b>0x0045</b>].
     * <p>
     * Event mask used to turn on and off keypad programming events. This mask DOES NOT apply to
     * the storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param keypadProgrammingEventMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setKeypadProgrammingEventMask(final Integer value) {
        return write(attributes.get(ATTR_KEYPADPROGRAMMINGEVENTMASK), value);
    }

    /**
     * Get the <i>Keypad Programming Event Mask</i> attribute [attribute ID <b>0x0045</b>].
     * <p>
     * Event mask used to turn on and off keypad programming events. This mask DOES NOT apply to
     * the storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getKeypadProgrammingEventMaskAsync() {
        return read(attributes.get(ATTR_KEYPADPROGRAMMINGEVENTMASK));
    }

    /**
     * Synchronously get the <i>Keypad Programming Event Mask</i> attribute [attribute ID <b>0x0045</b>].
     * <p>
     * Event mask used to turn on and off keypad programming events. This mask DOES NOT apply to
     * the storing of events in the report table.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getKeypadProgrammingEventMask(final long refreshPeriod) {
        if (attributes.get(ATTR_KEYPADPROGRAMMINGEVENTMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_KEYPADPROGRAMMINGEVENTMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_KEYPADPROGRAMMINGEVENTMASK));
    }

    /**
     * Set the <i>RF Programming Event Mask</i> attribute [attribute ID <b>0x0046</b>].
     * <p>
     * Event mask used to turn on and off RF programming events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param rfProgrammingEventMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setRfProgrammingEventMask(final Integer value) {
        return write(attributes.get(ATTR_RFPROGRAMMINGEVENTMASK), value);
    }

    /**
     * Get the <i>RF Programming Event Mask</i> attribute [attribute ID <b>0x0046</b>].
     * <p>
     * Event mask used to turn on and off RF programming events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getRfProgrammingEventMaskAsync() {
        return read(attributes.get(ATTR_RFPROGRAMMINGEVENTMASK));
    }

    /**
     * Synchronously get the <i>RF Programming Event Mask</i> attribute [attribute ID <b>0x0046</b>].
     * <p>
     * Event mask used to turn on and off RF programming events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getRfProgrammingEventMask(final long refreshPeriod) {
        if (attributes.get(ATTR_RFPROGRAMMINGEVENTMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_RFPROGRAMMINGEVENTMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_RFPROGRAMMINGEVENTMASK));
    }

    /**
     * Set the <i>RFID Programming Event Mask</i> attribute [attribute ID <b>0x0047</b>].
     * <p>
     * Event mask used to turn on and off RFID programming events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param rfidProgrammingEventMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setRfidProgrammingEventMask(final Integer value) {
        return write(attributes.get(ATTR_RFIDPROGRAMMINGEVENTMASK), value);
    }

    /**
     * Get the <i>RFID Programming Event Mask</i> attribute [attribute ID <b>0x0047</b>].
     * <p>
     * Event mask used to turn on and off RFID programming events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getRfidProgrammingEventMaskAsync() {
        return read(attributes.get(ATTR_RFIDPROGRAMMINGEVENTMASK));
    }

    /**
     * Synchronously get the <i>RFID Programming Event Mask</i> attribute [attribute ID <b>0x0047</b>].
     * <p>
     * Event mask used to turn on and off RFID programming events. This mask DOES NOT apply to the
     * storing of events in the report table.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getRfidProgrammingEventMask(final long refreshPeriod) {
        if (attributes.get(ATTR_RFIDPROGRAMMINGEVENTMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_RFIDPROGRAMMINGEVENTMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_RFIDPROGRAMMINGEVENTMASK));
    }

    /**
     * The Lock Door Command
     * <p>
     * This command causes the lock device to lock the door. As of HA 1.2, this command includes
     * an optional code for the lock. The door lock may require a PIN depending on the value of the
     * [Require PIN for RF Operation attribute]
     *
     * @param pinCode {@link ByteArray} PIN Code
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> lockDoorCommand(ByteArray pinCode) {
        LockDoorCommand command = new LockDoorCommand();

        // Set the fields
        command.setPinCode(pinCode);

        return send(command);
    }

    /**
     * The Unlock Door Command
     * <p>
     * This command causes the lock device to unlock the door. As of HA 1.2, this command
     * includes an optional code for the lock. The door lock may require a code depending on the
     * value of the [Require PIN for RF Operation attribute].
     * <p>
     *
     * <p>
     * <b>Note:</b> If the attribute AutoRelockTime is supported the lock will close when the auto relock
     * time has expired
     *
     * @param pinCode {@link ByteArray} PIN Code
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> unlockDoorCommand(ByteArray pinCode) {
        UnlockDoorCommand command = new UnlockDoorCommand();

        // Set the fields
        command.setPinCode(pinCode);

        return send(command);
    }

    /**
     * The Toggle
     * <p>
     * Request the status of the lock. As of HA 1.2, this command includes an optional code for
     * the lock. The door lock may require a code depending on the value of the [Require PIN for RF
     * Operation attribute]
     *
     * @param pin {@link String} PIN
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> toggle(String pin) {
        Toggle command = new Toggle();

        // Set the fields
        command.setPin(pin);

        return send(command);
    }

    /**
     * The Unlock With Timeout
     * <p>
     * This command causes the lock device to unlock the door with a timeout parameter. After
     * the time in seconds specified in the timeout field, the lock device will relock itself
     * automatically. This timeout parameter is only temporary for this message transition
     * only and overrides the default relock time as specified in the [Auto Relock Time
     * attribute] attribute. If the door lock device is not capable of or does not want to
     * support temporary Relock Timeout, it should not support this optional command.
     *
     * @param timeoutInSeconds {@link Integer} Timeout In Seconds
     * @param pin {@link String} PIN
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> unlockWithTimeout(Integer timeoutInSeconds, String pin) {
        UnlockWithTimeout command = new UnlockWithTimeout();

        // Set the fields
        command.setTimeoutInSeconds(timeoutInSeconds);
        command.setPin(pin);

        return send(command);
    }

    /**
     * The Lock Door Response
     * <p>
     * This command is sent in response to a Lock command with one status byte payload. The
     * Status field shall be set to SUCCESS or FAILURE.
     * <p>
     * The status byte only indicates if the message has received successfully. To determine
     * the lock and/or door status, the client should query to [Lock State attribute] and [Door
     * State attribute]
     *
     * @param status {@link Integer} Status
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> lockDoorResponse(Integer status) {
        LockDoorResponse command = new LockDoorResponse();

        // Set the fields
        command.setStatus(status);

        return send(command);
    }

    /**
     * The Unlock Door Response
     * <p>
     * This command is sent in response to a Toggle command with one status byte payload. The
     * Status field shall be set to SUCCESS or FAILURE.
     * <p>
     * The status byte only indicates if the message has received successfully. To determine
     * the lock and/or door status, the client should query to [Lock State attribute] and [Door
     * State attribute].
     *
     * @param status {@link Integer} Status
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> unlockDoorResponse(Integer status) {
        UnlockDoorResponse command = new UnlockDoorResponse();

        // Set the fields
        command.setStatus(status);

        return send(command);
    }

    /**
     * The Toggle Response
     * <p>
     * This command is sent in response to a Toggle command with one status byte payload. The
     * Status field shall be set to SUCCESS or FAILURE.
     * <p>
     * The status byte only indicates if the message has received successfully. To determine
     * the lock and/or door status, the client should query to [Lock State attribute] and [Door
     * State attribute].
     *
     * @param status {@link Integer} Status
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> toggleResponse(Integer status) {
        ToggleResponse command = new ToggleResponse();

        // Set the fields
        command.setStatus(status);

        return send(command);
    }

    /**
     * The Unlock With Timeout Response
     * <p>
     * This command is sent in response to an Unlock with Timeout command with one status byte
     * payload. The Status field shall be set to SUCCESS or FAILURE.
     * <p>
     * The status byte only indicates if the message has received successfully. To determine
     * status, the client should query to [Lock State attribute] and [Door State attribute].
     *
     * @param status {@link Integer} Status
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> unlockWithTimeoutResponse(Integer status) {
        UnlockWithTimeoutResponse command = new UnlockWithTimeoutResponse();

        // Set the fields
        command.setStatus(status);

        return send(command);
    }

    @Override
    public ZclCommand getCommandFromId(int commandId) {
        switch (commandId) {
            case 0x00: // LOCK_DOOR_COMMAND
                return new LockDoorCommand();
            case 0x01: // UNLOCK_DOOR_COMMAND
                return new UnlockDoorCommand();
            case 0x02: // TOGGLE
                return new Toggle();
            case 0x03: // UNLOCK_WITH_TIMEOUT
                return new UnlockWithTimeout();
            default:
                return null;
        }
    }

    @Override
    public ZclCommand getResponseFromId(int commandId) {
        switch (commandId) {
            case 0x00: // LOCK_DOOR_RESPONSE
                return new LockDoorResponse();
            case 0x01: // UNLOCK_DOOR_RESPONSE
                return new UnlockDoorResponse();
            case 0x02: // TOGGLE_RESPONSE
                return new ToggleResponse();
            case 0x03: // UNLOCK_WITH_TIMEOUT_RESPONSE
                return new UnlockWithTimeoutResponse();
            default:
                return null;
        }
    }
}
