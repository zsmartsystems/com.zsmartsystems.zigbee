/**
 * Copyright (c) 2016-2019 by the respective copyright holders.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package com.zsmartsystems.zigbee.zcl.clusters;

import java.util.Calendar;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Future;

import javax.annotation.Generated;

import com.zsmartsystems.zigbee.CommandResult;
import com.zsmartsystems.zigbee.ZigBeeEndpoint;
import com.zsmartsystems.zigbee.zcl.ZclAttribute;
import com.zsmartsystems.zigbee.zcl.ZclCluster;
import com.zsmartsystems.zigbee.zcl.ZclCommand;
import com.zsmartsystems.zigbee.zcl.clusters.metering.ChangeSupply;
import com.zsmartsystems.zigbee.zcl.clusters.metering.ConfigureMirror;
import com.zsmartsystems.zigbee.zcl.clusters.metering.ConfigureNotificationFlags;
import com.zsmartsystems.zigbee.zcl.clusters.metering.ConfigureNotificationScheme;
import com.zsmartsystems.zigbee.zcl.clusters.metering.GetNotifiedMessage;
import com.zsmartsystems.zigbee.zcl.clusters.metering.GetProfile;
import com.zsmartsystems.zigbee.zcl.clusters.metering.GetProfileResponse;
import com.zsmartsystems.zigbee.zcl.clusters.metering.GetSampledData;
import com.zsmartsystems.zigbee.zcl.clusters.metering.GetSampledDataResponse;
import com.zsmartsystems.zigbee.zcl.clusters.metering.GetSnapshot;
import com.zsmartsystems.zigbee.zcl.clusters.metering.LocalChangeSupply;
import com.zsmartsystems.zigbee.zcl.clusters.metering.MirrorRemoved;
import com.zsmartsystems.zigbee.zcl.clusters.metering.MirrorReportAttributeResponse;
import com.zsmartsystems.zigbee.zcl.clusters.metering.NotificationCommandSubPayload;
import com.zsmartsystems.zigbee.zcl.clusters.metering.PublishSnapshot;
import com.zsmartsystems.zigbee.zcl.clusters.metering.RemoveMirror;
import com.zsmartsystems.zigbee.zcl.clusters.metering.RequestFastPollMode;
import com.zsmartsystems.zigbee.zcl.clusters.metering.RequestFastPollModeResponse;
import com.zsmartsystems.zigbee.zcl.clusters.metering.RequestMirror;
import com.zsmartsystems.zigbee.zcl.clusters.metering.RequestMirrorResponse;
import com.zsmartsystems.zigbee.zcl.clusters.metering.ResetLoadLimitCounter;
import com.zsmartsystems.zigbee.zcl.clusters.metering.ScheduleSnapshot;
import com.zsmartsystems.zigbee.zcl.clusters.metering.ScheduleSnapshotResponse;
import com.zsmartsystems.zigbee.zcl.clusters.metering.SetSupplyStatus;
import com.zsmartsystems.zigbee.zcl.clusters.metering.SetUncontrolledFlowThreshold;
import com.zsmartsystems.zigbee.zcl.clusters.metering.SnapshotResponsePayload;
import com.zsmartsystems.zigbee.zcl.clusters.metering.SnapshotSchedulePayload;
import com.zsmartsystems.zigbee.zcl.clusters.metering.StartSampling;
import com.zsmartsystems.zigbee.zcl.clusters.metering.StartSamplingResponse;
import com.zsmartsystems.zigbee.zcl.clusters.metering.SupplyStatusResponse;
import com.zsmartsystems.zigbee.zcl.clusters.metering.TakeSnapshot;
import com.zsmartsystems.zigbee.zcl.clusters.metering.TakeSnapshotResponse;
import com.zsmartsystems.zigbee.zcl.field.ByteArray;
import com.zsmartsystems.zigbee.zcl.protocol.ZclClusterType;
import com.zsmartsystems.zigbee.zcl.protocol.ZclDataType;

/**
 * <b>Metering</b> cluster implementation (<i>Cluster ID 0x0702</i>).
 * <p>
 * The Metering Cluster provides a mechanism to retrieve usage information from Electric,
 * Gas, Water, and potentially Thermal metering devices. These devices can operate on either
 * battery or mains power, and can have a wide variety of sophistication. The Metering Cluster
 * is designed to provide flexibility while limiting capabilities to a set number of metered
 * information types. More advanced forms or data sets from metering devices will be supported
 * in the Smart Energy Tunneling Cluster
 * <p>
 * Code is auto-generated. Modifications may be overwritten!
 */
@Generated(value = "com.zsmartsystems.zigbee.autocode.ZigBeeCodeGenerator", date = "2019-02-26T20:57:36Z")
public class ZclMeteringCluster extends ZclCluster {
    /**
     * The ZigBee Cluster Library Cluster ID
     */
    public static final int CLUSTER_ID = 0x0702;

    /**
     * The ZigBee Cluster Library Cluster Name
     */
    public static final String CLUSTER_NAME = "Metering";

    // Attribute constants
    /**
     * The FunctionalNotificationFlags attribute is implemented as a set of bit flags which
     * are have a predefined action associated with a bit that is not based on a specific
     * command, but may require the Mirrored device to trigger some additional functionality
     * within the system.
     */
    public static final int ATTR_FUNCTIONALNOTIFICATIONFLAGS = 0x0000;
    /**
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     */
    public static final int ATTR_NOTIFICATIONFLAGS2 = 0x0003;
    /**
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     */
    public static final int ATTR_NOTIFICATIONFLAGS3 = 0x0004;
    /**
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     */
    public static final int ATTR_NOTIFICATIONFLAGS4 = 0x0005;
    /**
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     */
    public static final int ATTR_NOTIFICATIONFLAGS5 = 0x0006;
    /**
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     */
    public static final int ATTR_NOTIFICATIONFLAGS6 = 0x0007;
    /**
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     */
    public static final int ATTR_NOTIFICATIONFLAGS7 = 0x0008;
    /**
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     */
    public static final int ATTR_NOTIFICATIONFLAGS8 = 0x0009;
    /**
     * CurrentSummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered and consumed in the premises. CurrentSummationDelivered is
     * mandatory and must be provided as part of the minimum data set to be provided by the
     * metering device. CurrentSummationDelivered is updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTSUMMATIONDELIVERED = 0x0000;
    /**
     * CurrentSummationReceived represents the most recent summed value of Energy, Gas, or
     * Water generated and delivered from the premises. If optionally provided,
     * CurrentSummationReceived is updated continuously as new measurements are made.
     */
    public static final int ATTR_CURRENTSUMMATIONRECEIVED = 0x0001;
    /**
     * CurrentMaxDemandDelivered represents the maximum demand or rate of delivered value
     * of Energy, Gas, or Water being utilized at the premises. If optionally provided,
     * CurrentMaxDemandDelivered is updated continuously as new measurements are made.
     */
    public static final int ATTR_CURRENTMAXDEMANDDELIVERED = 0x0002;
    /**
     * CurrentMaxDemandReceived represents the maximum demand or rate of received value of
     * Energy, Gas, or Water being utilized by the utility. If optionally provided,
     * CurrentMaxDemandReceived is updated continuously as new measurements are made.
     */
    public static final int ATTR_CURRENTMAXDEMANDRECEIVED = 0x0003;
    /**
     * DFTSummation represents a snapshot of attribute CurrentSummationDelivered
     * captured at the time indicated by attribute DailyFreezeTime. If optionally provided,
     * DFTSummation is updated once every 24 hours.
     */
    public static final int ATTR_DFTSUMMATION = 0x0004;
    /**
     * DailyFreezeTime represents the time of day when DFTSummation is captured.
     * DailyFreezeTime is an unsigned 16-bit value representing the hour and minutes for DFT.
     * <p>
     * Bits 0 to 7: Range of 0 to 0x3B representing the number of minutes past the top of the hour.
     * <p>
     * Bits 8 to 15: Range of 0 to 0x17 representing the hour of the day (in 24-hour format). Note
     * that midnight shall be represented as 00:00 only.
     */
    public static final int ATTR_DAILYFREEZETIME = 0x0005;
    /**
     * PowerFactor contains the Average Power Factor ratio in 1/100ths. Valid values are 0 to
     * 99.
     */
    public static final int ATTR_POWERFACTOR = 0x0006;
    /**
     * The ReadingSnapshotTime attribute represents the last time all of the
     * CurrentSummationDelivered, CurrentSummationReceived,
     * CurrentMaxDemandDelivered, and CurrentMaxDemandReceived attributes that are
     * supported by the device were updated.
     */
    public static final int ATTR_READINGSNAPSHOTTIME = 0x0007;
    /**
     * The CurrentMaxDemandDeliveredTime attribute represents the time when
     * CurrentMaxDemandDelivered reading was captured.
     */
    public static final int ATTR_CURRENTMAXDEMANDDELIVEREDTIME = 0x0008;
    /**
     * The CurrentMaxDemandReceivedTime attribute represents the time when
     * CurrentMaxDemandReceived reading was captured.
     */
    public static final int ATTR_CURRENTMAXDEMANDRECEIVEDTIME = 0x0009;
    /**
     * The DefaultUpdatePeriod attribute represents the interval (seconds) at which the
     * InstantaneousDemand attribute is updated when not in fast poll mode.
     * InstantaneousDemand may be continuously updated as new measurements are acquired,
     * but at a minimum InstantaneousDemand must be updated at the DefaultUpdatePeriod. The
     * DefaultUpdatePeriod may apply to other attributes as defined by the device
     * manufacturer.
     */
    public static final int ATTR_DEFAULTUPDATEPERIOD = 0x000A;
    /**
     * The FastPollUpdatePeriod attribute represents the interval (seconds) at which the
     * InstantaneousDemandattribute is updated when in fast poll mode.
     * InstantaneousDemand may be continuously updated as new measurements are acquired,
     * but at a minimum, InstantaneousDemand must be updated at the FastPollUpdatePeriod.
     * The FastPollUpdatePeriod may apply to other attributes as defined by the device
     * manufacturer.
     */
    public static final int ATTR_FASTPOLLUPDATEPERIOD = 0x000B;
    /**
     * The CurrentBlockPeriodConsumptionDelivered attribute represents the most recent
     * summed value of Energy, Gas or Water delivered and consumed in the premises during the
     * Block Tariff Period.
     * <p>
     * The CurrentBlockPeriodConsumptionDelivered is reset at the start of each Block
     * Tariff Period.
     */
    public static final int ATTR_CURRENTBLOCKPERIODCONSUMPTIONDELIVERED = 0x000C;
    /**
     * The DailyConsumptionTarget attribute is a daily target consumption amount that can be
     * displayed to the consumer on a HAN device, with the intent that it can be used to compare to
     * actual daily consumption (e.g. compare to the CurrentDayConsumptionDelivered).
     */
    public static final int ATTR_DAILYCONSUMPTIONTARGET = 0x000D;
    /**
     * When Block Tariffs are enabled, CurrentBlock is an 8-bit Enumeration which indicates
     * the currently active block. If blocks are active then the current active block is based
     * on the CurrentBlockPeriodConsumptionDelivered and the block thresholds. Block 1 is
     * active when the value of CurrentBlockPeriodConsumptionDelivered is less than or
     * equal to the Block1Threshold value, Block 2 is active when
     * CurrentBlockPeriodConsumptionDelivered is greater than Block1Threshold value and
     * less than or equal to the8 Block2Threshold value, and so on. Block 16 is active when the
     * value of CurrentBlockPeriodConsumptionDelivered is greater than Block15Threshold
     * value.
     */
    public static final int ATTR_CURRENTBLOCK = 0x000E;
    /**
     * The ProfileIntervalPeriod attribute is currently included in the Get Profile
     * Response command payload, but does not appear in an attribute set. This represents the
     * duration of each interval. ProfileIntervalPeriod represents the interval or time
     * frame used to capture metered Energy, Gas, and Water consumption for profiling
     * purposes.
     */
    public static final int ATTR_PROFILEINTERVALPERIOD = 0x000F;
    public static final int ATTR_INTERVALREADREPORTINGPERIOD = 0x0010;
    /**
     * The PresetReadingTime attribute represents the time of day (in quarter hour
     * increments) at which the meter will wake up and report a register reading even if there
     * has been no consumption for the previous 24 hours. PresetReadingTime is an unsigned
     * 16-bit value representing the hour and minutes.
     */
    public static final int ATTR_PRESETREADINGTIME = 0x0011;
    /**
     * The VolumePerReport attribute represents the volume per report increment from the
     * water or gas meter. For example a gas meter might be set to report its register reading for
     * every time 1 cubic meter of gas is used. For a water meter it might report the register
     * value every 10 liters of water usage.
     */
    public static final int ATTR_VOLUMEPERREPORT = 0x0012;
    /**
     * The FlowRestriction attribute represents the volume per minute limit set in the flow
     * restrictor. This applies to water but not for gas. A setting of 0xFF indicates this
     * feature is disabled.
     */
    public static final int ATTR_FLOWRESTRICTION = 0x0013;
    /**
     * The SupplyStatus attribute represents the state of the supply at the customer's
     * premises.
     */
    public static final int ATTR_SUPPLYSTATUS = 0x0014;
    /**
     * CurrentInletEnergyCarrierSummation is the current integrated volume of a given
     * energy carrier measured on the inlet. The formatting and unit of measure for this value
     * is specified in the EnergyCarrierUnitOfMeasure and
     * EnergyCarrierSummationFormatting attributes
     */
    public static final int ATTR_CURRENTINLETENERGYCARRIERSUMMATION = 0x0015;
    /**
     * CurrentOutletEnergyCarrierSummation is the current integrated volume of a given
     * energy carrier measured on the outlet. The formatting and unit of measure for this value
     * is specified in the EnergyCarrierUnitOfMeasure and
     * EnergyCarrierSummationFormatting attributes.
     */
    public static final int ATTR_CURRENTOUTLETENERGYCARRIERSUMMATION = 0x0016;
    /**
     * InletTemperature is the temperature measured on the energy carrier inlet.
     */
    public static final int ATTR_INLETTEMPERATURE = 0x0017;
    /**
     * OutletTemperature is the temperature measured on the energy carrier outlet.
     */
    public static final int ATTR_OUTLETTEMPERATURE = 0x0018;
    /**
     * ControlTemperature is a reference temperature measured on the meter used to validate
     * the Inlet/Outlet temperatures.
     */
    public static final int ATTR_CONTROLTEMPERATURE = 0x0019;
    /**
     * CurrentInletEnergyCarrierDemand is the current absolute demand on the energy
     * carrier inlet.
     */
    public static final int ATTR_CURRENTINLETENERGYCARRIERDEMAND = 0x001A;
    /**
     * CurrentOutletEnergyCarrierDemand is the current absolute demand on the energy
     * carrier outlet.
     */
    public static final int ATTR_CURRENTOUTLETENERGYCARRIERDEMAND = 0x001B;
    /**
     * The PreviousBlockPeriodConsumptionDelivered attribute represents the total value
     * of Energy, Gas or Water delivered and consumed in the premises at the end of the previous
     * Block Tariff Period. If supported, the PreviousBlockPeriodConsumptionDelivered
     * attribute is updated at the end of each Block Tariff Period.
     */
    public static final int ATTR_PREVIOUSBLOCKPERIODCONSUMPTIONDELIVERED = 0x001C;
    /**
     * The CurrentBlockPeriodConsumptionReceived attribute represents the most recent
     * summed value of Energy, Gas or Water received by the energy supplier from the premises
     * during the Block Tariff Period. The CurrentBlockPeriodConsumptionReceived
     * attribute is reset at the start of each Block Tariff Period.
     */
    public static final int ATTR_CURRENTBLOCKPERIODCONSUMPTIONRECEIVED = 0x001D;
    /**
     * When Block Tariffs are enabled, CurrentBlockReceived is an 8-bit Enumeration which
     * indicates the currently active block. If blocks are active then the current active
     * block is based on the CurrentBlockPeriodConsumptionReceived and the block
     * thresholds. Block 1 is active when the value of
     * CurrentBlockPeriodConsumptionReceived is less than or equal to the Block1Threshold
     * value, Block 2 is active when CurrentBlockPeriodConsumptionReceived is greater than
     * Block1Threshold value and less than or equal to the Block2Threshold value, and so on.
     * Block 16 is active when the value of CurrentBlockPeriodConsumptionReceived is
     * greater than Block15Threshold value.
     */
    public static final int ATTR_CURRENTBLOCKRECEIVED = 0x001E;
    /**
     * DFTSummationReceived represents a snapshot of attribute CurrentSummationReceived
     * captured at the time indicated by the DailyFreezeTime attribute.
     */
    public static final int ATTR_DFTSUMMATIONRECEIVED = 0x001F;
    /**
     * The ActiveRegisterTierDelivered attribute indicates the current register tier that
     * the energy consumed is being accumulated against.
     */
    public static final int ATTR_ACTIVEREGISTERTIERDELIVERED = 0x0020;
    /**
     * The ActiveRegisterTierReceived attribute indicates the current register tier that
     * the energy generated is being accumulated against.
     */
    public static final int ATTR_ACTIVEREGISTERTIERRECEIVED = 0x0021;
    /**
     * This attribute allows other devices to determine the time at which a meter switches from
     * one block to another.
     * <p>
     * When Block Tariffs are enabled, the LastBlockSwitchTime attribute represents the
     * timestamp of the last update to the CurrentBlock attribute, as a result of the
     * consumption exceeding a threshold, or the start of a new block period and/or billing
     * period.
     * <p>
     * If, at the start of a new block period and/or billing period, the value of the
     * CurrentBlock attribute is still set to Block1 (0x01), the CurrentBlock attribute
     * value will not change but the LastBlockSwitchTime attribute shall be updated to
     * indicate this change.
     */
    public static final int ATTR_LASTBLOCKSWITCHTIME = 0x0022;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER1SUMMATIONDELIVERED = 0x0101;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER3SUMMATIONDELIVERED = 0x0103;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER5SUMMATIONDELIVERED = 0x0105;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER7SUMMATIONDELIVERED = 0x0107;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER9SUMMATIONDELIVERED = 0x0109;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER11SUMMATIONDELIVERED = 0x010B;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER13SUMMATIONDELIVERED = 0x010D;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER15SUMMATIONDELIVERED = 0x010F;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER17SUMMATIONDELIVERED = 0x0111;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER19SUMMATIONDELIVERED = 0x0113;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER21SUMMATIONDELIVERED = 0x0115;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER23SUMMATIONDELIVERED = 0x0117;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER25SUMMATIONDELIVERED = 0x0119;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER27SUMMATIONDELIVERED = 0x011B;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER29SUMMATIONDELIVERED = 0x011D;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER31SUMMATIONDELIVERED = 0x011F;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER33SUMMATIONDELIVERED = 0x0121;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER35SUMMATIONDELIVERED = 0x0123;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER37SUMMATIONDELIVERED = 0x0125;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER39SUMMATIONDELIVERED = 0x0127;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER41SUMMATIONDELIVERED = 0x0129;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER43SUMMATIONDELIVERED = 0x012B;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER45SUMMATIONDELIVERED = 0x012D;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER47SUMMATIONDELIVERED = 0x012F;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER49SUMMATIONDELIVERED = 0x0131;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER51SUMMATIONDELIVERED = 0x0133;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER53SUMMATIONDELIVERED = 0x0135;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER55SUMMATIONDELIVERED = 0x0137;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER57SUMMATIONDELIVERED = 0x0139;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER59SUMMATIONDELIVERED = 0x013B;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER61SUMMATIONDELIVERED = 0x013D;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER63SUMMATIONDELIVERED = 0x013F;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER65SUMMATIONDELIVERED = 0x0141;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER67SUMMATIONDELIVERED = 0x0143;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER69SUMMATIONDELIVERED = 0x0145;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER71SUMMATIONDELIVERED = 0x0147;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER73SUMMATIONDELIVERED = 0x0149;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER75SUMMATIONDELIVERED = 0x014B;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER77SUMMATIONDELIVERED = 0x014D;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER79SUMMATIONDELIVERED = 0x014F;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER81SUMMATIONDELIVERED = 0x0151;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER83SUMMATIONDELIVERED = 0x0153;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER85SUMMATIONDELIVERED = 0x0155;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER87SUMMATIONDELIVERED = 0x0157;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER89SUMMATIONDELIVERED = 0x0159;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER91SUMMATIONDELIVERED = 0x015B;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER93SUMMATIONDELIVERED = 0x015D;
    /**
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     */
    public static final int ATTR_CURRENTTIER95SUMMATIONDELIVERED = 0x015F;
    public static final int ATTR_CURRENTTIER1SUMMATIONRECEIVED = 0x0102;
    public static final int ATTR_CURRENTTIER3SUMMATIONRECEIVED = 0x0104;
    public static final int ATTR_CURRENTTIER5SUMMATIONRECEIVED = 0x0106;
    public static final int ATTR_CURRENTTIER7SUMMATIONRECEIVED = 0x0108;
    public static final int ATTR_CURRENTTIER9SUMMATIONRECEIVED = 0x010A;
    public static final int ATTR_CURRENTTIER11SUMMATIONRECEIVED = 0x010C;
    public static final int ATTR_CURRENTTIER13SUMMATIONRECEIVED = 0x010E;
    public static final int ATTR_CURRENTTIER15SUMMATIONRECEIVED = 0x0110;
    public static final int ATTR_CURRENTTIER17SUMMATIONRECEIVED = 0x0112;
    public static final int ATTR_CURRENTTIER19SUMMATIONRECEIVED = 0x0114;
    public static final int ATTR_CURRENTTIER21SUMMATIONRECEIVED = 0x0116;
    public static final int ATTR_CURRENTTIER23SUMMATIONRECEIVED = 0x0118;
    public static final int ATTR_CURRENTTIER25SUMMATIONRECEIVED = 0x011A;
    public static final int ATTR_CURRENTTIER27SUMMATIONRECEIVED = 0x011C;
    public static final int ATTR_CURRENTTIER29SUMMATIONRECEIVED = 0x011E;
    public static final int ATTR_CURRENTTIER31SUMMATIONRECEIVED = 0x0120;
    public static final int ATTR_CURRENTTIER33SUMMATIONRECEIVED = 0x0122;
    public static final int ATTR_CURRENTTIER35SUMMATIONRECEIVED = 0x0124;
    public static final int ATTR_CURRENTTIER37SUMMATIONRECEIVED = 0x0126;
    public static final int ATTR_CURRENTTIER39SUMMATIONRECEIVED = 0x0128;
    public static final int ATTR_CURRENTTIER41SUMMATIONRECEIVED = 0x012A;
    public static final int ATTR_CURRENTTIER43SUMMATIONRECEIVED = 0x012C;
    public static final int ATTR_CURRENTTIER45SUMMATIONRECEIVED = 0x012E;
    public static final int ATTR_CURRENTTIER47SUMMATIONRECEIVED = 0x0130;
    public static final int ATTR_CURRENTTIER49SUMMATIONRECEIVED = 0x0132;
    public static final int ATTR_CURRENTTIER51SUMMATIONRECEIVED = 0x0134;
    public static final int ATTR_CURRENTTIER53SUMMATIONRECEIVED = 0x0136;
    public static final int ATTR_CURRENTTIER55SUMMATIONRECEIVED = 0x0138;
    public static final int ATTR_CURRENTTIER57SUMMATIONRECEIVED = 0x013A;
    public static final int ATTR_CURRENTTIER59SUMMATIONRECEIVED = 0x013C;
    public static final int ATTR_CURRENTTIER61SUMMATIONRECEIVED = 0x013E;
    public static final int ATTR_CURRENTTIER63SUMMATIONRECEIVED = 0x0140;
    public static final int ATTR_CURRENTTIER65SUMMATIONRECEIVED = 0x0142;
    public static final int ATTR_CURRENTTIER67SUMMATIONRECEIVED = 0x0144;
    public static final int ATTR_CURRENTTIER69SUMMATIONRECEIVED = 0x0146;
    public static final int ATTR_CURRENTTIER71SUMMATIONRECEIVED = 0x0148;
    public static final int ATTR_CURRENTTIER73SUMMATIONRECEIVED = 0x014A;
    public static final int ATTR_CURRENTTIER75SUMMATIONRECEIVED = 0x014C;
    public static final int ATTR_CURRENTTIER77SUMMATIONRECEIVED = 0x014E;
    public static final int ATTR_CURRENTTIER79SUMMATIONRECEIVED = 0x0150;
    public static final int ATTR_CURRENTTIER81SUMMATIONRECEIVED = 0x0152;
    public static final int ATTR_CURRENTTIER83SUMMATIONRECEIVED = 0x0154;
    public static final int ATTR_CURRENTTIER85SUMMATIONRECEIVED = 0x0156;
    public static final int ATTR_CURRENTTIER87SUMMATIONRECEIVED = 0x0158;
    public static final int ATTR_CURRENTTIER89SUMMATIONRECEIVED = 0x015A;
    public static final int ATTR_CURRENTTIER91SUMMATIONRECEIVED = 0x015C;
    public static final int ATTR_CURRENTTIER93SUMMATIONRECEIVED = 0x015E;
    public static final int ATTR_CURRENTTIER95SUMMATIONRECEIVED = 0x0160;
    /**
     * CPP1SummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered to the premises (i.e. delivered to the customer from the utility) while
     * Critical Peak Price CPP1 was being applied. If optionally provided, attribute
     * CPP1SummationDelivered is updated continuously as new measurements are made.
     */
    public static final int ATTR_CPP1SUMMATIONDELIVERED = 0x01FC;
    /**
     * CPP2SummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered to the premises (i.e. delivered to the customer from the utility) while
     * Critical Peak Price CPP2 was being applied. If optionally provided, attribute
     * CPP2SummationDelivered is updated continuously as new measurements are made.
     */
    public static final int ATTR_CPP2SUMMATIONDELIVERED = 0x01FE;
    /**
     * The Status attribute provides indicators reflecting the current error conditions
     * found by the metering device. This attribute is an 8-bit field where when an individual
     * bit is set, an error or warning condition exists. The behavior causing the setting or
     * resetting each bit is device specific. In other words, the application within the
     * metering device will determine and control when these settings are either set or
     * cleared.
     */
    public static final int ATTR_STATUS = 0x0200;
    /**
     * RemainingBatteryLife represents the estimated remaining life of the battery in % of
     * capacity. A setting of 0xFF indicates this feature is disabled. The range 0 - 100 where
     * 100 = 100%, 0xFF = Unknown.
     */
    public static final int ATTR_REMAININGBATTERYLIFE = 0x0201;
    /**
     * HoursInOperation is a counter that increments once every hour during operation. This
     * may be used as a check for tampering.
     */
    public static final int ATTR_HOURSINOPERATION = 0x0202;
    /**
     * HoursInFault is a counter that increments once every hour when the device is in
     * operation with a fault detected. This may be used as a check for tampering.
     */
    public static final int ATTR_HOURSINFAULT = 0x0203;
    /**
     * The ExtendedStatus attribute reflects the state of items in a meter that the standard
     * Status attribute cannot show. The Extended Status BitMap is split into two groups of
     * flags: general flags and metering type specific flags. Flags are currently defined for
     * electricity and gas meters; flag definitions for other commodities will be added as and
     * when their usage is agreed.
     * <p>
     * These flags are set and reset by the meter autonomously; they cannot be reset by other
     * devices.
     */
    public static final int ATTR_EXTENDEDSTATUS = 0x0204;
    /**
     * RemainingBatteryLifeInDays attribute represents the estimated remaining life of
     * the battery in days of capacity. The range is 0  0xFFFE, where 0xFFFF represents
     * 'Invalid', 'Unused' and 'Disabled'.
     */
    public static final int ATTR_REMAININGBATTERYLIFEINDAYS = 0x0205;
    /**
     * CurrentMeterID attribute is the current ID for the Meter. This could be the current
     * firmware version supported on the meter.
     */
    public static final int ATTR_CURRENTMETERID = 0x0206;
    /**
     * The AmbientConsumptionIndicator attribute is an 8-bit enumeration which provides a
     * simple (i.e. Low/Medium/High) indication of the amount of a commodity being consumed
     * within the premises. The status is achieved by comparing the current value of the
     * InstantaneousDemand attribute with low/medium and medium/high thresholds.
     */
    public static final int ATTR_AMBIENTCONSUMPTIONINDICATOR = 0x0207;
    /**
     * UnitofMeasure provides a label for the Energy, Gas, or Water being measured by the
     * metering device. The unit of measure applies to all summations, consumptions/ profile
     * interval and demand/rate supported by this cluster other than those specifically
     * identified as being based upon the EnergyCarrierUnitOfMeasure or the
     * AlternativeUnitofMeasure. Other measurements such as the power factor are self
     * describing.
     */
    public static final int ATTR_UNITOFMEASURE = 0x0300;
    /**
     * Multiplier provides a value to be multiplied against a raw or uncompensated sensor
     * count of Energy, Gas, or Water being measured by the metering device. If present, this
     * attribute must be applied against all summation, consumption and demand values to
     * derive the delivered and received values expressed in the unit of measure specified.
     * This attribute must be used in conjunction with the Divisor attribute.
     */
    public static final int ATTR_MULTIPLIER = 0x0301;
    /**
     * Divisor provides a value to divide the results of applying the Multiplier Attribute
     * against a raw or uncompensated sensor count of Energy, Gas, or Water being measured by
     * the metering device. If present, this attribute must be applied against all summation,
     * consumption and demand values to derive the delivered and received values expressed in
     * the unit of measure specified. This attribute must be used in conjunction with the
     * Multiplier attribute.
     */
    public static final int ATTR_DIVISOR = 0x0302;
    /**
     * SummationFormatting provides a method to properly decipher the number of digits and
     * the decimal location of the values found in the Summation Information Set of
     * attributes.
     */
    public static final int ATTR_SUMMATIONFORMATTING = 0x0303;
    /**
     * DemandFormatting provides a method to properly decipher the number of digits and the
     * decimal location of the values found in the Demand-related attributes.
     */
    public static final int ATTR_DEMANDFORMATTING = 0x0304;
    /**
     * HistoricalConsumptionFormatting provides a method to properly decipher the number
     * of digits and the decimal location of the values found in the Historical Consumption Set
     * of attributes.
     */
    public static final int ATTR_HISTORICALCONSUMPTIONFORMATTING = 0x0305;
    /**
     * MeteringDeviceType provides a label for identifying the type of metering device
     * present. The attribute are values representing Energy, Gas, Water, Thermal, Heat,
     * Cooling, and mirrored metering devices.
     */
    public static final int ATTR_METERINGDEVICETYPE = 0x0306;
    /**
     * The SiteID is a ZCL Octet String field capable of storing a 32 character string (the first
     * Octet indicates length) encoded in UTF-8 format. The SiteID is a text string, known in
     * the UK as the MPAN number for electricity, MPRN for gas and 'Stand Point' in South Africa.
     * These numbers specify the meter point location in a standardized way. The field is
     * defined to accommodate the number of characters typically found in the UK and Europe (16
     * digits). Generally speaking the field is numeric but is defined for the possibility of
     * an alpha-numeric format by specifying an octet string.
     */
    public static final int ATTR_SITEID = 0x0307;
    /**
     * The MeterSerialNumber is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format. It is used to provide
     * a unique identification of the metering device.
     */
    public static final int ATTR_METERSERIALNUMBER = 0x0308;
    /**
     * The EnergyCarrierUnitOfMeasure specifies the unit of measure that the EnergyCarrier
     * is measured in. This unit of measure is typically a unit of volume or flow and cannot be an
     * amount of energy.
     */
    public static final int ATTR_ENERGYCARRIERUNITOFMEASURE = 0x0309;
    /**
     * EnergyCarrierSummationFormatting provides a method to properly decipher the number
     * of digits and the decimal location of the values found in the Summation- related
     * attributes.
     */
    public static final int ATTR_ENERGYCARRIERSUMMATIONFORMATTING = 0x030A;
    /**
     * EnergyCarrierDemandFormatting provides a method to properly decipher the number of
     * digits and the decimal location of the values found in the Demand-related attributes.
     */
    public static final int ATTR_ENERGYCARRIERDEMANDFORMATTING = 0x030B;
    /**
     * TemperatureFormatting provides a method to properly decipher the number of digits and
     * the decimal location of the values found in the Temperature-related attributes.
     */
    public static final int ATTR_TEMPERATUREUNITOFMEASURE = 0x030C;
    /**
     * The TemperatureUnitOfMeasure specifies the unit of measure that temperatures are
     * measured in.
     */
    public static final int ATTR_TEMPERATUREFORMATTING = 0x030D;
    /**
     * The ModuleSerialNumber attribute represents the serial number (unique identifier)
     * of the meter module. It is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format. It shall be used to
     * uniquely identify the meter communications module.
     */
    public static final int ATTR_MODULESERIALNUMBER = 0x030E;
    /**
     * The OperatingTariffLabelDelivered attribute is the meters version of the
     * TariffLabel attribute that is found within the Tariff Information attribute set of the
     * Price Cluster. It is used to identify the current consumption tariff operating on the
     * meter. The attribute is a ZCL Octet String field capable of storing a 24 character string
     * (the first Octet indicates length) encoded in UTF-8 format.
     */
    public static final int ATTR_OPERATINGTARIFFLABELDELIVERED = 0x030F;
    /**
     * The OperatingTariffLabelReceived attribute is the meters version of the
     * ReceivedTariffLabel attribute that is found within the Tariff Information attribute
     * set of the Price Cluster. It is used to identify the current generation tariff operating
     * on the meter. The attribute is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format.
     */
    public static final int ATTR_OPERATINGTARIFFLABELRECEIVED = 0x0310;
    /**
     * The CustomerIDNumber attribute provides a customer identification which may be used
     * to confirm the customer at the premises. The attribute is a ZCL Octet String field
     * capable of storing a 24 character string (not including the first Octet which indicates
     * length) encoded in UTF-8 format.
     */
    public static final int ATTR_CUSTOMERIDNUMBER = 0x0311;
    /**
     * Unless stated otherwise, the AlternativeUnitofMeasure attribute provides a base for
     * the attributes in the Alternative Historical Consumption attribute set.
     */
    public static final int ATTR_ALTERNATIVEUNITOFMEASURE = 0x0312;
    /**
     * AlternativeDemandFormatting provides a method to properly decipher the number of
     * digits and the decimal location of the values found in the Alternative Demand-related
     * attributes.
     */
    public static final int ATTR_ALTERNATIVEDEMANDFORMATTING = 0x0313;
    public static final int ATTR_ALTERNATIVECONSUMPTIONFORMATTING = 0x0314;
    /**
     * InstantaneousDemand represents the current Demand of Energy, Gas, or Water delivered
     * or received at the premises. Positive values indicate demand delivered to the premises
     * where negative values indicate demand received from the premises.
     * InstantaneousDemand is updated continuously as new measurements are made. The
     * frequency of updates to this field is specific to the metering device, but should be
     * within the range of once every second to once every 5 seconds.
     */
    public static final int ATTR_INSTANTANEOUSDEMAND = 0x0400;
    /**
     * CurrentDayConsumptionDelivered represents the summed value of Energy, Gas, or Water
     * delivered to the premises since the Historical Freeze Time (HFT). If optionally
     * provided, CurrentDayConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     */
    public static final int ATTR_CURRENTDAYCONSUMPTIONDELIVERED = 0x0401;
    /**
     * CurrentDayConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises since the Historical Freeze Time (HFT). If optionally
     * provided, CurrentDayConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     */
    public static final int ATTR_CURRENTDAYCONSUMPTIONRECEIVED = 0x0402;
    /**
     * PreviousDayConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayConsumptionDelivered is updated every HFT. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAYCONSUMPTIONDELIVERED = 0x0403;
    /**
     * PreviousDayConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayConsumptionReceived is updated every HFT. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAYCONSUMPTIONRECEIVED = 0x0404;
    /**
     * CurrentPartialProfileIntervalStartTimeDelivered represents the start time of the
     * current Load Profile interval being accumulated for commodity delivered.
     */
    public static final int ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMEDELIVERED = 0x0405;
    /**
     * CurrentPartialProfileIntervalStartTimeReceived represents the start time of the
     * current Load Profile interval being accumulated for commodity received.
     */
    public static final int ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMERECEIVED = 0x0406;
    /**
     * CurrentPartialProfileIntervalValueDelivered represents the value of the current
     * Load Profile interval being accumulated for commodity delivered.
     */
    public static final int ATTR_CURRENTPARTIALPROFILEINTERVALVALUEDELIVERED = 0x0407;
    /**
     * CurrentPartialProfileIntervalValueReceived represents the value of the current
     * Load Profile interval being accumulated for commodity received.
     */
    public static final int ATTR_CURRENTPARTIALPROFILEINTERVALVALUERECEIVED = 0x0408;
    /**
     * CurrentDayMaxPressure is the maximum pressure reported during a day from the water or
     * gas meter.
     */
    public static final int ATTR_CURRENTDAYMAXPRESSURE = 0x0409;
    /**
     * CurrentDayMinPressure is the minimum pressure reported during a day from the water or
     * gas meter.
     */
    public static final int ATTR_CURRENTDAYMINPRESSURE = 0x040A;
    /**
     * PreviousDayMaxPressure represents the maximum pressure reported during previous
     * day from the water or gas meter.
     */
    public static final int ATTR_PREVIOUSDAYMAXPRESSURE = 0x040B;
    /**
     * PreviousDayMinPressure represents the minimum pressure reported during previous
     * day from the water or gas meter.
     */
    public static final int ATTR_PREVIOUSDAYMINPRESSURE = 0x040C;
    /**
     * CurrentDayMaxDemand represents the maximum demand or rate of delivered value of
     * Energy, Gas, or Water being utilized at the premises.
     */
    public static final int ATTR_CURRENTDAYMAXDEMAND = 0x040D;
    /**
     * PreviousDayMaxDemand represents the maximum demand or rate of delivered value of
     * Energy, Gas, or Water being utilized at the premises.
     */
    public static final int ATTR_PREVIOUSDAYMAXDEMAND = 0x040E;
    /**
     * CurrentMonthMaxDemand is the maximum demand reported during a month from the meter.
     */
    public static final int ATTR_CURRENTMONTHMAXDEMAND = 0x040F;
    /**
     * CurrentYearMaxDemand is the maximum demand reported during a year from the meter.
     */
    public static final int ATTR_CURRENTYEARMAXDEMAND = 0x0410;
    /**
     * CurrentDayMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a day from the meter.
     */
    public static final int ATTR_CURRENTDAYMAXENERGYCARRIERDEMAND = 0x0411;
    /**
     * PreviousDayMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during the previous day from the meter.
     */
    public static final int ATTR_PREVIOUSDAYMAXENERGYCARRIERDEMAND = 0x0412;
    /**
     * CurrentMonthMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a month from the meter.
     */
    public static final int ATTR_CURRENTMONTHMAXENERGYCARRIERDEMAND = 0x0413;
    /**
     * CurrentMonthMinEnergyCarrierDemand is the minimum energy carrier demand reported
     * during a month from the meter.
     */
    public static final int ATTR_CURRENTMONTHMINENERGYCARRIERDEMAND = 0x0414;
    /**
     * CurrentYearMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a year from the meter.
     */
    public static final int ATTR_CURRENTYEARMAXENERGYCARRIERDEMAND = 0x0415;
    /**
     * CurrentYearMinEnergyCarrierDemand is the minimum energy carrier demand reported
     * during a year from the heat meter.
     */
    public static final int ATTR_CURRENTYEARMINENERGYCARRIERDEMAND = 0x0416;
    /**
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY2CONSUMPTIONDELIVERED = 0x0422;
    /**
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY4CONSUMPTIONDELIVERED = 0x0424;
    /**
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY6CONSUMPTIONDELIVERED = 0x0426;
    /**
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY8CONSUMPTIONDELIVERED = 0x0428;
    /**
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY10CONSUMPTIONDELIVERED = 0x042A;
    /**
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY12CONSUMPTIONDELIVERED = 0x042C;
    /**
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY14CONSUMPTIONDELIVERED = 0x042E;
    /**
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY16CONSUMPTIONDELIVERED = 0x0430;
    /**
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY2CONSUMPTIONRECEIVED = 0x0423;
    /**
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY4CONSUMPTIONRECEIVED = 0x0425;
    /**
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY6CONSUMPTIONRECEIVED = 0x0427;
    /**
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY8CONSUMPTIONRECEIVED = 0x0429;
    /**
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY10CONSUMPTIONRECEIVED = 0x042B;
    /**
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY12CONSUMPTIONRECEIVED = 0x042D;
    /**
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY14CONSUMPTIONRECEIVED = 0x042F;
    /**
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAY16CONSUMPTIONRECEIVED = 0x0431;
    /**
     * CurrentWeekConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises since the Historical Freeze Time (HFT) on Monday to the
     * last HFT read. If optionally provided, CurrentWeekConsumptionDelivered is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_CURRENTWEEKCONSUMPTIONDELIVERED = 0x0430;
    /**
     * CurrentWeekConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises since the Historical Freeze Time (HFT) on Monday to the last
     * HFT read. If optionally provided, CurrentWeekConsumptionReceived is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_CURRENTWEEKCONSUMPTIONRECEIVED = 0x0431;
    /**
     * PreviousWeekNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK1CONSUMPTIONDELIVERED = 0x0433;
    /**
     * PreviousWeekNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK3CONSUMPTIONDELIVERED = 0x0435;
    /**
     * PreviousWeekNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK5CONSUMPTIONDELIVERED = 0x0437;
    /**
     * PreviousWeekNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK7CONSUMPTIONDELIVERED = 0x0439;
    /**
     * PreviousWeekNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK9CONSUMPTIONDELIVERED = 0x043B;
    /**
     * PreviousWeekNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK1CONSUMPTIONRECEIVED = 0x0434;
    /**
     * PreviousWeekNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK3CONSUMPTIONRECEIVED = 0x0436;
    /**
     * PreviousWeekNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK5CONSUMPTIONRECEIVED = 0x0438;
    /**
     * PreviousWeekNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK7CONSUMPTIONRECEIVED = 0x043A;
    /**
     * PreviousWeekNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK9CONSUMPTIONRECEIVED = 0x043C;
    /**
     * CurrentMonthConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises since the Historical Freeze Time (HFT) on the 1st of the
     * month to the last HFT read. If optionally provided,
     * CurrentMonthConsumptionDelivered is updated continuously as new measurements are
     * made. If the optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_CURRENTMONTHCONSUMPTIONDELIVERED = 0x0440;
    /**
     * CurrentMonthConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises since the Historical Freeze Time (HFT) on the 1st of the
     * month to the last HFT read. If optionally provided, CurrentMonthConsumptionReceived
     * is updated continuously as new measurements are made. If the optional HFT attribute is
     * not available, default to midnight local time.
     */
    public static final int ATTR_CURRENTMONTHCONSUMPTIONRECEIVED = 0x0441;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH1CONSUMPTIONDELIVERED = 0x0443;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH3CONSUMPTIONDELIVERED = 0x0445;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH5CONSUMPTIONDELIVERED = 0x0447;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH7CONSUMPTIONDELIVERED = 0x0449;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH9CONSUMPTIONDELIVERED = 0x044B;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH11CONSUMPTIONDELIVERED = 0x044D;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH13CONSUMPTIONDELIVERED = 0x044F;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH15CONSUMPTIONDELIVERED = 0x0451;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH17CONSUMPTIONDELIVERED = 0x0453;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH19CONSUMPTIONDELIVERED = 0x0455;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH21CONSUMPTIONDELIVERED = 0x0457;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH23CONSUMPTIONDELIVERED = 0x0459;
    /**
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH25CONSUMPTIONDELIVERED = 0x045B;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH1CONSUMPTIONRECEIVED = 0x0444;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH3CONSUMPTIONRECEIVED = 0x0446;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH5CONSUMPTIONRECEIVED = 0x0448;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH7CONSUMPTIONRECEIVED = 0x044A;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH9CONSUMPTIONRECEIVED = 0x044C;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH11CONSUMPTIONRECEIVED = 0x044E;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH13CONSUMPTIONRECEIVED = 0x0450;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH15CONSUMPTIONRECEIVED = 0x0452;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH17CONSUMPTIONRECEIVED = 0x0454;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH19CONSUMPTIONRECEIVED = 0x0456;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH21CONSUMPTIONRECEIVED = 0x0458;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH23CONSUMPTIONRECEIVED = 0x045A;
    /**
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSMONTH25CONSUMPTIONRECEIVED = 0x045C;
    /**
     * HistoricalFreezeTime (HFT) represents the time of day, in Local Time, when Historical
     * Consumption attributes and/or Alternative Historical Consumption attributes are
     * captured. HistoricalFreezeTime is an unsigned 16-bit value representing the hour and
     * minutes for HFT.
     */
    public static final int ATTR_HISTORICALFREEZETIME = 0x045C;
    /**
     * MaxNumberofPeriodsDelivered represents the maximum number of intervals the device
     * is capable of returning in one Get Profile Response command. It is required
     * MaxNumberofPeriodsDelivered fit within the default Fragmentation ASDU size of 128
     * bytes, or an optionally agreed upon larger Fragmentation ASDU size supported by both
     * devices.
     */
    public static final int ATTR_MAXNUMBEROFPERIODSDELIVERED = 0x0500;
    /**
     * CurrentDemandDelivered represents the current Demand of Energy, Gas, or Water
     * delivered at the premises. CurrentDemandDelivered may be continuously updated as new
     * measurements are acquired, but at a minimum CurrentDemandDelivered must be updated at
     * the end of each integration sub- period, which can be obtained by dividing the
     * DemandIntegrationPeriod by the NumberOfDemandSubintervals.
     */
    public static final int ATTR_CURRENTDEMANDDELIVERED = 0x0600;
    /**
     * DemandLimit reflects the current supply demand limit set in the meter. This value can be
     * compared to the CurrentDemandDelivered attribute to understand if limits are being
     * approached or exceeded.
     */
    public static final int ATTR_DEMANDLIMIT = 0x0601;
    /**
     * DemandIntegrationPeriod is the number of minutes over which the
     * CurrentDemandDelivered attribute is calculated. Valid range is 0x01 to 0xFF. 0x00 is a
     * reserved value.
     */
    public static final int ATTR_DEMANDINTEGRATIONPERIOD = 0x0602;
    /**
     * NumberOfDemandSubintervals represents the number of subintervals used within the
     * DemandIntegrationPeriod. The subinterval duration (in minutes) is obtained by
     * dividing the DemandIntegrationPeriod by the NumberOfDemandSubintervals. The
     * CurrentDemandDelivered attribute is updated at the each of each subinterval. Valid
     * range is 0x01 to 0xFF. 0x00 is a reserved value.
     */
    public static final int ATTR_NUMBEROFDEMANDSUBINTERVALS = 0x0603;
    /**
     * An unsigned 16-bit integer that defines the length of time, in seconds, that the supply
     * shall be disconnected if the DemandLimit attribute is enabled and the limit is
     * exceeded. At the end of the time period the meter shall move to the ARMED status. This will
     * allow the user to reconnect the supply.
     */
    public static final int ATTR_DEMANDLIMITARMDURATION = 0x0604;
    /**
     * The LoadLimitSupplyState attribute indicates the required status of the supply once
     * device is in a load limit state.
     */
    public static final int ATTR_LOADLIMITSUPPLYSTATE = 0x0605;
    /**
     * An unsigned 8-bit integer used for counting the number of times that the demand limit has
     * exceeded the set threshold.
     */
    public static final int ATTR_LOADLIMITCOUNTER = 0x0606;
    /**
     * The SupplyTamperState indicates the required status of the supply following the
     * detection of a tamper event within the metering device.
     */
    public static final int ATTR_SUPPLYTAMPERSTATE = 0x0607;
    /**
     * The SupplyDepletionState indicates the required status of the supply following
     * detection of a depleted battery within the metering device.
     */
    public static final int ATTR_SUPPLYDEPLETIONSTATE = 0x0608;
    /**
     * The SupplyUncontrolledFlowState indicates the required status of the supply
     * following detection of an uncontrolled flow event within the metering device.
     */
    public static final int ATTR_SUPPLYUNCONTROLLEDFLOWSTATE = 0x0609;
    public static final int ATTR_CURRENTNOTIERBLOCK1SUMMATIONDELIVERED = 0x0701;
    public static final int ATTR_CURRENTNOTIERBLOCK2SUMMATIONDELIVERED = 0x0702;
    public static final int ATTR_CURRENTNOTIERBLOCK3SUMMATIONDELIVERED = 0x0703;
    public static final int ATTR_CURRENTNOTIERBLOCK4SUMMATIONDELIVERED = 0x0704;
    public static final int ATTR_CURRENTNOTIERBLOCK5SUMMATIONDELIVERED = 0x0705;
    public static final int ATTR_CURRENTNOTIERBLOCK6SUMMATIONDELIVERED = 0x0706;
    public static final int ATTR_CURRENTNOTIERBLOCK7SUMMATIONDELIVERED = 0x0707;
    public static final int ATTR_CURRENTNOTIERBLOCK8SUMMATIONDELIVERED = 0x0708;
    public static final int ATTR_CURRENTNOTIERBLOCK9SUMMATIONDELIVERED = 0x0709;
    public static final int ATTR_CURRENTNOTIERBLOCK10SUMMATIONDELIVERED = 0x070A;
    public static final int ATTR_CURRENTNOTIERBLOCK11SUMMATIONDELIVERED = 0x070B;
    public static final int ATTR_CURRENTNOTIERBLOCK12SUMMATIONDELIVERED = 0x070C;
    public static final int ATTR_CURRENTNOTIERBLOCK13SUMMATIONDELIVERED = 0x070D;
    public static final int ATTR_CURRENTNOTIERBLOCK14SUMMATIONDELIVERED = 0x070E;
    public static final int ATTR_CURRENTNOTIERBLOCK15SUMMATIONDELIVERED = 0x070F;
    public static final int ATTR_CURRENTNOTIERBLOCK16SUMMATIONDELIVERED = 0x0710;
    public static final int ATTR_CURRENTTIER1BLOCK1SUMMATIONDELIVERED = 0x0711;
    public static final int ATTR_CURRENTTIER1BLOCK2SUMMATIONDELIVERED = 0x0712;
    public static final int ATTR_CURRENTTIER1BLOCK3SUMMATIONDELIVERED = 0x0713;
    public static final int ATTR_CURRENTTIER1BLOCK4SUMMATIONDELIVERED = 0x0714;
    public static final int ATTR_CURRENTTIER1BLOCK5SUMMATIONDELIVERED = 0x0715;
    public static final int ATTR_CURRENTTIER1BLOCK6SUMMATIONDELIVERED = 0x0716;
    public static final int ATTR_CURRENTTIER1BLOCK7SUMMATIONDELIVERED = 0x0717;
    public static final int ATTR_CURRENTTIER1BLOCK8SUMMATIONDELIVERED = 0x0718;
    public static final int ATTR_CURRENTTIER1BLOCK9SUMMATIONDELIVERED = 0x0719;
    public static final int ATTR_CURRENTTIER1BLOCK10SUMMATIONDELIVERED = 0x071A;
    public static final int ATTR_CURRENTTIER1BLOCK11SUMMATIONDELIVERED = 0x071B;
    public static final int ATTR_CURRENTTIER1BLOCK12SUMMATIONDELIVERED = 0x071C;
    public static final int ATTR_CURRENTTIER1BLOCK13SUMMATIONDELIVERED = 0x071D;
    public static final int ATTR_CURRENTTIER1BLOCK14SUMMATIONDELIVERED = 0x071E;
    public static final int ATTR_CURRENTTIER1BLOCK15SUMMATIONDELIVERED = 0x071F;
    public static final int ATTR_CURRENTTIER1BLOCK16SUMMATIONDELIVERED = 0x0720;
    public static final int ATTR_CURRENTTIER2BLOCK1SUMMATIONDELIVERED = 0x0721;
    public static final int ATTR_CURRENTTIER2BLOCK2SUMMATIONDELIVERED = 0x0722;
    public static final int ATTR_CURRENTTIER2BLOCK3SUMMATIONDELIVERED = 0x0723;
    public static final int ATTR_CURRENTTIER2BLOCK4SUMMATIONDELIVERED = 0x0724;
    public static final int ATTR_CURRENTTIER2BLOCK5SUMMATIONDELIVERED = 0x0725;
    public static final int ATTR_CURRENTTIER2BLOCK6SUMMATIONDELIVERED = 0x0726;
    public static final int ATTR_CURRENTTIER2BLOCK7SUMMATIONDELIVERED = 0x0727;
    public static final int ATTR_CURRENTTIER2BLOCK8SUMMATIONDELIVERED = 0x0728;
    public static final int ATTR_CURRENTTIER2BLOCK9SUMMATIONDELIVERED = 0x0729;
    public static final int ATTR_CURRENTTIER2BLOCK10SUMMATIONDELIVERED = 0x072A;
    public static final int ATTR_CURRENTTIER2BLOCK11SUMMATIONDELIVERED = 0x072B;
    public static final int ATTR_CURRENTTIER2BLOCK12SUMMATIONDELIVERED = 0x072C;
    public static final int ATTR_CURRENTTIER2BLOCK13SUMMATIONDELIVERED = 0x072D;
    public static final int ATTR_CURRENTTIER2BLOCK14SUMMATIONDELIVERED = 0x072E;
    public static final int ATTR_CURRENTTIER2BLOCK15SUMMATIONDELIVERED = 0x072F;
    public static final int ATTR_CURRENTTIER2BLOCK16SUMMATIONDELIVERED = 0x0730;
    public static final int ATTR_CURRENTTIER3BLOCK1SUMMATIONDELIVERED = 0x0731;
    public static final int ATTR_CURRENTTIER3BLOCK2SUMMATIONDELIVERED = 0x0732;
    public static final int ATTR_CURRENTTIER3BLOCK3SUMMATIONDELIVERED = 0x0733;
    public static final int ATTR_CURRENTTIER3BLOCK4SUMMATIONDELIVERED = 0x0734;
    public static final int ATTR_CURRENTTIER3BLOCK5SUMMATIONDELIVERED = 0x0735;
    public static final int ATTR_CURRENTTIER3BLOCK6SUMMATIONDELIVERED = 0x0736;
    public static final int ATTR_CURRENTTIER3BLOCK7SUMMATIONDELIVERED = 0x0737;
    public static final int ATTR_CURRENTTIER3BLOCK8SUMMATIONDELIVERED = 0x0738;
    public static final int ATTR_CURRENTTIER3BLOCK9SUMMATIONDELIVERED = 0x0739;
    public static final int ATTR_CURRENTTIER3BLOCK10SUMMATIONDELIVERED = 0x073A;
    public static final int ATTR_CURRENTTIER3BLOCK11SUMMATIONDELIVERED = 0x073B;
    public static final int ATTR_CURRENTTIER3BLOCK12SUMMATIONDELIVERED = 0x073C;
    public static final int ATTR_CURRENTTIER3BLOCK13SUMMATIONDELIVERED = 0x073D;
    public static final int ATTR_CURRENTTIER3BLOCK14SUMMATIONDELIVERED = 0x073E;
    public static final int ATTR_CURRENTTIER3BLOCK15SUMMATIONDELIVERED = 0x073F;
    public static final int ATTR_CURRENTTIER3BLOCK16SUMMATIONDELIVERED = 0x0740;
    public static final int ATTR_CURRENTTIER4BLOCK1SUMMATIONDELIVERED = 0x0741;
    public static final int ATTR_CURRENTTIER4BLOCK2SUMMATIONDELIVERED = 0x0742;
    public static final int ATTR_CURRENTTIER4BLOCK3SUMMATIONDELIVERED = 0x0743;
    public static final int ATTR_CURRENTTIER4BLOCK4SUMMATIONDELIVERED = 0x0744;
    public static final int ATTR_CURRENTTIER4BLOCK5SUMMATIONDELIVERED = 0x0745;
    public static final int ATTR_CURRENTTIER4BLOCK6SUMMATIONDELIVERED = 0x0746;
    public static final int ATTR_CURRENTTIER4BLOCK7SUMMATIONDELIVERED = 0x0747;
    public static final int ATTR_CURRENTTIER4BLOCK8SUMMATIONDELIVERED = 0x0748;
    public static final int ATTR_CURRENTTIER4BLOCK9SUMMATIONDELIVERED = 0x0749;
    public static final int ATTR_CURRENTTIER4BLOCK10SUMMATIONDELIVERED = 0x074A;
    public static final int ATTR_CURRENTTIER4BLOCK11SUMMATIONDELIVERED = 0x074B;
    public static final int ATTR_CURRENTTIER4BLOCK12SUMMATIONDELIVERED = 0x074C;
    public static final int ATTR_CURRENTTIER4BLOCK13SUMMATIONDELIVERED = 0x074D;
    public static final int ATTR_CURRENTTIER4BLOCK14SUMMATIONDELIVERED = 0x074E;
    public static final int ATTR_CURRENTTIER4BLOCK15SUMMATIONDELIVERED = 0x074F;
    public static final int ATTR_CURRENTTIER4BLOCK16SUMMATIONDELIVERED = 0x0750;
    public static final int ATTR_CURRENTTIER5BLOCK1SUMMATIONDELIVERED = 0x0751;
    public static final int ATTR_CURRENTTIER5BLOCK2SUMMATIONDELIVERED = 0x0752;
    public static final int ATTR_CURRENTTIER5BLOCK3SUMMATIONDELIVERED = 0x0753;
    public static final int ATTR_CURRENTTIER5BLOCK4SUMMATIONDELIVERED = 0x0754;
    public static final int ATTR_CURRENTTIER5BLOCK5SUMMATIONDELIVERED = 0x0755;
    public static final int ATTR_CURRENTTIER5BLOCK6SUMMATIONDELIVERED = 0x0756;
    public static final int ATTR_CURRENTTIER5BLOCK7SUMMATIONDELIVERED = 0x0757;
    public static final int ATTR_CURRENTTIER5BLOCK8SUMMATIONDELIVERED = 0x0758;
    public static final int ATTR_CURRENTTIER5BLOCK9SUMMATIONDELIVERED = 0x0759;
    public static final int ATTR_CURRENTTIER5BLOCK10SUMMATIONDELIVERED = 0x075A;
    public static final int ATTR_CURRENTTIER5BLOCK11SUMMATIONDELIVERED = 0x075B;
    public static final int ATTR_CURRENTTIER5BLOCK12SUMMATIONDELIVERED = 0x075C;
    public static final int ATTR_CURRENTTIER5BLOCK13SUMMATIONDELIVERED = 0x075D;
    public static final int ATTR_CURRENTTIER5BLOCK14SUMMATIONDELIVERED = 0x075E;
    public static final int ATTR_CURRENTTIER5BLOCK15SUMMATIONDELIVERED = 0x075F;
    public static final int ATTR_CURRENTTIER5BLOCK16SUMMATIONDELIVERED = 0x0760;
    public static final int ATTR_CURRENTTIER6BLOCK1SUMMATIONDELIVERED = 0x0761;
    public static final int ATTR_CURRENTTIER6BLOCK2SUMMATIONDELIVERED = 0x0762;
    public static final int ATTR_CURRENTTIER6BLOCK3SUMMATIONDELIVERED = 0x0763;
    public static final int ATTR_CURRENTTIER6BLOCK4SUMMATIONDELIVERED = 0x0764;
    public static final int ATTR_CURRENTTIER6BLOCK5SUMMATIONDELIVERED = 0x0765;
    public static final int ATTR_CURRENTTIER6BLOCK6SUMMATIONDELIVERED = 0x0766;
    public static final int ATTR_CURRENTTIER6BLOCK7SUMMATIONDELIVERED = 0x0767;
    public static final int ATTR_CURRENTTIER6BLOCK8SUMMATIONDELIVERED = 0x0768;
    public static final int ATTR_CURRENTTIER6BLOCK9SUMMATIONDELIVERED = 0x0769;
    public static final int ATTR_CURRENTTIER6BLOCK10SUMMATIONDELIVERED = 0x076A;
    public static final int ATTR_CURRENTTIER6BLOCK11SUMMATIONDELIVERED = 0x076B;
    public static final int ATTR_CURRENTTIER6BLOCK12SUMMATIONDELIVERED = 0x076C;
    public static final int ATTR_CURRENTTIER6BLOCK13SUMMATIONDELIVERED = 0x076D;
    public static final int ATTR_CURRENTTIER6BLOCK14SUMMATIONDELIVERED = 0x076E;
    public static final int ATTR_CURRENTTIER6BLOCK15SUMMATIONDELIVERED = 0x076F;
    public static final int ATTR_CURRENTTIER6BLOCK16SUMMATIONDELIVERED = 0x0770;
    public static final int ATTR_CURRENTTIER7BLOCK1SUMMATIONDELIVERED = 0x0771;
    public static final int ATTR_CURRENTTIER7BLOCK2SUMMATIONDELIVERED = 0x0772;
    public static final int ATTR_CURRENTTIER7BLOCK3SUMMATIONDELIVERED = 0x0773;
    public static final int ATTR_CURRENTTIER7BLOCK4SUMMATIONDELIVERED = 0x0774;
    public static final int ATTR_CURRENTTIER7BLOCK5SUMMATIONDELIVERED = 0x0775;
    public static final int ATTR_CURRENTTIER7BLOCK6SUMMATIONDELIVERED = 0x0776;
    public static final int ATTR_CURRENTTIER7BLOCK7SUMMATIONDELIVERED = 0x0777;
    public static final int ATTR_CURRENTTIER7BLOCK8SUMMATIONDELIVERED = 0x0778;
    public static final int ATTR_CURRENTTIER7BLOCK9SUMMATIONDELIVERED = 0x0779;
    public static final int ATTR_CURRENTTIER7BLOCK10SUMMATIONDELIVERED = 0x077A;
    public static final int ATTR_CURRENTTIER7BLOCK11SUMMATIONDELIVERED = 0x077B;
    public static final int ATTR_CURRENTTIER7BLOCK12SUMMATIONDELIVERED = 0x077C;
    public static final int ATTR_CURRENTTIER7BLOCK13SUMMATIONDELIVERED = 0x077D;
    public static final int ATTR_CURRENTTIER7BLOCK14SUMMATIONDELIVERED = 0x077E;
    public static final int ATTR_CURRENTTIER7BLOCK15SUMMATIONDELIVERED = 0x077F;
    public static final int ATTR_CURRENTTIER7BLOCK16SUMMATIONDELIVERED = 0x0780;
    public static final int ATTR_CURRENTTIER8BLOCK1SUMMATIONDELIVERED = 0x0781;
    public static final int ATTR_CURRENTTIER8BLOCK2SUMMATIONDELIVERED = 0x0782;
    public static final int ATTR_CURRENTTIER8BLOCK3SUMMATIONDELIVERED = 0x0783;
    public static final int ATTR_CURRENTTIER8BLOCK4SUMMATIONDELIVERED = 0x0784;
    public static final int ATTR_CURRENTTIER8BLOCK5SUMMATIONDELIVERED = 0x0785;
    public static final int ATTR_CURRENTTIER8BLOCK6SUMMATIONDELIVERED = 0x0786;
    public static final int ATTR_CURRENTTIER8BLOCK7SUMMATIONDELIVERED = 0x0787;
    public static final int ATTR_CURRENTTIER8BLOCK8SUMMATIONDELIVERED = 0x0788;
    public static final int ATTR_CURRENTTIER8BLOCK9SUMMATIONDELIVERED = 0x0789;
    public static final int ATTR_CURRENTTIER8BLOCK10SUMMATIONDELIVERED = 0x078A;
    public static final int ATTR_CURRENTTIER8BLOCK11SUMMATIONDELIVERED = 0x078B;
    public static final int ATTR_CURRENTTIER8BLOCK12SUMMATIONDELIVERED = 0x078C;
    public static final int ATTR_CURRENTTIER8BLOCK13SUMMATIONDELIVERED = 0x078D;
    public static final int ATTR_CURRENTTIER8BLOCK14SUMMATIONDELIVERED = 0x078E;
    public static final int ATTR_CURRENTTIER8BLOCK15SUMMATIONDELIVERED = 0x078F;
    public static final int ATTR_CURRENTTIER8BLOCK16SUMMATIONDELIVERED = 0x0790;
    public static final int ATTR_CURRENTTIER9BLOCK1SUMMATIONDELIVERED = 0x0791;
    public static final int ATTR_CURRENTTIER9BLOCK2SUMMATIONDELIVERED = 0x0792;
    public static final int ATTR_CURRENTTIER9BLOCK3SUMMATIONDELIVERED = 0x0793;
    public static final int ATTR_CURRENTTIER9BLOCK4SUMMATIONDELIVERED = 0x0794;
    public static final int ATTR_CURRENTTIER9BLOCK5SUMMATIONDELIVERED = 0x0795;
    public static final int ATTR_CURRENTTIER9BLOCK6SUMMATIONDELIVERED = 0x0796;
    public static final int ATTR_CURRENTTIER9BLOCK7SUMMATIONDELIVERED = 0x0797;
    public static final int ATTR_CURRENTTIER9BLOCK8SUMMATIONDELIVERED = 0x0798;
    public static final int ATTR_CURRENTTIER9BLOCK9SUMMATIONDELIVERED = 0x0799;
    public static final int ATTR_CURRENTTIER9BLOCK10SUMMATIONDELIVERED = 0x079A;
    public static final int ATTR_CURRENTTIER9BLOCK11SUMMATIONDELIVERED = 0x079B;
    public static final int ATTR_CURRENTTIER9BLOCK12SUMMATIONDELIVERED = 0x079C;
    public static final int ATTR_CURRENTTIER9BLOCK13SUMMATIONDELIVERED = 0x079D;
    public static final int ATTR_CURRENTTIER9BLOCK14SUMMATIONDELIVERED = 0x079E;
    public static final int ATTR_CURRENTTIER9BLOCK15SUMMATIONDELIVERED = 0x079F;
    public static final int ATTR_CURRENTTIER9BLOCK16SUMMATIONDELIVERED = 0x07A0;
    public static final int ATTR_CURRENTTIER10BLOCK1SUMMATIONDELIVERED = 0x07A1;
    public static final int ATTR_CURRENTTIER10BLOCK2SUMMATIONDELIVERED = 0x07A2;
    public static final int ATTR_CURRENTTIER10BLOCK3SUMMATIONDELIVERED = 0x07A3;
    public static final int ATTR_CURRENTTIER10BLOCK4SUMMATIONDELIVERED = 0x07A4;
    public static final int ATTR_CURRENTTIER10BLOCK5SUMMATIONDELIVERED = 0x07A5;
    public static final int ATTR_CURRENTTIER10BLOCK6SUMMATIONDELIVERED = 0x07A6;
    public static final int ATTR_CURRENTTIER10BLOCK7SUMMATIONDELIVERED = 0x07A7;
    public static final int ATTR_CURRENTTIER10BLOCK8SUMMATIONDELIVERED = 0x07A8;
    public static final int ATTR_CURRENTTIER10BLOCK9SUMMATIONDELIVERED = 0x07A9;
    public static final int ATTR_CURRENTTIER10BLOCK10SUMMATIONDELIVERED = 0x07AA;
    public static final int ATTR_CURRENTTIER10BLOCK11SUMMATIONDELIVERED = 0x07AB;
    public static final int ATTR_CURRENTTIER10BLOCK12SUMMATIONDELIVERED = 0x07AC;
    public static final int ATTR_CURRENTTIER10BLOCK13SUMMATIONDELIVERED = 0x07AD;
    public static final int ATTR_CURRENTTIER10BLOCK14SUMMATIONDELIVERED = 0x07AE;
    public static final int ATTR_CURRENTTIER10BLOCK15SUMMATIONDELIVERED = 0x07AF;
    public static final int ATTR_CURRENTTIER10BLOCK16SUMMATIONDELIVERED = 0x07B0;
    public static final int ATTR_CURRENTTIER11BLOCK1SUMMATIONDELIVERED = 0x07B1;
    public static final int ATTR_CURRENTTIER11BLOCK2SUMMATIONDELIVERED = 0x07B2;
    public static final int ATTR_CURRENTTIER11BLOCK3SUMMATIONDELIVERED = 0x07B3;
    public static final int ATTR_CURRENTTIER11BLOCK4SUMMATIONDELIVERED = 0x07B4;
    public static final int ATTR_CURRENTTIER11BLOCK5SUMMATIONDELIVERED = 0x07B5;
    public static final int ATTR_CURRENTTIER11BLOCK6SUMMATIONDELIVERED = 0x07B6;
    public static final int ATTR_CURRENTTIER11BLOCK7SUMMATIONDELIVERED = 0x07B7;
    public static final int ATTR_CURRENTTIER11BLOCK8SUMMATIONDELIVERED = 0x07B8;
    public static final int ATTR_CURRENTTIER11BLOCK9SUMMATIONDELIVERED = 0x07B9;
    public static final int ATTR_CURRENTTIER11BLOCK10SUMMATIONDELIVERED = 0x07BA;
    public static final int ATTR_CURRENTTIER11BLOCK11SUMMATIONDELIVERED = 0x07BB;
    public static final int ATTR_CURRENTTIER11BLOCK12SUMMATIONDELIVERED = 0x07BC;
    public static final int ATTR_CURRENTTIER11BLOCK13SUMMATIONDELIVERED = 0x07BD;
    public static final int ATTR_CURRENTTIER11BLOCK14SUMMATIONDELIVERED = 0x07BE;
    public static final int ATTR_CURRENTTIER11BLOCK15SUMMATIONDELIVERED = 0x07BF;
    public static final int ATTR_CURRENTTIER11BLOCK16SUMMATIONDELIVERED = 0x07C0;
    public static final int ATTR_CURRENTTIER12BLOCK1SUMMATIONDELIVERED = 0x07C1;
    public static final int ATTR_CURRENTTIER12BLOCK2SUMMATIONDELIVERED = 0x07C2;
    public static final int ATTR_CURRENTTIER12BLOCK3SUMMATIONDELIVERED = 0x07C3;
    public static final int ATTR_CURRENTTIER12BLOCK4SUMMATIONDELIVERED = 0x07C4;
    public static final int ATTR_CURRENTTIER12BLOCK5SUMMATIONDELIVERED = 0x07C5;
    public static final int ATTR_CURRENTTIER12BLOCK6SUMMATIONDELIVERED = 0x07C6;
    public static final int ATTR_CURRENTTIER12BLOCK7SUMMATIONDELIVERED = 0x07C7;
    public static final int ATTR_CURRENTTIER12BLOCK8SUMMATIONDELIVERED = 0x07C8;
    public static final int ATTR_CURRENTTIER12BLOCK9SUMMATIONDELIVERED = 0x07C9;
    public static final int ATTR_CURRENTTIER12BLOCK10SUMMATIONDELIVERED = 0x07CA;
    public static final int ATTR_CURRENTTIER12BLOCK11SUMMATIONDELIVERED = 0x07CB;
    public static final int ATTR_CURRENTTIER12BLOCK12SUMMATIONDELIVERED = 0x07CC;
    public static final int ATTR_CURRENTTIER12BLOCK13SUMMATIONDELIVERED = 0x07CD;
    public static final int ATTR_CURRENTTIER12BLOCK14SUMMATIONDELIVERED = 0x07CE;
    public static final int ATTR_CURRENTTIER12BLOCK15SUMMATIONDELIVERED = 0x07CF;
    public static final int ATTR_CURRENTTIER12BLOCK16SUMMATIONDELIVERED = 0x07D0;
    public static final int ATTR_CURRENTTIER13BLOCK1SUMMATIONDELIVERED = 0x07D1;
    public static final int ATTR_CURRENTTIER13BLOCK2SUMMATIONDELIVERED = 0x07D2;
    public static final int ATTR_CURRENTTIER13BLOCK3SUMMATIONDELIVERED = 0x07D3;
    public static final int ATTR_CURRENTTIER13BLOCK4SUMMATIONDELIVERED = 0x07D4;
    public static final int ATTR_CURRENTTIER13BLOCK5SUMMATIONDELIVERED = 0x07D5;
    public static final int ATTR_CURRENTTIER13BLOCK6SUMMATIONDELIVERED = 0x07D6;
    public static final int ATTR_CURRENTTIER13BLOCK7SUMMATIONDELIVERED = 0x07D7;
    public static final int ATTR_CURRENTTIER13BLOCK8SUMMATIONDELIVERED = 0x07D8;
    public static final int ATTR_CURRENTTIER13BLOCK9SUMMATIONDELIVERED = 0x07D9;
    public static final int ATTR_CURRENTTIER13BLOCK10SUMMATIONDELIVERED = 0x07DA;
    public static final int ATTR_CURRENTTIER13BLOCK11SUMMATIONDELIVERED = 0x07DB;
    public static final int ATTR_CURRENTTIER13BLOCK12SUMMATIONDELIVERED = 0x07DC;
    public static final int ATTR_CURRENTTIER13BLOCK13SUMMATIONDELIVERED = 0x07DD;
    public static final int ATTR_CURRENTTIER13BLOCK14SUMMATIONDELIVERED = 0x07DE;
    public static final int ATTR_CURRENTTIER13BLOCK15SUMMATIONDELIVERED = 0x07DF;
    public static final int ATTR_CURRENTTIER13BLOCK16SUMMATIONDELIVERED = 0x07E0;
    public static final int ATTR_CURRENTTIER14BLOCK1SUMMATIONDELIVERED = 0x07E1;
    public static final int ATTR_CURRENTTIER14BLOCK2SUMMATIONDELIVERED = 0x07E2;
    public static final int ATTR_CURRENTTIER14BLOCK3SUMMATIONDELIVERED = 0x07E3;
    public static final int ATTR_CURRENTTIER14BLOCK4SUMMATIONDELIVERED = 0x07E4;
    public static final int ATTR_CURRENTTIER14BLOCK5SUMMATIONDELIVERED = 0x07E5;
    public static final int ATTR_CURRENTTIER14BLOCK6SUMMATIONDELIVERED = 0x07E6;
    public static final int ATTR_CURRENTTIER14BLOCK7SUMMATIONDELIVERED = 0x07E7;
    public static final int ATTR_CURRENTTIER14BLOCK8SUMMATIONDELIVERED = 0x07E8;
    public static final int ATTR_CURRENTTIER14BLOCK9SUMMATIONDELIVERED = 0x07E9;
    public static final int ATTR_CURRENTTIER14BLOCK10SUMMATIONDELIVERED = 0x07EA;
    public static final int ATTR_CURRENTTIER14BLOCK11SUMMATIONDELIVERED = 0x07EB;
    public static final int ATTR_CURRENTTIER14BLOCK12SUMMATIONDELIVERED = 0x07EC;
    public static final int ATTR_CURRENTTIER14BLOCK13SUMMATIONDELIVERED = 0x07ED;
    public static final int ATTR_CURRENTTIER14BLOCK14SUMMATIONDELIVERED = 0x07EE;
    public static final int ATTR_CURRENTTIER14BLOCK15SUMMATIONDELIVERED = 0x07EF;
    public static final int ATTR_CURRENTTIER14BLOCK16SUMMATIONDELIVERED = 0x07F0;
    public static final int ATTR_CURRENTTIER15BLOCK1SUMMATIONDELIVERED = 0x07F1;
    public static final int ATTR_CURRENTTIER15BLOCK2SUMMATIONDELIVERED = 0x07F2;
    public static final int ATTR_CURRENTTIER15BLOCK3SUMMATIONDELIVERED = 0x07F3;
    public static final int ATTR_CURRENTTIER15BLOCK4SUMMATIONDELIVERED = 0x07F4;
    public static final int ATTR_CURRENTTIER15BLOCK5SUMMATIONDELIVERED = 0x07F5;
    public static final int ATTR_CURRENTTIER15BLOCK6SUMMATIONDELIVERED = 0x07F6;
    public static final int ATTR_CURRENTTIER15BLOCK7SUMMATIONDELIVERED = 0x07F7;
    public static final int ATTR_CURRENTTIER15BLOCK8SUMMATIONDELIVERED = 0x07F8;
    public static final int ATTR_CURRENTTIER15BLOCK9SUMMATIONDELIVERED = 0x07F9;
    public static final int ATTR_CURRENTTIER15BLOCK10SUMMATIONDELIVERED = 0x07FA;
    public static final int ATTR_CURRENTTIER15BLOCK11SUMMATIONDELIVERED = 0x07FB;
    public static final int ATTR_CURRENTTIER15BLOCK12SUMMATIONDELIVERED = 0x07FC;
    public static final int ATTR_CURRENTTIER15BLOCK13SUMMATIONDELIVERED = 0x07FD;
    public static final int ATTR_CURRENTTIER15BLOCK14SUMMATIONDELIVERED = 0x07FE;
    public static final int ATTR_CURRENTTIER15BLOCK15SUMMATIONDELIVERED = 0x07FF;
    public static final int ATTR_CURRENTTIER15BLOCK16SUMMATIONDELIVERED = 0x0800;
    public static final int ATTR_GENERICALARMMASK = 0x0800;
    public static final int ATTR_ELECTRICITYALARMMASK = 0x0801;
    public static final int ATTR_GENERICFLOWPRESSUREALARMMASK = 0x0802;
    public static final int ATTR_WATERSPECIFICALARMMASK = 0x0803;
    public static final int ATTR_HEATANDCOOLINGSPECIFICALARMMASK = 0x0804;
    public static final int ATTR_GASSPECIFICALARMMASK = 0x0805;
    public static final int ATTR_EXTENDEDGENERICALARMMASK = 0x0806;
    public static final int ATTR_MANUFACTUREALARMMASK = 0x0807;
    public static final int ATTR_CURRENTNOTIERBLOCK1SUMMATIONRECEIVED = 0x0901;
    public static final int ATTR_CURRENTNOTIERBLOCK2SUMMATIONRECEIVED = 0x0902;
    public static final int ATTR_CURRENTNOTIERBLOCK3SUMMATIONRECEIVED = 0x0903;
    public static final int ATTR_CURRENTNOTIERBLOCK4SUMMATIONRECEIVED = 0x0904;
    public static final int ATTR_CURRENTNOTIERBLOCK5SUMMATIONRECEIVED = 0x0905;
    public static final int ATTR_CURRENTNOTIERBLOCK6SUMMATIONRECEIVED = 0x0906;
    public static final int ATTR_CURRENTNOTIERBLOCK7SUMMATIONRECEIVED = 0x0907;
    public static final int ATTR_CURRENTNOTIERBLOCK8SUMMATIONRECEIVED = 0x0908;
    public static final int ATTR_CURRENTNOTIERBLOCK9SUMMATIONRECEIVED = 0x0909;
    public static final int ATTR_CURRENTNOTIERBLOCK10SUMMATIONRECEIVED = 0x090A;
    public static final int ATTR_CURRENTNOTIERBLOCK11SUMMATIONRECEIVED = 0x090B;
    public static final int ATTR_CURRENTNOTIERBLOCK12SUMMATIONRECEIVED = 0x090C;
    public static final int ATTR_CURRENTNOTIERBLOCK13SUMMATIONRECEIVED = 0x090D;
    public static final int ATTR_CURRENTNOTIERBLOCK14SUMMATIONRECEIVED = 0x090E;
    public static final int ATTR_CURRENTNOTIERBLOCK15SUMMATIONRECEIVED = 0x090F;
    public static final int ATTR_CURRENTNOTIERBLOCK16SUMMATIONRECEIVED = 0x0910;
    public static final int ATTR_CURRENTTIER1BLOCK1SUMMATIONRECEIVED = 0x0911;
    public static final int ATTR_CURRENTTIER1BLOCK2SUMMATIONRECEIVED = 0x0912;
    public static final int ATTR_CURRENTTIER1BLOCK3SUMMATIONRECEIVED = 0x0913;
    public static final int ATTR_CURRENTTIER1BLOCK4SUMMATIONRECEIVED = 0x0914;
    public static final int ATTR_CURRENTTIER1BLOCK5SUMMATIONRECEIVED = 0x0915;
    public static final int ATTR_CURRENTTIER1BLOCK6SUMMATIONRECEIVED = 0x0916;
    public static final int ATTR_CURRENTTIER1BLOCK7SUMMATIONRECEIVED = 0x0917;
    public static final int ATTR_CURRENTTIER1BLOCK8SUMMATIONRECEIVED = 0x0918;
    public static final int ATTR_CURRENTTIER1BLOCK9SUMMATIONRECEIVED = 0x0919;
    public static final int ATTR_CURRENTTIER1BLOCK10SUMMATIONRECEIVED = 0x091A;
    public static final int ATTR_CURRENTTIER1BLOCK11SUMMATIONRECEIVED = 0x091B;
    public static final int ATTR_CURRENTTIER1BLOCK12SUMMATIONRECEIVED = 0x091C;
    public static final int ATTR_CURRENTTIER1BLOCK13SUMMATIONRECEIVED = 0x091D;
    public static final int ATTR_CURRENTTIER1BLOCK14SUMMATIONRECEIVED = 0x091E;
    public static final int ATTR_CURRENTTIER1BLOCK15SUMMATIONRECEIVED = 0x091F;
    public static final int ATTR_CURRENTTIER1BLOCK16SUMMATIONRECEIVED = 0x0920;
    public static final int ATTR_CURRENTTIER2BLOCK1SUMMATIONRECEIVED = 0x0921;
    public static final int ATTR_CURRENTTIER2BLOCK2SUMMATIONRECEIVED = 0x0922;
    public static final int ATTR_CURRENTTIER2BLOCK3SUMMATIONRECEIVED = 0x0923;
    public static final int ATTR_CURRENTTIER2BLOCK4SUMMATIONRECEIVED = 0x0924;
    public static final int ATTR_CURRENTTIER2BLOCK5SUMMATIONRECEIVED = 0x0925;
    public static final int ATTR_CURRENTTIER2BLOCK6SUMMATIONRECEIVED = 0x0926;
    public static final int ATTR_CURRENTTIER2BLOCK7SUMMATIONRECEIVED = 0x0927;
    public static final int ATTR_CURRENTTIER2BLOCK8SUMMATIONRECEIVED = 0x0928;
    public static final int ATTR_CURRENTTIER2BLOCK9SUMMATIONRECEIVED = 0x0929;
    public static final int ATTR_CURRENTTIER2BLOCK10SUMMATIONRECEIVED = 0x092A;
    public static final int ATTR_CURRENTTIER2BLOCK11SUMMATIONRECEIVED = 0x092B;
    public static final int ATTR_CURRENTTIER2BLOCK12SUMMATIONRECEIVED = 0x092C;
    public static final int ATTR_CURRENTTIER2BLOCK13SUMMATIONRECEIVED = 0x092D;
    public static final int ATTR_CURRENTTIER2BLOCK14SUMMATIONRECEIVED = 0x092E;
    public static final int ATTR_CURRENTTIER2BLOCK15SUMMATIONRECEIVED = 0x092F;
    public static final int ATTR_CURRENTTIER2BLOCK16SUMMATIONRECEIVED = 0x0930;
    public static final int ATTR_CURRENTTIER3BLOCK1SUMMATIONRECEIVED = 0x0931;
    public static final int ATTR_CURRENTTIER3BLOCK2SUMMATIONRECEIVED = 0x0932;
    public static final int ATTR_CURRENTTIER3BLOCK3SUMMATIONRECEIVED = 0x0933;
    public static final int ATTR_CURRENTTIER3BLOCK4SUMMATIONRECEIVED = 0x0934;
    public static final int ATTR_CURRENTTIER3BLOCK5SUMMATIONRECEIVED = 0x0935;
    public static final int ATTR_CURRENTTIER3BLOCK6SUMMATIONRECEIVED = 0x0936;
    public static final int ATTR_CURRENTTIER3BLOCK7SUMMATIONRECEIVED = 0x0937;
    public static final int ATTR_CURRENTTIER3BLOCK8SUMMATIONRECEIVED = 0x0938;
    public static final int ATTR_CURRENTTIER3BLOCK9SUMMATIONRECEIVED = 0x0939;
    public static final int ATTR_CURRENTTIER3BLOCK10SUMMATIONRECEIVED = 0x093A;
    public static final int ATTR_CURRENTTIER3BLOCK11SUMMATIONRECEIVED = 0x093B;
    public static final int ATTR_CURRENTTIER3BLOCK12SUMMATIONRECEIVED = 0x093C;
    public static final int ATTR_CURRENTTIER3BLOCK13SUMMATIONRECEIVED = 0x093D;
    public static final int ATTR_CURRENTTIER3BLOCK14SUMMATIONRECEIVED = 0x093E;
    public static final int ATTR_CURRENTTIER3BLOCK15SUMMATIONRECEIVED = 0x093F;
    public static final int ATTR_CURRENTTIER3BLOCK16SUMMATIONRECEIVED = 0x0940;
    public static final int ATTR_CURRENTTIER4BLOCK1SUMMATIONRECEIVED = 0x0941;
    public static final int ATTR_CURRENTTIER4BLOCK2SUMMATIONRECEIVED = 0x0942;
    public static final int ATTR_CURRENTTIER4BLOCK3SUMMATIONRECEIVED = 0x0943;
    public static final int ATTR_CURRENTTIER4BLOCK4SUMMATIONRECEIVED = 0x0944;
    public static final int ATTR_CURRENTTIER4BLOCK5SUMMATIONRECEIVED = 0x0945;
    public static final int ATTR_CURRENTTIER4BLOCK6SUMMATIONRECEIVED = 0x0946;
    public static final int ATTR_CURRENTTIER4BLOCK7SUMMATIONRECEIVED = 0x0947;
    public static final int ATTR_CURRENTTIER4BLOCK8SUMMATIONRECEIVED = 0x0948;
    public static final int ATTR_CURRENTTIER4BLOCK9SUMMATIONRECEIVED = 0x0949;
    public static final int ATTR_CURRENTTIER4BLOCK10SUMMATIONRECEIVED = 0x094A;
    public static final int ATTR_CURRENTTIER4BLOCK11SUMMATIONRECEIVED = 0x094B;
    public static final int ATTR_CURRENTTIER4BLOCK12SUMMATIONRECEIVED = 0x094C;
    public static final int ATTR_CURRENTTIER4BLOCK13SUMMATIONRECEIVED = 0x094D;
    public static final int ATTR_CURRENTTIER4BLOCK14SUMMATIONRECEIVED = 0x094E;
    public static final int ATTR_CURRENTTIER4BLOCK15SUMMATIONRECEIVED = 0x094F;
    public static final int ATTR_CURRENTTIER4BLOCK16SUMMATIONRECEIVED = 0x0950;
    public static final int ATTR_CURRENTTIER5BLOCK1SUMMATIONRECEIVED = 0x0951;
    public static final int ATTR_CURRENTTIER5BLOCK2SUMMATIONRECEIVED = 0x0952;
    public static final int ATTR_CURRENTTIER5BLOCK3SUMMATIONRECEIVED = 0x0953;
    public static final int ATTR_CURRENTTIER5BLOCK4SUMMATIONRECEIVED = 0x0954;
    public static final int ATTR_CURRENTTIER5BLOCK5SUMMATIONRECEIVED = 0x0955;
    public static final int ATTR_CURRENTTIER5BLOCK6SUMMATIONRECEIVED = 0x0956;
    public static final int ATTR_CURRENTTIER5BLOCK7SUMMATIONRECEIVED = 0x0957;
    public static final int ATTR_CURRENTTIER5BLOCK8SUMMATIONRECEIVED = 0x0958;
    public static final int ATTR_CURRENTTIER5BLOCK9SUMMATIONRECEIVED = 0x0959;
    public static final int ATTR_CURRENTTIER5BLOCK10SUMMATIONRECEIVED = 0x095A;
    public static final int ATTR_CURRENTTIER5BLOCK11SUMMATIONRECEIVED = 0x095B;
    public static final int ATTR_CURRENTTIER5BLOCK12SUMMATIONRECEIVED = 0x095C;
    public static final int ATTR_CURRENTTIER5BLOCK13SUMMATIONRECEIVED = 0x095D;
    public static final int ATTR_CURRENTTIER5BLOCK14SUMMATIONRECEIVED = 0x095E;
    public static final int ATTR_CURRENTTIER5BLOCK15SUMMATIONRECEIVED = 0x095F;
    public static final int ATTR_CURRENTTIER5BLOCK16SUMMATIONRECEIVED = 0x0960;
    public static final int ATTR_CURRENTTIER6BLOCK1SUMMATIONRECEIVED = 0x0961;
    public static final int ATTR_CURRENTTIER6BLOCK2SUMMATIONRECEIVED = 0x0962;
    public static final int ATTR_CURRENTTIER6BLOCK3SUMMATIONRECEIVED = 0x0963;
    public static final int ATTR_CURRENTTIER6BLOCK4SUMMATIONRECEIVED = 0x0964;
    public static final int ATTR_CURRENTTIER6BLOCK5SUMMATIONRECEIVED = 0x0965;
    public static final int ATTR_CURRENTTIER6BLOCK6SUMMATIONRECEIVED = 0x0966;
    public static final int ATTR_CURRENTTIER6BLOCK7SUMMATIONRECEIVED = 0x0967;
    public static final int ATTR_CURRENTTIER6BLOCK8SUMMATIONRECEIVED = 0x0968;
    public static final int ATTR_CURRENTTIER6BLOCK9SUMMATIONRECEIVED = 0x0969;
    public static final int ATTR_CURRENTTIER6BLOCK10SUMMATIONRECEIVED = 0x096A;
    public static final int ATTR_CURRENTTIER6BLOCK11SUMMATIONRECEIVED = 0x096B;
    public static final int ATTR_CURRENTTIER6BLOCK12SUMMATIONRECEIVED = 0x096C;
    public static final int ATTR_CURRENTTIER6BLOCK13SUMMATIONRECEIVED = 0x096D;
    public static final int ATTR_CURRENTTIER6BLOCK14SUMMATIONRECEIVED = 0x096E;
    public static final int ATTR_CURRENTTIER6BLOCK15SUMMATIONRECEIVED = 0x096F;
    public static final int ATTR_CURRENTTIER6BLOCK16SUMMATIONRECEIVED = 0x0970;
    public static final int ATTR_CURRENTTIER7BLOCK1SUMMATIONRECEIVED = 0x0971;
    public static final int ATTR_CURRENTTIER7BLOCK2SUMMATIONRECEIVED = 0x0972;
    public static final int ATTR_CURRENTTIER7BLOCK3SUMMATIONRECEIVED = 0x0973;
    public static final int ATTR_CURRENTTIER7BLOCK4SUMMATIONRECEIVED = 0x0974;
    public static final int ATTR_CURRENTTIER7BLOCK5SUMMATIONRECEIVED = 0x0975;
    public static final int ATTR_CURRENTTIER7BLOCK6SUMMATIONRECEIVED = 0x0976;
    public static final int ATTR_CURRENTTIER7BLOCK7SUMMATIONRECEIVED = 0x0977;
    public static final int ATTR_CURRENTTIER7BLOCK8SUMMATIONRECEIVED = 0x0978;
    public static final int ATTR_CURRENTTIER7BLOCK9SUMMATIONRECEIVED = 0x0979;
    public static final int ATTR_CURRENTTIER7BLOCK10SUMMATIONRECEIVED = 0x097A;
    public static final int ATTR_CURRENTTIER7BLOCK11SUMMATIONRECEIVED = 0x097B;
    public static final int ATTR_CURRENTTIER7BLOCK12SUMMATIONRECEIVED = 0x097C;
    public static final int ATTR_CURRENTTIER7BLOCK13SUMMATIONRECEIVED = 0x097D;
    public static final int ATTR_CURRENTTIER7BLOCK14SUMMATIONRECEIVED = 0x097E;
    public static final int ATTR_CURRENTTIER7BLOCK15SUMMATIONRECEIVED = 0x097F;
    public static final int ATTR_CURRENTTIER7BLOCK16SUMMATIONRECEIVED = 0x0980;
    public static final int ATTR_CURRENTTIER8BLOCK1SUMMATIONRECEIVED = 0x0981;
    public static final int ATTR_CURRENTTIER8BLOCK2SUMMATIONRECEIVED = 0x0982;
    public static final int ATTR_CURRENTTIER8BLOCK3SUMMATIONRECEIVED = 0x0983;
    public static final int ATTR_CURRENTTIER8BLOCK4SUMMATIONRECEIVED = 0x0984;
    public static final int ATTR_CURRENTTIER8BLOCK5SUMMATIONRECEIVED = 0x0985;
    public static final int ATTR_CURRENTTIER8BLOCK6SUMMATIONRECEIVED = 0x0986;
    public static final int ATTR_CURRENTTIER8BLOCK7SUMMATIONRECEIVED = 0x0987;
    public static final int ATTR_CURRENTTIER8BLOCK8SUMMATIONRECEIVED = 0x0988;
    public static final int ATTR_CURRENTTIER8BLOCK9SUMMATIONRECEIVED = 0x0989;
    public static final int ATTR_CURRENTTIER8BLOCK10SUMMATIONRECEIVED = 0x098A;
    public static final int ATTR_CURRENTTIER8BLOCK11SUMMATIONRECEIVED = 0x098B;
    public static final int ATTR_CURRENTTIER8BLOCK12SUMMATIONRECEIVED = 0x098C;
    public static final int ATTR_CURRENTTIER8BLOCK13SUMMATIONRECEIVED = 0x098D;
    public static final int ATTR_CURRENTTIER8BLOCK14SUMMATIONRECEIVED = 0x098E;
    public static final int ATTR_CURRENTTIER8BLOCK15SUMMATIONRECEIVED = 0x098F;
    public static final int ATTR_CURRENTTIER8BLOCK16SUMMATIONRECEIVED = 0x0990;
    public static final int ATTR_CURRENTTIER9BLOCK1SUMMATIONRECEIVED = 0x0991;
    public static final int ATTR_CURRENTTIER9BLOCK2SUMMATIONRECEIVED = 0x0992;
    public static final int ATTR_CURRENTTIER9BLOCK3SUMMATIONRECEIVED = 0x0993;
    public static final int ATTR_CURRENTTIER9BLOCK4SUMMATIONRECEIVED = 0x0994;
    public static final int ATTR_CURRENTTIER9BLOCK5SUMMATIONRECEIVED = 0x0995;
    public static final int ATTR_CURRENTTIER9BLOCK6SUMMATIONRECEIVED = 0x0996;
    public static final int ATTR_CURRENTTIER9BLOCK7SUMMATIONRECEIVED = 0x0997;
    public static final int ATTR_CURRENTTIER9BLOCK8SUMMATIONRECEIVED = 0x0998;
    public static final int ATTR_CURRENTTIER9BLOCK9SUMMATIONRECEIVED = 0x0999;
    public static final int ATTR_CURRENTTIER9BLOCK10SUMMATIONRECEIVED = 0x099A;
    public static final int ATTR_CURRENTTIER9BLOCK11SUMMATIONRECEIVED = 0x099B;
    public static final int ATTR_CURRENTTIER9BLOCK12SUMMATIONRECEIVED = 0x099C;
    public static final int ATTR_CURRENTTIER9BLOCK13SUMMATIONRECEIVED = 0x099D;
    public static final int ATTR_CURRENTTIER9BLOCK14SUMMATIONRECEIVED = 0x099E;
    public static final int ATTR_CURRENTTIER9BLOCK15SUMMATIONRECEIVED = 0x099F;
    public static final int ATTR_CURRENTTIER9BLOCK16SUMMATIONRECEIVED = 0x09A0;
    public static final int ATTR_CURRENTTIER10BLOCK1SUMMATIONRECEIVED = 0x09A1;
    public static final int ATTR_CURRENTTIER10BLOCK2SUMMATIONRECEIVED = 0x09A2;
    public static final int ATTR_CURRENTTIER10BLOCK3SUMMATIONRECEIVED = 0x09A3;
    public static final int ATTR_CURRENTTIER10BLOCK4SUMMATIONRECEIVED = 0x09A4;
    public static final int ATTR_CURRENTTIER10BLOCK5SUMMATIONRECEIVED = 0x09A5;
    public static final int ATTR_CURRENTTIER10BLOCK6SUMMATIONRECEIVED = 0x09A6;
    public static final int ATTR_CURRENTTIER10BLOCK7SUMMATIONRECEIVED = 0x09A7;
    public static final int ATTR_CURRENTTIER10BLOCK8SUMMATIONRECEIVED = 0x09A8;
    public static final int ATTR_CURRENTTIER10BLOCK9SUMMATIONRECEIVED = 0x09A9;
    public static final int ATTR_CURRENTTIER10BLOCK10SUMMATIONRECEIVED = 0x09AA;
    public static final int ATTR_CURRENTTIER10BLOCK11SUMMATIONRECEIVED = 0x09AB;
    public static final int ATTR_CURRENTTIER10BLOCK12SUMMATIONRECEIVED = 0x09AC;
    public static final int ATTR_CURRENTTIER10BLOCK13SUMMATIONRECEIVED = 0x09AD;
    public static final int ATTR_CURRENTTIER10BLOCK14SUMMATIONRECEIVED = 0x09AE;
    public static final int ATTR_CURRENTTIER10BLOCK15SUMMATIONRECEIVED = 0x09AF;
    public static final int ATTR_CURRENTTIER10BLOCK16SUMMATIONRECEIVED = 0x09B0;
    public static final int ATTR_CURRENTTIER11BLOCK1SUMMATIONRECEIVED = 0x09B1;
    public static final int ATTR_CURRENTTIER11BLOCK2SUMMATIONRECEIVED = 0x09B2;
    public static final int ATTR_CURRENTTIER11BLOCK3SUMMATIONRECEIVED = 0x09B3;
    public static final int ATTR_CURRENTTIER11BLOCK4SUMMATIONRECEIVED = 0x09B4;
    public static final int ATTR_CURRENTTIER11BLOCK5SUMMATIONRECEIVED = 0x09B5;
    public static final int ATTR_CURRENTTIER11BLOCK6SUMMATIONRECEIVED = 0x09B6;
    public static final int ATTR_CURRENTTIER11BLOCK7SUMMATIONRECEIVED = 0x09B7;
    public static final int ATTR_CURRENTTIER11BLOCK8SUMMATIONRECEIVED = 0x09B8;
    public static final int ATTR_CURRENTTIER11BLOCK9SUMMATIONRECEIVED = 0x09B9;
    public static final int ATTR_CURRENTTIER11BLOCK10SUMMATIONRECEIVED = 0x09BA;
    public static final int ATTR_CURRENTTIER11BLOCK11SUMMATIONRECEIVED = 0x09BB;
    public static final int ATTR_CURRENTTIER11BLOCK12SUMMATIONRECEIVED = 0x09BC;
    public static final int ATTR_CURRENTTIER11BLOCK13SUMMATIONRECEIVED = 0x09BD;
    public static final int ATTR_CURRENTTIER11BLOCK14SUMMATIONRECEIVED = 0x09BE;
    public static final int ATTR_CURRENTTIER11BLOCK15SUMMATIONRECEIVED = 0x09BF;
    public static final int ATTR_CURRENTTIER11BLOCK16SUMMATIONRECEIVED = 0x09C0;
    public static final int ATTR_CURRENTTIER12BLOCK1SUMMATIONRECEIVED = 0x09C1;
    public static final int ATTR_CURRENTTIER12BLOCK2SUMMATIONRECEIVED = 0x09C2;
    public static final int ATTR_CURRENTTIER12BLOCK3SUMMATIONRECEIVED = 0x09C3;
    public static final int ATTR_CURRENTTIER12BLOCK4SUMMATIONRECEIVED = 0x09C4;
    public static final int ATTR_CURRENTTIER12BLOCK5SUMMATIONRECEIVED = 0x09C5;
    public static final int ATTR_CURRENTTIER12BLOCK6SUMMATIONRECEIVED = 0x09C6;
    public static final int ATTR_CURRENTTIER12BLOCK7SUMMATIONRECEIVED = 0x09C7;
    public static final int ATTR_CURRENTTIER12BLOCK8SUMMATIONRECEIVED = 0x09C8;
    public static final int ATTR_CURRENTTIER12BLOCK9SUMMATIONRECEIVED = 0x09C9;
    public static final int ATTR_CURRENTTIER12BLOCK10SUMMATIONRECEIVED = 0x09CA;
    public static final int ATTR_CURRENTTIER12BLOCK11SUMMATIONRECEIVED = 0x09CB;
    public static final int ATTR_CURRENTTIER12BLOCK12SUMMATIONRECEIVED = 0x09CC;
    public static final int ATTR_CURRENTTIER12BLOCK13SUMMATIONRECEIVED = 0x09CD;
    public static final int ATTR_CURRENTTIER12BLOCK14SUMMATIONRECEIVED = 0x09CE;
    public static final int ATTR_CURRENTTIER12BLOCK15SUMMATIONRECEIVED = 0x09CF;
    public static final int ATTR_CURRENTTIER12BLOCK16SUMMATIONRECEIVED = 0x09D0;
    public static final int ATTR_CURRENTTIER13BLOCK1SUMMATIONRECEIVED = 0x09D1;
    public static final int ATTR_CURRENTTIER13BLOCK2SUMMATIONRECEIVED = 0x09D2;
    public static final int ATTR_CURRENTTIER13BLOCK3SUMMATIONRECEIVED = 0x09D3;
    public static final int ATTR_CURRENTTIER13BLOCK4SUMMATIONRECEIVED = 0x09D4;
    public static final int ATTR_CURRENTTIER13BLOCK5SUMMATIONRECEIVED = 0x09D5;
    public static final int ATTR_CURRENTTIER13BLOCK6SUMMATIONRECEIVED = 0x09D6;
    public static final int ATTR_CURRENTTIER13BLOCK7SUMMATIONRECEIVED = 0x09D7;
    public static final int ATTR_CURRENTTIER13BLOCK8SUMMATIONRECEIVED = 0x09D8;
    public static final int ATTR_CURRENTTIER13BLOCK9SUMMATIONRECEIVED = 0x09D9;
    public static final int ATTR_CURRENTTIER13BLOCK10SUMMATIONRECEIVED = 0x09DA;
    public static final int ATTR_CURRENTTIER13BLOCK11SUMMATIONRECEIVED = 0x09DB;
    public static final int ATTR_CURRENTTIER13BLOCK12SUMMATIONRECEIVED = 0x09DC;
    public static final int ATTR_CURRENTTIER13BLOCK13SUMMATIONRECEIVED = 0x09DD;
    public static final int ATTR_CURRENTTIER13BLOCK14SUMMATIONRECEIVED = 0x09DE;
    public static final int ATTR_CURRENTTIER13BLOCK15SUMMATIONRECEIVED = 0x09DF;
    public static final int ATTR_CURRENTTIER13BLOCK16SUMMATIONRECEIVED = 0x09E0;
    public static final int ATTR_CURRENTTIER14BLOCK1SUMMATIONRECEIVED = 0x09E1;
    public static final int ATTR_CURRENTTIER14BLOCK2SUMMATIONRECEIVED = 0x09E2;
    public static final int ATTR_CURRENTTIER14BLOCK3SUMMATIONRECEIVED = 0x09E3;
    public static final int ATTR_CURRENTTIER14BLOCK4SUMMATIONRECEIVED = 0x09E4;
    public static final int ATTR_CURRENTTIER14BLOCK5SUMMATIONRECEIVED = 0x09E5;
    public static final int ATTR_CURRENTTIER14BLOCK6SUMMATIONRECEIVED = 0x09E6;
    public static final int ATTR_CURRENTTIER14BLOCK7SUMMATIONRECEIVED = 0x09E7;
    public static final int ATTR_CURRENTTIER14BLOCK8SUMMATIONRECEIVED = 0x09E8;
    public static final int ATTR_CURRENTTIER14BLOCK9SUMMATIONRECEIVED = 0x09E9;
    public static final int ATTR_CURRENTTIER14BLOCK10SUMMATIONRECEIVED = 0x09EA;
    public static final int ATTR_CURRENTTIER14BLOCK11SUMMATIONRECEIVED = 0x09EB;
    public static final int ATTR_CURRENTTIER14BLOCK12SUMMATIONRECEIVED = 0x09EC;
    public static final int ATTR_CURRENTTIER14BLOCK13SUMMATIONRECEIVED = 0x09ED;
    public static final int ATTR_CURRENTTIER14BLOCK14SUMMATIONRECEIVED = 0x09EE;
    public static final int ATTR_CURRENTTIER14BLOCK15SUMMATIONRECEIVED = 0x09EF;
    public static final int ATTR_CURRENTTIER14BLOCK16SUMMATIONRECEIVED = 0x09F0;
    public static final int ATTR_CURRENTTIER15BLOCK1SUMMATIONRECEIVED = 0x09F1;
    public static final int ATTR_CURRENTTIER15BLOCK2SUMMATIONRECEIVED = 0x09F2;
    public static final int ATTR_CURRENTTIER15BLOCK3SUMMATIONRECEIVED = 0x09F3;
    public static final int ATTR_CURRENTTIER15BLOCK4SUMMATIONRECEIVED = 0x09F4;
    public static final int ATTR_CURRENTTIER15BLOCK5SUMMATIONRECEIVED = 0x09F5;
    public static final int ATTR_CURRENTTIER15BLOCK6SUMMATIONRECEIVED = 0x09F6;
    public static final int ATTR_CURRENTTIER15BLOCK7SUMMATIONRECEIVED = 0x09F7;
    public static final int ATTR_CURRENTTIER15BLOCK8SUMMATIONRECEIVED = 0x09F8;
    public static final int ATTR_CURRENTTIER15BLOCK9SUMMATIONRECEIVED = 0x09F9;
    public static final int ATTR_CURRENTTIER15BLOCK10SUMMATIONRECEIVED = 0x09FA;
    public static final int ATTR_CURRENTTIER15BLOCK11SUMMATIONRECEIVED = 0x09FB;
    public static final int ATTR_CURRENTTIER15BLOCK12SUMMATIONRECEIVED = 0x09FC;
    public static final int ATTR_CURRENTTIER15BLOCK13SUMMATIONRECEIVED = 0x09FD;
    public static final int ATTR_CURRENTTIER15BLOCK14SUMMATIONRECEIVED = 0x09FE;
    public static final int ATTR_CURRENTTIER15BLOCK15SUMMATIONRECEIVED = 0x09FF;
    public static final int ATTR_CURRENTTIER15BLOCK16SUMMATIONRECEIVED = 0x0A00;
    /**
     * BillToDateDelivered provides a value for the costs in the current billing period. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillDeliveredTrailingDigit attribute.
     */
    public static final int ATTR_BILLTODATEDELIVERED = 0x0A00;
    /**
     * The UTC timestamp when the associated BillToDateDelivered attribute was last
     * updated.
     */
    public static final int ATTR_BILLTODATETIMESTAMPDELIVERED = 0x0A01;
    /**
     * ProjectedBillDelivered provides a value indicating what the estimated state of the
     * account will be at the end of the billing period based on past consumption. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillDeliveredTrailingDigit attribute.
     */
    public static final int ATTR_PROJECTEDBILLDELIVERED = 0x0A02;
    /**
     * The UTC timestamp when the associated ProjectedBillDelivered attribute was last
     * updated.
     */
    public static final int ATTR_PROJECTEDBILLTIMESTAMPDELIVERED = 0x0A03;
    /**
     * An 8-bit BitMap used to determine where the decimal point is located in the
     * BillToDateDelivered and ProjectedBillDelivered attributes. The most significant
     * nibble indicates the number of digits to the right of the decimal point. The least
     * significant nibble is reserved and shall be 0. The BillDeliveredTrailingDigit
     * attribute represents the current active value.
     */
    public static final int ATTR_BILLDELIVEREDTRAILINGDIGIT = 0x0A04;
    /**
     * BillToDateReceived provides a value for the costs in the current billing period. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillReceivedTrailingDigit attribute.
     */
    public static final int ATTR_BILLTODATERECEIVED = 0x0A10;
    /**
     * The UTC timestamp when the associated BillToDateReceived attribute was last updated.
     */
    public static final int ATTR_BILLTODATETIMESTAMPRECEIVED = 0x0A11;
    /**
     * ProjectedBillReceived provides a value indicating what the estimated state of the
     * account will be at the end of the billing period based on past generation. This attribute
     * is measured in a base unit of Currency with the decimal point located as indicated by the
     * BillReceivedTrailingDigit attribute.
     */
    public static final int ATTR_PROJECTEDBILLRECEIVED = 0x0A12;
    /**
     * The UTC timestamp when the associated ProjectedBillReceived attribute was last
     * updated.
     */
    public static final int ATTR_PROJECTEDBILLTIMESTAMPRECEIVED = 0x0A13;
    /**
     * An 8-bit BitMap used to determine where the decimal point is located in the
     * BillToDateReceived and ProjectedBillReceived attributes. The most significant
     * nibble indicates the number of digits to the right of the decimal point. The least
     * significant nibble is reserved and shall be 0. The BillReceivedTrailingDigit
     * attribute represents the current active value
     */
    public static final int ATTR_BILLRECEIVEDTRAILINGDIGIT = 0x0A14;
    /**
     * The ProposedChangeImplementationTime attribute indicates the time at which a
     * proposed change to the supply is to be implemented. If there is no change of supply
     * pending, this attribute will be set to 0xFFFFFFFF.
     */
    public static final int ATTR_PROPOSEDCHANGESUPPLYIMPLEMENTATIONTIME = 0x0B00;
    /**
     * The ProposedChangeSupplyStatus indicates the proposed status of the supply once the
     * change to the supply has be been implemented.
     */
    public static final int ATTR_PROPOSEDCHANGESUPPLYSTATUS = 0x0B01;
    /**
     * The Uncontrolled Flow Threshold attribute indicates the threshold above which a flow
     * meter (e.g. Gas or Water) shall detect an uncontrolled flow. A value of 0x0000 indicates
     * the feature in unused.
     */
    public static final int ATTR_UNCONTROLLEDFLOWTHRESHOLD = 0x0B10;
    /**
     * The Uncontrolled Flow Threshold Unit of Measure attribute indicates the unit of
     * measure used in conjunction with the Uncontrolled Flow Threshold attribute.
     */
    public static final int ATTR_UNCONTROLLEDFLOWTHRESHOLDUNITOFMEASURE = 0x0B11;
    /**
     * The Uncontrolled Flow Multiplier attribute indicates the multiplier, to be used in
     * conjunction with the Uncontrolled Flow Threshold and Uncontrolled Flow Divisor
     * attributes, to determine the true flow threshold value. A value of 0x0000 is not
     * allowed.
     */
    public static final int ATTR_UNCONTROLLEDFLOWTHRESHOLDMULTIPLIER = 0x0B12;
    /**
     * The Uncontrolled Flow Divisor attribute indicates the divisor, to be used in
     * conjunction with the Uncontrolled Flow Threshold and Uncontrolled Flow Multiplier
     * attributes, to determine the true flow threshold value. A value of 0x0000 is not
     * allowed.
     */
    public static final int ATTR_UNCONTROLLEDFLOWTHRESHOLDDIVISOR = 0x0B13;
    /**
     * The Flow Stabilisation Period attribute indicates the time given to allow the flow to
     * stabilize. It is defined in units of tenths of a second.
     */
    public static final int ATTR_FLOWSTABILIZATIONPERIOD = 0x0B14;
    /**
     * The Flow Measurement Period attribute indicates the period over which the flow is
     * measured and compared against the Uncontrolled Flow Threshold attribute. It is
     * defined in units of 1 second.
     */
    public static final int ATTR_FLOWMEASUREMENTPERIOD = 0x0B15;
    /**
     * AlternativeInstantaneousDemand represents the current Demand delivered or
     * received at the premises. Positive values indicate demand delivered to the premises
     * where negative values indicate demand received from the premises.
     * AlternativeInstantaneousDemand is updated continuously as new measurements are
     * made. The frequency of updates to this field is specific to the metering device, but
     * should be within the range of once every second to once every 5 seconds.
     */
    public static final int ATTR_ALTERNATIVEINSTANTANEOUSDEMAND = 0x0C00;
    /**
     * CurrentDayAlternativeConsumptionDelivered represents the summed value delivered
     * to the premises since the Historical Freeze Time (HFT). If optionally provided,
     * CurrentDayAlternativeConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     */
    public static final int ATTR_CURRENTDAYALTERNATIVECONSUMPTIONDELIVERED = 0x0C01;
    /**
     * CurrentDayAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT). If optionally provided,
     * CurrentDayAlternativeConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     */
    public static final int ATTR_CURRENTDAYALTERNATIVECONSUMPTIONRECEIVED = 0x0C02;
    /**
     * PreviousDayAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the
     * Alternative Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayAlternativeConsumptionDelivered is updated every HFT. If the optional
     * HFT attribute is not available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONDELIVERED = 0x0C03;
    /**
     * PreviousDayAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If optionally provided, PreviousDayAlternativeConsumptionReceived is
     * updated every HFT. If the optional HFT attribute is not available, default to midnight
     * local time.
     */
    public static final int ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONRECEIVED = 0x0C04;
    /**
     * CurrentAlternativePartialProfileIntervalStartTimeDelivered represents the
     * start time of the current Load Profile interval being accumulated for commodity
     * delivered.
     */
    public static final int ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMEDELIVERED = 0x0C05;
    /**
     * CurrentAlternativePartialProfileIntervalStartTimeReceived represents the
     * start time of the current Load Profile interval being accumulated for commodity
     * received.
     */
    public static final int ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMERECEIVED = 0x0C06;
    /**
     * CurrentAlternativePartialProfileIntervalValueDelivered represents the value of
     * the current Load Profile interval being accumulated for commodity delivered.
     */
    public static final int ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUEDELIVERED = 0x0C07;
    /**
     * CurrentAlternativePartialProfileIntervalValueReceived represents the value of
     * the current Load Profile interval being accumulated for commodity received.
     */
    public static final int ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUERECEIVED = 0x0C08;
    /**
     * CurrentDayAlternativeMaxPressure is the maximum pressure reported during a day from
     * the water or gas meter.
     */
    public static final int ATTR_CURRENTDAYALTERNATIVEMAXPRESSURE = 0x0C09;
    /**
     * CurrentDayAlternativeMinPressure is the minimum pressure reported during a day from
     * the water or gas meter.
     */
    public static final int ATTR_CURRENTDAYALTERNATIVEMINPRESSURE = 0x0C0A;
    /**
     * PreviousDayAlternativeMaxPressure represents the maximum pressure reported
     * during previous day from the water or gas meter.
     */
    public static final int ATTR_PREVIOUSDAYALTERNATIVEMAXPRESSURE = 0x0C0B;
    /**
     * PreviousDayAlternativeMinPressure represents the minimum pressure reported
     * during previous day from the water or gas meter.
     */
    public static final int ATTR_PREVIOUSDAYALTERNATIVEMINPRESSURE = 0x0C0C;
    /**
     * CurrentDayAlternativeMaxDemand represents the maximum demand or rate of delivered
     * value of Energy, Gas, or Water being utilized at the premises.
     */
    public static final int ATTR_CURRENTDAYALTERNATIVEMAXDEMAND = 0x0C0D;
    /**
     * PreviousDayAlternativeMaxDemand represents the maximum demand or rate of delivered
     * value of Energy, Gas, or Water being utilized at the premises.
     */
    public static final int ATTR_PREVIOUSDAYALTERNATIVEMAXDEMAND = 0x0C0E;
    /**
     * CurrentMonthAlternativeMaxDemand is the maximum demand reported during a month from
     * the meter.
     */
    public static final int ATTR_CURRENTMONTHALTERNATIVEMAXDEMAND = 0x0C0F;
    /**
     * CurrentYearAlternativeMaxDemand is the maximum demand reported during a year from
     * the meter.
     */
    public static final int ATTR_CURRENTYEARALTERNATIVEMAXDEMAND = 0x0C10;
    /**
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     */
    public static final int ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONDELIVERED = 0x0C22;
    /**
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     */
    public static final int ATTR_PREVIOUSDAY4ALTERNATIVECONSUMPTIONDELIVERED = 0x0C24;
    /**
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     */
    public static final int ATTR_PREVIOUSDAY6ALTERNATIVECONSUMPTIONDELIVERED = 0x0C26;
    /**
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     */
    public static final int ATTR_PREVIOUSDAY8ALTERNATIVECONSUMPTIONDELIVERED = 0x0C28;
    /**
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     */
    public static final int ATTR_PREVIOUSDAY10ALTERNATIVECONSUMPTIONDELIVERED = 0x0C2A;
    /**
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     */
    public static final int ATTR_PREVIOUSDAY12ALTERNATIVECONSUMPTIONDELIVERED = 0x0C2C;
    /**
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     */
    public static final int ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONRECEIVED = 0x0C23;
    /**
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     */
    public static final int ATTR_PREVIOUSDAY4ALTERNATIVECONSUMPTIONRECEIVED = 0x0C25;
    /**
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     */
    public static final int ATTR_PREVIOUSDAY6ALTERNATIVECONSUMPTIONRECEIVED = 0x0C27;
    /**
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     */
    public static final int ATTR_PREVIOUSDAY8ALTERNATIVECONSUMPTIONRECEIVED = 0x0C29;
    /**
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     */
    public static final int ATTR_PREVIOUSDAY10ALTERNATIVECONSUMPTIONRECEIVED = 0x0C2B;
    /**
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     */
    public static final int ATTR_PREVIOUSDAY12ALTERNATIVECONSUMPTIONRECEIVED = 0x0C2D;
    /**
     * CurrentWeekAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises since the Historical Freeze Time (HFT) on Monday to the last
     * HFT read. If optionally provided, CurrentWeekAlternativeConsumptionDelivered is
     * updated continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONDELIVERED = 0x0C30;
    /**
     * CurrentWeekAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT) on Monday to the last HFT read.
     * If optionally provided, CurrentWeekAlternativeConsumptionReceived is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONRECEIVED = 0x0C31;
    /**
     * PreviousWeekNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONDELIVERED = 0x0C33;
    /**
     * PreviousWeekNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK3ALTERNATIVECONSUMPTIONDELIVERED = 0x0C35;
    /**
     * PreviousWeekNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK5ALTERNATIVECONSUMPTIONDELIVERED = 0x0C37;
    /**
     * PreviousWeekNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK7ALTERNATIVECONSUMPTIONDELIVERED = 0x0C39;
    /**
     * PreviousWeekNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK9ALTERNATIVECONSUMPTIONDELIVERED = 0x0C3B;
    /**
     * PreviousWeekNAlternativeConsumptionReceived represents the summed value
     * received from the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONRECEIVED = 0x0C34;
    /**
     * PreviousWeekNAlternativeConsumptionReceived represents the summed value
     * received from the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK3ALTERNATIVECONSUMPTIONRECEIVED = 0x0C36;
    /**
     * PreviousWeekNAlternativeConsumptionReceived represents the summed value
     * received from the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK5ALTERNATIVECONSUMPTIONRECEIVED = 0x0C38;
    /**
     * PreviousWeekNAlternativeConsumptionReceived represents the summed value
     * received from the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK7ALTERNATIVECONSUMPTIONRECEIVED = 0x0C3A;
    /**
     * PreviousWeekNAlternativeConsumptionReceived represents the summed value
     * received from the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     */
    public static final int ATTR_PREVIOUSWEEK9ALTERNATIVECONSUMPTIONRECEIVED = 0x0C3C;
    /**
     * CurrentMonthAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises since the Historical Freeze Time (HFT) on the 1st of the month
     * to the last HFT read. If optionally provided,
     * CurrentMonthAlternativeConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     */
    public static final int ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONDELIVERED = 0x0C40;
    /**
     * CurrentMonthAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT) on the 1st of the month to the
     * last HFT read. If optionally provided,
     * CurrentMonthAlternativeConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     */
    public static final int ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONRECEIVED = 0x0C41;
    public static final int ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONDELIVERED = 0x0C43;
    public static final int ATTR_PREVIOUSMONTH3ALTERNATIVECONSUMPTIONDELIVERED = 0x0C45;
    public static final int ATTR_PREVIOUSMONTH5ALTERNATIVECONSUMPTIONDELIVERED = 0x0C47;
    public static final int ATTR_PREVIOUSMONTH7ALTERNATIVECONSUMPTIONDELIVERED = 0x0C49;
    public static final int ATTR_PREVIOUSMONTH9ALTERNATIVECONSUMPTIONDELIVERED = 0x0C4B;
    public static final int ATTR_PREVIOUSMONTH11ALTERNATIVECONSUMPTIONDELIVERED = 0x0C4D;
    public static final int ATTR_PREVIOUSMONTH13ALTERNATIVECONSUMPTIONDELIVERED = 0x0C4F;
    public static final int ATTR_PREVIOUSMONTH15ALTERNATIVECONSUMPTIONDELIVERED = 0x0C51;
    public static final int ATTR_PREVIOUSMONTH17ALTERNATIVECONSUMPTIONDELIVERED = 0x0C53;
    public static final int ATTR_PREVIOUSMONTH19ALTERNATIVECONSUMPTIONDELIVERED = 0x0C55;
    public static final int ATTR_PREVIOUSMONTH21ALTERNATIVECONSUMPTIONDELIVERED = 0x0C57;
    public static final int ATTR_PREVIOUSMONTH23ALTERNATIVECONSUMPTIONDELIVERED = 0x0C59;
    public static final int ATTR_PREVIOUSMONTH25ALTERNATIVECONSUMPTIONDELIVERED = 0x0C5B;
    public static final int ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONRECEIVED = 0x0C44;
    public static final int ATTR_PREVIOUSMONTH3ALTERNATIVECONSUMPTIONRECEIVED = 0x0C46;
    public static final int ATTR_PREVIOUSMONTH5ALTERNATIVECONSUMPTIONRECEIVED = 0x0C48;
    public static final int ATTR_PREVIOUSMONTH7ALTERNATIVECONSUMPTIONRECEIVED = 0x0C4A;
    public static final int ATTR_PREVIOUSMONTH9ALTERNATIVECONSUMPTIONRECEIVED = 0x0C4C;
    public static final int ATTR_PREVIOUSMONTH11ALTERNATIVECONSUMPTIONRECEIVED = 0x0C4E;
    public static final int ATTR_PREVIOUSMONTH13ALTERNATIVECONSUMPTIONRECEIVED = 0x0C50;
    public static final int ATTR_PREVIOUSMONTH15ALTERNATIVECONSUMPTIONRECEIVED = 0x0C52;
    public static final int ATTR_PREVIOUSMONTH17ALTERNATIVECONSUMPTIONRECEIVED = 0x0C54;
    public static final int ATTR_PREVIOUSMONTH19ALTERNATIVECONSUMPTIONRECEIVED = 0x0C56;
    public static final int ATTR_PREVIOUSMONTH21ALTERNATIVECONSUMPTIONRECEIVED = 0x0C58;
    public static final int ATTR_PREVIOUSMONTH23ALTERNATIVECONSUMPTIONRECEIVED = 0x0C5A;
    public static final int ATTR_PREVIOUSMONTH25ALTERNATIVECONSUMPTIONRECEIVED = 0x0C5C;

    @Override
    protected Map<Integer, ZclAttribute> initializeAttributes() {
        Map<Integer, ZclAttribute> attributeMap = new ConcurrentHashMap<>(198);

        attributeMap.put(ATTR_CURRENTSUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTSUMMATIONDELIVERED, "Current Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTSUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTSUMMATIONRECEIVED, "Current Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTMAXDEMANDDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMAXDEMANDDELIVERED, "Current Max Demand Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTMAXDEMANDRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMAXDEMANDRECEIVED, "Current Max Demand Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_DFTSUMMATION, new ZclAttribute(ZclClusterType.METERING, ATTR_DFTSUMMATION, "Dft Summation", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_DAILYFREEZETIME, new ZclAttribute(ZclClusterType.METERING, ATTR_DAILYFREEZETIME, "Daily Freeze Time", ZclDataType.UNSIGNED_16_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_POWERFACTOR, new ZclAttribute(ZclClusterType.METERING, ATTR_POWERFACTOR, "Power Factor", ZclDataType.SIGNED_8_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_READINGSNAPSHOTTIME, new ZclAttribute(ZclClusterType.METERING, ATTR_READINGSNAPSHOTTIME, "Reading Snapshot Time", ZclDataType.UTCTIME, true, true, true, false));
        attributeMap.put(ATTR_CURRENTMAXDEMANDDELIVEREDTIME, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMAXDEMANDDELIVEREDTIME, "Current Max Demand Delivered Time", ZclDataType.UTCTIME, true, true, true, false));
        attributeMap.put(ATTR_CURRENTMAXDEMANDRECEIVEDTIME, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMAXDEMANDRECEIVEDTIME, "Current Max Demand Received Time", ZclDataType.UTCTIME, true, true, true, false));
        attributeMap.put(ATTR_DEFAULTUPDATEPERIOD, new ZclAttribute(ZclClusterType.METERING, ATTR_DEFAULTUPDATEPERIOD, "Default Update Period", ZclDataType.UNSIGNED_8_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_FASTPOLLUPDATEPERIOD, new ZclAttribute(ZclClusterType.METERING, ATTR_FASTPOLLUPDATEPERIOD, "Fast Poll Update Period", ZclDataType.UNSIGNED_8_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTBLOCKPERIODCONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTBLOCKPERIODCONSUMPTIONDELIVERED, "Current Block Period Consumption Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_DAILYCONSUMPTIONTARGET, new ZclAttribute(ZclClusterType.METERING, ATTR_DAILYCONSUMPTIONTARGET, "Daily Consumption Target", ZclDataType.UNSIGNED_24_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTBLOCK, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTBLOCK, "Current Block", ZclDataType.ENUMERATION_8_BIT, false, true, false, false));
        attributeMap.put(ATTR_PROFILEINTERVALPERIOD, new ZclAttribute(ZclClusterType.METERING, ATTR_PROFILEINTERVALPERIOD, "Profile Interval Period", ZclDataType.ENUMERATION_8_BIT, false, true, false, false));
        attributeMap.put(ATTR_INTERVALREADREPORTINGPERIOD, new ZclAttribute(ZclClusterType.METERING, ATTR_INTERVALREADREPORTINGPERIOD, "Interval Read Reporting Period", ZclDataType.UNSIGNED_16_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_PRESETREADINGTIME, new ZclAttribute(ZclClusterType.METERING, ATTR_PRESETREADINGTIME, "Preset Reading Time", ZclDataType.UNSIGNED_16_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_VOLUMEPERREPORT, new ZclAttribute(ZclClusterType.METERING, ATTR_VOLUMEPERREPORT, "Volume Per Report", ZclDataType.UNSIGNED_16_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_FLOWRESTRICTION, new ZclAttribute(ZclClusterType.METERING, ATTR_FLOWRESTRICTION, "Flow Restriction", ZclDataType.UNSIGNED_8_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_SUPPLYSTATUS, new ZclAttribute(ZclClusterType.METERING, ATTR_SUPPLYSTATUS, "Supply Status", ZclDataType.ENUMERATION_8_BIT, false, true, false, false));
        attributeMap.put(ATTR_CURRENTINLETENERGYCARRIERSUMMATION, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTINLETENERGYCARRIERSUMMATION, "Current Inlet Energy Carrier Summation", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTOUTLETENERGYCARRIERSUMMATION, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTOUTLETENERGYCARRIERSUMMATION, "Current Outlet Energy Carrier Summation", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_INLETTEMPERATURE, new ZclAttribute(ZclClusterType.METERING, ATTR_INLETTEMPERATURE, "Inlet Temperature", ZclDataType.SIGNED_24_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_OUTLETTEMPERATURE, new ZclAttribute(ZclClusterType.METERING, ATTR_OUTLETTEMPERATURE, "Outlet Temperature", ZclDataType.SIGNED_24_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CONTROLTEMPERATURE, new ZclAttribute(ZclClusterType.METERING, ATTR_CONTROLTEMPERATURE, "Control Temperature", ZclDataType.SIGNED_24_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTINLETENERGYCARRIERDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTINLETENERGYCARRIERDEMAND, "Current Inlet Energy Carrier Demand", ZclDataType.SIGNED_24_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTOUTLETENERGYCARRIERDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTOUTLETENERGYCARRIERDEMAND, "Current Outlet Energy Carrier Demand", ZclDataType.SIGNED_24_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_PREVIOUSBLOCKPERIODCONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSBLOCKPERIODCONSUMPTIONDELIVERED, "Previous Block Period Consumption Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTBLOCKPERIODCONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTBLOCKPERIODCONSUMPTIONRECEIVED, "Current Block Period Consumption Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_CURRENTBLOCKRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTBLOCKRECEIVED, "Current Block Received", ZclDataType.ENUMERATION_8_BIT, false, true, false, false));
        attributeMap.put(ATTR_DFTSUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_DFTSUMMATIONRECEIVED, "Dft Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, false, true, false, false));
        attributeMap.put(ATTR_ACTIVEREGISTERTIERDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_ACTIVEREGISTERTIERDELIVERED, "Active Register Tier Delivered", ZclDataType.ENUMERATION_8_BIT, false, true, false, false));
        attributeMap.put(ATTR_ACTIVEREGISTERTIERRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_ACTIVEREGISTERTIERRECEIVED, "Active Register Tier Received", ZclDataType.ENUMERATION_8_BIT, false, true, false, false));
        attributeMap.put(ATTR_LASTBLOCKSWITCHTIME, new ZclAttribute(ZclClusterType.METERING, ATTR_LASTBLOCKSWITCHTIME, "Last Block Switch Time", ZclDataType.UTCTIME, false, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1SUMMATIONDELIVERED, "Current Tier 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3SUMMATIONDELIVERED, "Current Tier 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5SUMMATIONDELIVERED, "Current Tier 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7SUMMATIONDELIVERED, "Current Tier 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9SUMMATIONDELIVERED, "Current Tier 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11SUMMATIONDELIVERED, "Current Tier 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13SUMMATIONDELIVERED, "Current Tier 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15SUMMATIONDELIVERED, "Current Tier 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER17SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER17SUMMATIONDELIVERED, "Current Tier 17 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER19SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER19SUMMATIONDELIVERED, "Current Tier 19 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER21SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER21SUMMATIONDELIVERED, "Current Tier 21 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER23SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER23SUMMATIONDELIVERED, "Current Tier 23 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER25SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER25SUMMATIONDELIVERED, "Current Tier 25 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER27SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER27SUMMATIONDELIVERED, "Current Tier 27 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER29SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER29SUMMATIONDELIVERED, "Current Tier 29 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER31SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER31SUMMATIONDELIVERED, "Current Tier 31 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER33SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER33SUMMATIONDELIVERED, "Current Tier 33 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER35SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER35SUMMATIONDELIVERED, "Current Tier 35 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER37SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER37SUMMATIONDELIVERED, "Current Tier 37 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER39SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER39SUMMATIONDELIVERED, "Current Tier 39 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER41SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER41SUMMATIONDELIVERED, "Current Tier 41 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER43SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER43SUMMATIONDELIVERED, "Current Tier 43 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER45SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER45SUMMATIONDELIVERED, "Current Tier 45 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER47SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER47SUMMATIONDELIVERED, "Current Tier 47 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER49SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER49SUMMATIONDELIVERED, "Current Tier 49 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER51SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER51SUMMATIONDELIVERED, "Current Tier 51 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER53SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER53SUMMATIONDELIVERED, "Current Tier 53 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER55SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER55SUMMATIONDELIVERED, "Current Tier 55 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER57SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER57SUMMATIONDELIVERED, "Current Tier 57 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER59SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER59SUMMATIONDELIVERED, "Current Tier 59 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER61SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER61SUMMATIONDELIVERED, "Current Tier 61 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER63SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER63SUMMATIONDELIVERED, "Current Tier 63 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER65SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER65SUMMATIONDELIVERED, "Current Tier 65 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER67SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER67SUMMATIONDELIVERED, "Current Tier 67 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER69SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER69SUMMATIONDELIVERED, "Current Tier 69 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER71SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER71SUMMATIONDELIVERED, "Current Tier 71 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER73SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER73SUMMATIONDELIVERED, "Current Tier 73 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER75SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER75SUMMATIONDELIVERED, "Current Tier 75 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER77SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER77SUMMATIONDELIVERED, "Current Tier 77 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER79SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER79SUMMATIONDELIVERED, "Current Tier 79 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER81SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER81SUMMATIONDELIVERED, "Current Tier 81 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER83SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER83SUMMATIONDELIVERED, "Current Tier 83 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER85SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER85SUMMATIONDELIVERED, "Current Tier 85 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER87SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER87SUMMATIONDELIVERED, "Current Tier 87 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER89SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER89SUMMATIONDELIVERED, "Current Tier 89 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER91SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER91SUMMATIONDELIVERED, "Current Tier 91 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER93SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER93SUMMATIONDELIVERED, "Current Tier 93 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER95SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER95SUMMATIONDELIVERED, "Current Tier 95 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1SUMMATIONRECEIVED, "Current Tier 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3SUMMATIONRECEIVED, "Current Tier 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5SUMMATIONRECEIVED, "Current Tier 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7SUMMATIONRECEIVED, "Current Tier 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9SUMMATIONRECEIVED, "Current Tier 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11SUMMATIONRECEIVED, "Current Tier 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13SUMMATIONRECEIVED, "Current Tier 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15SUMMATIONRECEIVED, "Current Tier 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER17SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER17SUMMATIONRECEIVED, "Current Tier 17 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER19SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER19SUMMATIONRECEIVED, "Current Tier 19 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER21SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER21SUMMATIONRECEIVED, "Current Tier 21 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER23SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER23SUMMATIONRECEIVED, "Current Tier 23 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER25SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER25SUMMATIONRECEIVED, "Current Tier 25 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER27SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER27SUMMATIONRECEIVED, "Current Tier 27 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER29SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER29SUMMATIONRECEIVED, "Current Tier 29 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER31SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER31SUMMATIONRECEIVED, "Current Tier 31 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER33SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER33SUMMATIONRECEIVED, "Current Tier 33 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER35SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER35SUMMATIONRECEIVED, "Current Tier 35 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER37SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER37SUMMATIONRECEIVED, "Current Tier 37 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER39SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER39SUMMATIONRECEIVED, "Current Tier 39 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER41SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER41SUMMATIONRECEIVED, "Current Tier 41 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER43SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER43SUMMATIONRECEIVED, "Current Tier 43 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER45SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER45SUMMATIONRECEIVED, "Current Tier 45 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER47SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER47SUMMATIONRECEIVED, "Current Tier 47 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER49SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER49SUMMATIONRECEIVED, "Current Tier 49 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER51SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER51SUMMATIONRECEIVED, "Current Tier 51 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER53SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER53SUMMATIONRECEIVED, "Current Tier 53 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER55SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER55SUMMATIONRECEIVED, "Current Tier 55 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER57SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER57SUMMATIONRECEIVED, "Current Tier 57 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER59SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER59SUMMATIONRECEIVED, "Current Tier 59 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER61SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER61SUMMATIONRECEIVED, "Current Tier 61 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER63SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER63SUMMATIONRECEIVED, "Current Tier 63 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER65SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER65SUMMATIONRECEIVED, "Current Tier 65 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER67SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER67SUMMATIONRECEIVED, "Current Tier 67 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER69SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER69SUMMATIONRECEIVED, "Current Tier 69 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER71SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER71SUMMATIONRECEIVED, "Current Tier 71 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER73SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER73SUMMATIONRECEIVED, "Current Tier 73 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER75SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER75SUMMATIONRECEIVED, "Current Tier 75 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER77SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER77SUMMATIONRECEIVED, "Current Tier 77 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER79SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER79SUMMATIONRECEIVED, "Current Tier 79 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER81SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER81SUMMATIONRECEIVED, "Current Tier 81 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER83SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER83SUMMATIONRECEIVED, "Current Tier 83 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER85SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER85SUMMATIONRECEIVED, "Current Tier 85 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER87SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER87SUMMATIONRECEIVED, "Current Tier 87 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER89SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER89SUMMATIONRECEIVED, "Current Tier 89 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER91SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER91SUMMATIONRECEIVED, "Current Tier 91 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER93SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER93SUMMATIONRECEIVED, "Current Tier 93 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER95SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER95SUMMATIONRECEIVED, "Current Tier 95 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CPP1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CPP1SUMMATIONDELIVERED, "CPP 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CPP2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CPP2SUMMATIONDELIVERED, "CPP 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_STATUS, new ZclAttribute(ZclClusterType.METERING, ATTR_STATUS, "Status", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_REMAININGBATTERYLIFE, new ZclAttribute(ZclClusterType.METERING, ATTR_REMAININGBATTERYLIFE, "Remaining Battery Life", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_HOURSINOPERATION, new ZclAttribute(ZclClusterType.METERING, ATTR_HOURSINOPERATION, "Hours In Operation", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_HOURSINFAULT, new ZclAttribute(ZclClusterType.METERING, ATTR_HOURSINFAULT, "Hours In Fault", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_EXTENDEDSTATUS, new ZclAttribute(ZclClusterType.METERING, ATTR_EXTENDEDSTATUS, "Extended Status", ZclDataType.BITMAP_64_BIT, true, true, false, false));
        attributeMap.put(ATTR_REMAININGBATTERYLIFEINDAYS, new ZclAttribute(ZclClusterType.METERING, ATTR_REMAININGBATTERYLIFEINDAYS, "Remaining Battery Life In Days", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMETERID, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMETERID, "Current Meter ID", ZclDataType.OCTET_STRING, true, true, false, false));
        attributeMap.put(ATTR_AMBIENTCONSUMPTIONINDICATOR, new ZclAttribute(ZclClusterType.METERING, ATTR_AMBIENTCONSUMPTIONINDICATOR, "Ambient Consumption Indicator", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_UNITOFMEASURE, new ZclAttribute(ZclClusterType.METERING, ATTR_UNITOFMEASURE, "Unit Of Measure", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_MULTIPLIER, new ZclAttribute(ZclClusterType.METERING, ATTR_MULTIPLIER, "Multiplier", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_DIVISOR, new ZclAttribute(ZclClusterType.METERING, ATTR_DIVISOR, "Divisor", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_SUMMATIONFORMATTING, new ZclAttribute(ZclClusterType.METERING, ATTR_SUMMATIONFORMATTING, "Summation Formatting", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_DEMANDFORMATTING, new ZclAttribute(ZclClusterType.METERING, ATTR_DEMANDFORMATTING, "Demand Formatting", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_HISTORICALCONSUMPTIONFORMATTING, new ZclAttribute(ZclClusterType.METERING, ATTR_HISTORICALCONSUMPTIONFORMATTING, "Historical Consumption Formatting", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_METERINGDEVICETYPE, new ZclAttribute(ZclClusterType.METERING, ATTR_METERINGDEVICETYPE, "Metering Device Type", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_SITEID, new ZclAttribute(ZclClusterType.METERING, ATTR_SITEID, "Site ID", ZclDataType.OCTET_STRING, true, true, false, false));
        attributeMap.put(ATTR_METERSERIALNUMBER, new ZclAttribute(ZclClusterType.METERING, ATTR_METERSERIALNUMBER, "Meter Serial Number", ZclDataType.OCTET_STRING, true, true, false, false));
        attributeMap.put(ATTR_ENERGYCARRIERUNITOFMEASURE, new ZclAttribute(ZclClusterType.METERING, ATTR_ENERGYCARRIERUNITOFMEASURE, "Energy Carrier Unit Of Measure", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_ENERGYCARRIERSUMMATIONFORMATTING, new ZclAttribute(ZclClusterType.METERING, ATTR_ENERGYCARRIERSUMMATIONFORMATTING, "Energy Carrier Summation Formatting", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_ENERGYCARRIERDEMANDFORMATTING, new ZclAttribute(ZclClusterType.METERING, ATTR_ENERGYCARRIERDEMANDFORMATTING, "Energy Carrier Demand Formatting", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_TEMPERATUREUNITOFMEASURE, new ZclAttribute(ZclClusterType.METERING, ATTR_TEMPERATUREUNITOFMEASURE, "Temperature Unit Of Measure", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_TEMPERATUREFORMATTING, new ZclAttribute(ZclClusterType.METERING, ATTR_TEMPERATUREFORMATTING, "Temperature Formatting", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_MODULESERIALNUMBER, new ZclAttribute(ZclClusterType.METERING, ATTR_MODULESERIALNUMBER, "Module Serial Number", ZclDataType.OCTET_STRING, true, true, false, false));
        attributeMap.put(ATTR_OPERATINGTARIFFLABELDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_OPERATINGTARIFFLABELDELIVERED, "Operating Tariff Label Delivered", ZclDataType.OCTET_STRING, true, true, false, false));
        attributeMap.put(ATTR_OPERATINGTARIFFLABELRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_OPERATINGTARIFFLABELRECEIVED, "Operating Tariff Label Received", ZclDataType.OCTET_STRING, true, true, false, false));
        attributeMap.put(ATTR_CUSTOMERIDNUMBER, new ZclAttribute(ZclClusterType.METERING, ATTR_CUSTOMERIDNUMBER, "Customer ID Number", ZclDataType.OCTET_STRING, true, true, false, false));
        attributeMap.put(ATTR_ALTERNATIVEUNITOFMEASURE, new ZclAttribute(ZclClusterType.METERING, ATTR_ALTERNATIVEUNITOFMEASURE, "Alternative Unit Of Measure", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_ALTERNATIVEDEMANDFORMATTING, new ZclAttribute(ZclClusterType.METERING, ATTR_ALTERNATIVEDEMANDFORMATTING, "Alternative Demand Formatting", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_ALTERNATIVECONSUMPTIONFORMATTING, new ZclAttribute(ZclClusterType.METERING, ATTR_ALTERNATIVECONSUMPTIONFORMATTING, "Alternative Consumption Formatting", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_INSTANTANEOUSDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_INSTANTANEOUSDEMAND, "Instantaneous Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYCONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYCONSUMPTIONDELIVERED, "Current Day Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYCONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYCONSUMPTIONRECEIVED, "Current Day Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYCONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYCONSUMPTIONDELIVERED, "Previous Day Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYCONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYCONSUMPTIONRECEIVED, "Previous Day Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMEDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMEDELIVERED, "Current Partial Profile Interval Start Time Delivered", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMERECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMERECEIVED, "Current Partial Profile Interval Start Time Received", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_CURRENTPARTIALPROFILEINTERVALVALUEDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTPARTIALPROFILEINTERVALVALUEDELIVERED, "Current Partial Profile Interval Value Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTPARTIALPROFILEINTERVALVALUERECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTPARTIALPROFILEINTERVALVALUERECEIVED, "Current Partial Profile Interval Value Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYMAXPRESSURE, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYMAXPRESSURE, "Current Day Max Pressure", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYMINPRESSURE, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYMINPRESSURE, "Current Day Min Pressure", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYMAXPRESSURE, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYMAXPRESSURE, "Previous Day Max Pressure", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYMINPRESSURE, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYMINPRESSURE, "Previous Day Min Pressure", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYMAXDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYMAXDEMAND, "Current Day Max Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYMAXDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYMAXDEMAND, "Previous Day Max Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMONTHMAXDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMONTHMAXDEMAND, "Current Month Max Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTYEARMAXDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTYEARMAXDEMAND, "Current Year Max Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYMAXENERGYCARRIERDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYMAXENERGYCARRIERDEMAND, "Current Day Max Energy Carrier Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYMAXENERGYCARRIERDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYMAXENERGYCARRIERDEMAND, "Previous Day Max Energy Carrier Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMONTHMAXENERGYCARRIERDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMONTHMAXENERGYCARRIERDEMAND, "Current Month Max Energy Carrier Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMONTHMINENERGYCARRIERDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMONTHMINENERGYCARRIERDEMAND, "Current Month Min Energy Carrier Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTYEARMAXENERGYCARRIERDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTYEARMAXENERGYCARRIERDEMAND, "Current Year Max Energy Carrier Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTYEARMINENERGYCARRIERDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTYEARMINENERGYCARRIERDEMAND, "Current Year Min Energy Carrier Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY2CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY2CONSUMPTIONDELIVERED, "Previous Day 2 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY4CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY4CONSUMPTIONDELIVERED, "Previous Day 4 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY6CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY6CONSUMPTIONDELIVERED, "Previous Day 6 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY8CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY8CONSUMPTIONDELIVERED, "Previous Day 8 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY10CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY10CONSUMPTIONDELIVERED, "Previous Day 10 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY12CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY12CONSUMPTIONDELIVERED, "Previous Day 12 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY14CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY14CONSUMPTIONDELIVERED, "Previous Day 14 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY16CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY16CONSUMPTIONDELIVERED, "Previous Day 16 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY2CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY2CONSUMPTIONRECEIVED, "Previous Day 2 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY4CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY4CONSUMPTIONRECEIVED, "Previous Day 4 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY6CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY6CONSUMPTIONRECEIVED, "Previous Day 6 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY8CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY8CONSUMPTIONRECEIVED, "Previous Day 8 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY10CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY10CONSUMPTIONRECEIVED, "Previous Day 10 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY12CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY12CONSUMPTIONRECEIVED, "Previous Day 12 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY14CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY14CONSUMPTIONRECEIVED, "Previous Day 14 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY16CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY16CONSUMPTIONRECEIVED, "Previous Day 16 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTWEEKCONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTWEEKCONSUMPTIONDELIVERED, "Current Week Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTWEEKCONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTWEEKCONSUMPTIONRECEIVED, "Current Week Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK1CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK1CONSUMPTIONDELIVERED, "Previous Week 1 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK3CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK3CONSUMPTIONDELIVERED, "Previous Week 3 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK5CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK5CONSUMPTIONDELIVERED, "Previous Week 5 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK7CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK7CONSUMPTIONDELIVERED, "Previous Week 7 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK9CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK9CONSUMPTIONDELIVERED, "Previous Week 9 Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK1CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK1CONSUMPTIONRECEIVED, "Previous Week 1 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK3CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK3CONSUMPTIONRECEIVED, "Previous Week 3 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK5CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK5CONSUMPTIONRECEIVED, "Previous Week 5 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK7CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK7CONSUMPTIONRECEIVED, "Previous Week 7 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK9CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK9CONSUMPTIONRECEIVED, "Previous Week 9 Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMONTHCONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMONTHCONSUMPTIONDELIVERED, "Current Month Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMONTHCONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMONTHCONSUMPTIONRECEIVED, "Current Month Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH1CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH1CONSUMPTIONDELIVERED, "Previous Month 1 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH3CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH3CONSUMPTIONDELIVERED, "Previous Month 3 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH5CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH5CONSUMPTIONDELIVERED, "Previous Month 5 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH7CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH7CONSUMPTIONDELIVERED, "Previous Month 7 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH9CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH9CONSUMPTIONDELIVERED, "Previous Month 9 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH11CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH11CONSUMPTIONDELIVERED, "Previous Month 11 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH13CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH13CONSUMPTIONDELIVERED, "Previous Month 13 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH15CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH15CONSUMPTIONDELIVERED, "Previous Month 15 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH17CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH17CONSUMPTIONDELIVERED, "Previous Month 17 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH19CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH19CONSUMPTIONDELIVERED, "Previous Month 19 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH21CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH21CONSUMPTIONDELIVERED, "Previous Month 21 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH23CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH23CONSUMPTIONDELIVERED, "Previous Month 23 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH25CONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH25CONSUMPTIONDELIVERED, "Previous Month 25 Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH1CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH1CONSUMPTIONRECEIVED, "Previous Month 1 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH3CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH3CONSUMPTIONRECEIVED, "Previous Month 3 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH5CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH5CONSUMPTIONRECEIVED, "Previous Month 5 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH7CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH7CONSUMPTIONRECEIVED, "Previous Month 7 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH9CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH9CONSUMPTIONRECEIVED, "Previous Month 9 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH11CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH11CONSUMPTIONRECEIVED, "Previous Month 11 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH13CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH13CONSUMPTIONRECEIVED, "Previous Month 13 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH15CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH15CONSUMPTIONRECEIVED, "Previous Month 15 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH17CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH17CONSUMPTIONRECEIVED, "Previous Month 17 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH19CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH19CONSUMPTIONRECEIVED, "Previous Month 19 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH21CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH21CONSUMPTIONRECEIVED, "Previous Month 21 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH23CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH23CONSUMPTIONRECEIVED, "Previous Month 23 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH25CONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH25CONSUMPTIONRECEIVED, "Previous Month 25 Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_HISTORICALFREEZETIME, new ZclAttribute(ZclClusterType.METERING, ATTR_HISTORICALFREEZETIME, "Historical Freeze Time", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_MAXNUMBEROFPERIODSDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_MAXNUMBEROFPERIODSDELIVERED, "Max Number Of Periods Delivered", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDEMANDDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDEMANDDELIVERED, "Current Demand Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_DEMANDLIMIT, new ZclAttribute(ZclClusterType.METERING, ATTR_DEMANDLIMIT, "Demand Limit", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_DEMANDINTEGRATIONPERIOD, new ZclAttribute(ZclClusterType.METERING, ATTR_DEMANDINTEGRATIONPERIOD, "Demand Integration Period", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_NUMBEROFDEMANDSUBINTERVALS, new ZclAttribute(ZclClusterType.METERING, ATTR_NUMBEROFDEMANDSUBINTERVALS, "Number Of Demand Subintervals", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_DEMANDLIMITARMDURATION, new ZclAttribute(ZclClusterType.METERING, ATTR_DEMANDLIMITARMDURATION, "Demand Limit Arm Duration", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_LOADLIMITSUPPLYSTATE, new ZclAttribute(ZclClusterType.METERING, ATTR_LOADLIMITSUPPLYSTATE, "Load Limit Supply State", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_LOADLIMITCOUNTER, new ZclAttribute(ZclClusterType.METERING, ATTR_LOADLIMITCOUNTER, "Load Limit Counter", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_SUPPLYTAMPERSTATE, new ZclAttribute(ZclClusterType.METERING, ATTR_SUPPLYTAMPERSTATE, "Supply Tamper State", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_SUPPLYDEPLETIONSTATE, new ZclAttribute(ZclClusterType.METERING, ATTR_SUPPLYDEPLETIONSTATE, "Supply Depletion State", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_SUPPLYUNCONTROLLEDFLOWSTATE, new ZclAttribute(ZclClusterType.METERING, ATTR_SUPPLYUNCONTROLLEDFLOWSTATE, "Supply Uncontrolled Flow State", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK1SUMMATIONDELIVERED, "Current No Tier Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK2SUMMATIONDELIVERED, "Current No Tier Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK3SUMMATIONDELIVERED, "Current No Tier Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK4SUMMATIONDELIVERED, "Current No Tier Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK5SUMMATIONDELIVERED, "Current No Tier Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK6SUMMATIONDELIVERED, "Current No Tier Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK7SUMMATIONDELIVERED, "Current No Tier Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK8SUMMATIONDELIVERED, "Current No Tier Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK9SUMMATIONDELIVERED, "Current No Tier Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK10SUMMATIONDELIVERED, "Current No Tier Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK11SUMMATIONDELIVERED, "Current No Tier Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK12SUMMATIONDELIVERED, "Current No Tier Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK13SUMMATIONDELIVERED, "Current No Tier Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK14SUMMATIONDELIVERED, "Current No Tier Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK15SUMMATIONDELIVERED, "Current No Tier Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK16SUMMATIONDELIVERED, "Current No Tier Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK1SUMMATIONDELIVERED, "Current Tier 1 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK2SUMMATIONDELIVERED, "Current Tier 1 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK3SUMMATIONDELIVERED, "Current Tier 1 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK4SUMMATIONDELIVERED, "Current Tier 1 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK5SUMMATIONDELIVERED, "Current Tier 1 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK6SUMMATIONDELIVERED, "Current Tier 1 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK7SUMMATIONDELIVERED, "Current Tier 1 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK8SUMMATIONDELIVERED, "Current Tier 1 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK9SUMMATIONDELIVERED, "Current Tier 1 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK10SUMMATIONDELIVERED, "Current Tier 1 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK11SUMMATIONDELIVERED, "Current Tier 1 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK12SUMMATIONDELIVERED, "Current Tier 1 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK13SUMMATIONDELIVERED, "Current Tier 1 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK14SUMMATIONDELIVERED, "Current Tier 1 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK15SUMMATIONDELIVERED, "Current Tier 1 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK16SUMMATIONDELIVERED, "Current Tier 1 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK1SUMMATIONDELIVERED, "Current Tier 2 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK2SUMMATIONDELIVERED, "Current Tier 2 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK3SUMMATIONDELIVERED, "Current Tier 2 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK4SUMMATIONDELIVERED, "Current Tier 2 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK5SUMMATIONDELIVERED, "Current Tier 2 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK6SUMMATIONDELIVERED, "Current Tier 2 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK7SUMMATIONDELIVERED, "Current Tier 2 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK8SUMMATIONDELIVERED, "Current Tier 2 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK9SUMMATIONDELIVERED, "Current Tier 2 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK10SUMMATIONDELIVERED, "Current Tier 2 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK11SUMMATIONDELIVERED, "Current Tier 2 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK12SUMMATIONDELIVERED, "Current Tier 2 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK13SUMMATIONDELIVERED, "Current Tier 2 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK14SUMMATIONDELIVERED, "Current Tier 2 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK15SUMMATIONDELIVERED, "Current Tier 2 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK16SUMMATIONDELIVERED, "Current Tier 2 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK1SUMMATIONDELIVERED, "Current Tier 3 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK2SUMMATIONDELIVERED, "Current Tier 3 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK3SUMMATIONDELIVERED, "Current Tier 3 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK4SUMMATIONDELIVERED, "Current Tier 3 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK5SUMMATIONDELIVERED, "Current Tier 3 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK6SUMMATIONDELIVERED, "Current Tier 3 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK7SUMMATIONDELIVERED, "Current Tier 3 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK8SUMMATIONDELIVERED, "Current Tier 3 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK9SUMMATIONDELIVERED, "Current Tier 3 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK10SUMMATIONDELIVERED, "Current Tier 3 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK11SUMMATIONDELIVERED, "Current Tier 3 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK12SUMMATIONDELIVERED, "Current Tier 3 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK13SUMMATIONDELIVERED, "Current Tier 3 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK14SUMMATIONDELIVERED, "Current Tier 3 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK15SUMMATIONDELIVERED, "Current Tier 3 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK16SUMMATIONDELIVERED, "Current Tier 3 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK1SUMMATIONDELIVERED, "Current Tier 4 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK2SUMMATIONDELIVERED, "Current Tier 4 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK3SUMMATIONDELIVERED, "Current Tier 4 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK4SUMMATIONDELIVERED, "Current Tier 4 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK5SUMMATIONDELIVERED, "Current Tier 4 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK6SUMMATIONDELIVERED, "Current Tier 4 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK7SUMMATIONDELIVERED, "Current Tier 4 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK8SUMMATIONDELIVERED, "Current Tier 4 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK9SUMMATIONDELIVERED, "Current Tier 4 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK10SUMMATIONDELIVERED, "Current Tier 4 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK11SUMMATIONDELIVERED, "Current Tier 4 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK12SUMMATIONDELIVERED, "Current Tier 4 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK13SUMMATIONDELIVERED, "Current Tier 4 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK14SUMMATIONDELIVERED, "Current Tier 4 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK15SUMMATIONDELIVERED, "Current Tier 4 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK16SUMMATIONDELIVERED, "Current Tier 4 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK1SUMMATIONDELIVERED, "Current Tier 5 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK2SUMMATIONDELIVERED, "Current Tier 5 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK3SUMMATIONDELIVERED, "Current Tier 5 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK4SUMMATIONDELIVERED, "Current Tier 5 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK5SUMMATIONDELIVERED, "Current Tier 5 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK6SUMMATIONDELIVERED, "Current Tier 5 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK7SUMMATIONDELIVERED, "Current Tier 5 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK8SUMMATIONDELIVERED, "Current Tier 5 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK9SUMMATIONDELIVERED, "Current Tier 5 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK10SUMMATIONDELIVERED, "Current Tier 5 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK11SUMMATIONDELIVERED, "Current Tier 5 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK12SUMMATIONDELIVERED, "Current Tier 5 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK13SUMMATIONDELIVERED, "Current Tier 5 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK14SUMMATIONDELIVERED, "Current Tier 5 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK15SUMMATIONDELIVERED, "Current Tier 5 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK16SUMMATIONDELIVERED, "Current Tier 5 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK1SUMMATIONDELIVERED, "Current Tier 6 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK2SUMMATIONDELIVERED, "Current Tier 6 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK3SUMMATIONDELIVERED, "Current Tier 6 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK4SUMMATIONDELIVERED, "Current Tier 6 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK5SUMMATIONDELIVERED, "Current Tier 6 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK6SUMMATIONDELIVERED, "Current Tier 6 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK7SUMMATIONDELIVERED, "Current Tier 6 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK8SUMMATIONDELIVERED, "Current Tier 6 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK9SUMMATIONDELIVERED, "Current Tier 6 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK10SUMMATIONDELIVERED, "Current Tier 6 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK11SUMMATIONDELIVERED, "Current Tier 6 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK12SUMMATIONDELIVERED, "Current Tier 6 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK13SUMMATIONDELIVERED, "Current Tier 6 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK14SUMMATIONDELIVERED, "Current Tier 6 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK15SUMMATIONDELIVERED, "Current Tier 6 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK16SUMMATIONDELIVERED, "Current Tier 6 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK1SUMMATIONDELIVERED, "Current Tier 7 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK2SUMMATIONDELIVERED, "Current Tier 7 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK3SUMMATIONDELIVERED, "Current Tier 7 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK4SUMMATIONDELIVERED, "Current Tier 7 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK5SUMMATIONDELIVERED, "Current Tier 7 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK6SUMMATIONDELIVERED, "Current Tier 7 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK7SUMMATIONDELIVERED, "Current Tier 7 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK8SUMMATIONDELIVERED, "Current Tier 7 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK9SUMMATIONDELIVERED, "Current Tier 7 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK10SUMMATIONDELIVERED, "Current Tier 7 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK11SUMMATIONDELIVERED, "Current Tier 7 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK12SUMMATIONDELIVERED, "Current Tier 7 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK13SUMMATIONDELIVERED, "Current Tier 7 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK14SUMMATIONDELIVERED, "Current Tier 7 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK15SUMMATIONDELIVERED, "Current Tier 7 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK16SUMMATIONDELIVERED, "Current Tier 7 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK1SUMMATIONDELIVERED, "Current Tier 8 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK2SUMMATIONDELIVERED, "Current Tier 8 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK3SUMMATIONDELIVERED, "Current Tier 8 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK4SUMMATIONDELIVERED, "Current Tier 8 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK5SUMMATIONDELIVERED, "Current Tier 8 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK6SUMMATIONDELIVERED, "Current Tier 8 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK7SUMMATIONDELIVERED, "Current Tier 8 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK8SUMMATIONDELIVERED, "Current Tier 8 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK9SUMMATIONDELIVERED, "Current Tier 8 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK10SUMMATIONDELIVERED, "Current Tier 8 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK11SUMMATIONDELIVERED, "Current Tier 8 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK12SUMMATIONDELIVERED, "Current Tier 8 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK13SUMMATIONDELIVERED, "Current Tier 8 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK14SUMMATIONDELIVERED, "Current Tier 8 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK15SUMMATIONDELIVERED, "Current Tier 8 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK16SUMMATIONDELIVERED, "Current Tier 8 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK1SUMMATIONDELIVERED, "Current Tier 9 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK2SUMMATIONDELIVERED, "Current Tier 9 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK3SUMMATIONDELIVERED, "Current Tier 9 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK4SUMMATIONDELIVERED, "Current Tier 9 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK5SUMMATIONDELIVERED, "Current Tier 9 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK6SUMMATIONDELIVERED, "Current Tier 9 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK7SUMMATIONDELIVERED, "Current Tier 9 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK8SUMMATIONDELIVERED, "Current Tier 9 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK9SUMMATIONDELIVERED, "Current Tier 9 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK10SUMMATIONDELIVERED, "Current Tier 9 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK11SUMMATIONDELIVERED, "Current Tier 9 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK12SUMMATIONDELIVERED, "Current Tier 9 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK13SUMMATIONDELIVERED, "Current Tier 9 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK14SUMMATIONDELIVERED, "Current Tier 9 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK15SUMMATIONDELIVERED, "Current Tier 9 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK16SUMMATIONDELIVERED, "Current Tier 9 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK1SUMMATIONDELIVERED, "Current Tier 10 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK2SUMMATIONDELIVERED, "Current Tier 10 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK3SUMMATIONDELIVERED, "Current Tier 10 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK4SUMMATIONDELIVERED, "Current Tier 10 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK5SUMMATIONDELIVERED, "Current Tier 10 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK6SUMMATIONDELIVERED, "Current Tier 10 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK7SUMMATIONDELIVERED, "Current Tier 10 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK8SUMMATIONDELIVERED, "Current Tier 10 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK9SUMMATIONDELIVERED, "Current Tier 10 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK10SUMMATIONDELIVERED, "Current Tier 10 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK11SUMMATIONDELIVERED, "Current Tier 10 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK12SUMMATIONDELIVERED, "Current Tier 10 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK13SUMMATIONDELIVERED, "Current Tier 10 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK14SUMMATIONDELIVERED, "Current Tier 10 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK15SUMMATIONDELIVERED, "Current Tier 10 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK16SUMMATIONDELIVERED, "Current Tier 10 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK1SUMMATIONDELIVERED, "Current Tier 11 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK2SUMMATIONDELIVERED, "Current Tier 11 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK3SUMMATIONDELIVERED, "Current Tier 11 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK4SUMMATIONDELIVERED, "Current Tier 11 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK5SUMMATIONDELIVERED, "Current Tier 11 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK6SUMMATIONDELIVERED, "Current Tier 11 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK7SUMMATIONDELIVERED, "Current Tier 11 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK8SUMMATIONDELIVERED, "Current Tier 11 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK9SUMMATIONDELIVERED, "Current Tier 11 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK10SUMMATIONDELIVERED, "Current Tier 11 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK11SUMMATIONDELIVERED, "Current Tier 11 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK12SUMMATIONDELIVERED, "Current Tier 11 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK13SUMMATIONDELIVERED, "Current Tier 11 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK14SUMMATIONDELIVERED, "Current Tier 11 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK15SUMMATIONDELIVERED, "Current Tier 11 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK16SUMMATIONDELIVERED, "Current Tier 11 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK1SUMMATIONDELIVERED, "Current Tier 12 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK2SUMMATIONDELIVERED, "Current Tier 12 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK3SUMMATIONDELIVERED, "Current Tier 12 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK4SUMMATIONDELIVERED, "Current Tier 12 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK5SUMMATIONDELIVERED, "Current Tier 12 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK6SUMMATIONDELIVERED, "Current Tier 12 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK7SUMMATIONDELIVERED, "Current Tier 12 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK8SUMMATIONDELIVERED, "Current Tier 12 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK9SUMMATIONDELIVERED, "Current Tier 12 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK10SUMMATIONDELIVERED, "Current Tier 12 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK11SUMMATIONDELIVERED, "Current Tier 12 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK12SUMMATIONDELIVERED, "Current Tier 12 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK13SUMMATIONDELIVERED, "Current Tier 12 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK14SUMMATIONDELIVERED, "Current Tier 12 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK15SUMMATIONDELIVERED, "Current Tier 12 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK16SUMMATIONDELIVERED, "Current Tier 12 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK1SUMMATIONDELIVERED, "Current Tier 13 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK2SUMMATIONDELIVERED, "Current Tier 13 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK3SUMMATIONDELIVERED, "Current Tier 13 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK4SUMMATIONDELIVERED, "Current Tier 13 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK5SUMMATIONDELIVERED, "Current Tier 13 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK6SUMMATIONDELIVERED, "Current Tier 13 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK7SUMMATIONDELIVERED, "Current Tier 13 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK8SUMMATIONDELIVERED, "Current Tier 13 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK9SUMMATIONDELIVERED, "Current Tier 13 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK10SUMMATIONDELIVERED, "Current Tier 13 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK11SUMMATIONDELIVERED, "Current Tier 13 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK12SUMMATIONDELIVERED, "Current Tier 13 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK13SUMMATIONDELIVERED, "Current Tier 13 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK14SUMMATIONDELIVERED, "Current Tier 13 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK15SUMMATIONDELIVERED, "Current Tier 13 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK16SUMMATIONDELIVERED, "Current Tier 13 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK1SUMMATIONDELIVERED, "Current Tier 14 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK2SUMMATIONDELIVERED, "Current Tier 14 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK3SUMMATIONDELIVERED, "Current Tier 14 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK4SUMMATIONDELIVERED, "Current Tier 14 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK5SUMMATIONDELIVERED, "Current Tier 14 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK6SUMMATIONDELIVERED, "Current Tier 14 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK7SUMMATIONDELIVERED, "Current Tier 14 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK8SUMMATIONDELIVERED, "Current Tier 14 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK9SUMMATIONDELIVERED, "Current Tier 14 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK10SUMMATIONDELIVERED, "Current Tier 14 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK11SUMMATIONDELIVERED, "Current Tier 14 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK12SUMMATIONDELIVERED, "Current Tier 14 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK13SUMMATIONDELIVERED, "Current Tier 14 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK14SUMMATIONDELIVERED, "Current Tier 14 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK15SUMMATIONDELIVERED, "Current Tier 14 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK16SUMMATIONDELIVERED, "Current Tier 14 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK1SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK1SUMMATIONDELIVERED, "Current Tier 15 Block 1 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK2SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK2SUMMATIONDELIVERED, "Current Tier 15 Block 2 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK3SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK3SUMMATIONDELIVERED, "Current Tier 15 Block 3 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK4SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK4SUMMATIONDELIVERED, "Current Tier 15 Block 4 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK5SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK5SUMMATIONDELIVERED, "Current Tier 15 Block 5 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK6SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK6SUMMATIONDELIVERED, "Current Tier 15 Block 6 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK7SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK7SUMMATIONDELIVERED, "Current Tier 15 Block 7 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK8SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK8SUMMATIONDELIVERED, "Current Tier 15 Block 8 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK9SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK9SUMMATIONDELIVERED, "Current Tier 15 Block 9 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK10SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK10SUMMATIONDELIVERED, "Current Tier 15 Block 10 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK11SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK11SUMMATIONDELIVERED, "Current Tier 15 Block 11 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK12SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK12SUMMATIONDELIVERED, "Current Tier 15 Block 12 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK13SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK13SUMMATIONDELIVERED, "Current Tier 15 Block 13 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK14SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK14SUMMATIONDELIVERED, "Current Tier 15 Block 14 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK15SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK15SUMMATIONDELIVERED, "Current Tier 15 Block 15 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK16SUMMATIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK16SUMMATIONDELIVERED, "Current Tier 15 Block 16 Summation Delivered", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_GENERICALARMMASK, new ZclAttribute(ZclClusterType.METERING, ATTR_GENERICALARMMASK, "Generic Alarm Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_ELECTRICITYALARMMASK, new ZclAttribute(ZclClusterType.METERING, ATTR_ELECTRICITYALARMMASK, "Electricity Alarm Mask", ZclDataType.BITMAP_32_BIT, false, true, true, true));
        attributeMap.put(ATTR_GENERICFLOWPRESSUREALARMMASK, new ZclAttribute(ZclClusterType.METERING, ATTR_GENERICFLOWPRESSUREALARMMASK, "Generic Flow /pressure Alarm Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_WATERSPECIFICALARMMASK, new ZclAttribute(ZclClusterType.METERING, ATTR_WATERSPECIFICALARMMASK, "Water Specific Alarm Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_HEATANDCOOLINGSPECIFICALARMMASK, new ZclAttribute(ZclClusterType.METERING, ATTR_HEATANDCOOLINGSPECIFICALARMMASK, "Heat And Cooling Specific Alarm Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_GASSPECIFICALARMMASK, new ZclAttribute(ZclClusterType.METERING, ATTR_GASSPECIFICALARMMASK, "Gas Specific Alarm Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_EXTENDEDGENERICALARMMASK, new ZclAttribute(ZclClusterType.METERING, ATTR_EXTENDEDGENERICALARMMASK, "Extended Generic Alarm Mask", ZclDataType.BITMAP_48_BIT, false, true, true, true));
        attributeMap.put(ATTR_MANUFACTUREALARMMASK, new ZclAttribute(ZclClusterType.METERING, ATTR_MANUFACTUREALARMMASK, "Manufacture Alarm Mask", ZclDataType.BITMAP_16_BIT, false, true, true, true));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK1SUMMATIONRECEIVED, "Current No Tier Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK2SUMMATIONRECEIVED, "Current No Tier Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK3SUMMATIONRECEIVED, "Current No Tier Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK4SUMMATIONRECEIVED, "Current No Tier Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK5SUMMATIONRECEIVED, "Current No Tier Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK6SUMMATIONRECEIVED, "Current No Tier Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK7SUMMATIONRECEIVED, "Current No Tier Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK8SUMMATIONRECEIVED, "Current No Tier Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK9SUMMATIONRECEIVED, "Current No Tier Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK10SUMMATIONRECEIVED, "Current No Tier Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK11SUMMATIONRECEIVED, "Current No Tier Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK12SUMMATIONRECEIVED, "Current No Tier Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK13SUMMATIONRECEIVED, "Current No Tier Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK14SUMMATIONRECEIVED, "Current No Tier Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK15SUMMATIONRECEIVED, "Current No Tier Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTNOTIERBLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTNOTIERBLOCK16SUMMATIONRECEIVED, "Current No Tier Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK1SUMMATIONRECEIVED, "Current Tier 1 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK2SUMMATIONRECEIVED, "Current Tier 1 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK3SUMMATIONRECEIVED, "Current Tier 1 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK4SUMMATIONRECEIVED, "Current Tier 1 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK5SUMMATIONRECEIVED, "Current Tier 1 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK6SUMMATIONRECEIVED, "Current Tier 1 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK7SUMMATIONRECEIVED, "Current Tier 1 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK8SUMMATIONRECEIVED, "Current Tier 1 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK9SUMMATIONRECEIVED, "Current Tier 1 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK10SUMMATIONRECEIVED, "Current Tier 1 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK11SUMMATIONRECEIVED, "Current Tier 1 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK12SUMMATIONRECEIVED, "Current Tier 1 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK13SUMMATIONRECEIVED, "Current Tier 1 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK14SUMMATIONRECEIVED, "Current Tier 1 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK15SUMMATIONRECEIVED, "Current Tier 1 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER1BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER1BLOCK16SUMMATIONRECEIVED, "Current Tier 1 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK1SUMMATIONRECEIVED, "Current Tier 2 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK2SUMMATIONRECEIVED, "Current Tier 2 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK3SUMMATIONRECEIVED, "Current Tier 2 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK4SUMMATIONRECEIVED, "Current Tier 2 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK5SUMMATIONRECEIVED, "Current Tier 2 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK6SUMMATIONRECEIVED, "Current Tier 2 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK7SUMMATIONRECEIVED, "Current Tier 2 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK8SUMMATIONRECEIVED, "Current Tier 2 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK9SUMMATIONRECEIVED, "Current Tier 2 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK10SUMMATIONRECEIVED, "Current Tier 2 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK11SUMMATIONRECEIVED, "Current Tier 2 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK12SUMMATIONRECEIVED, "Current Tier 2 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK13SUMMATIONRECEIVED, "Current Tier 2 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK14SUMMATIONRECEIVED, "Current Tier 2 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK15SUMMATIONRECEIVED, "Current Tier 2 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER2BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER2BLOCK16SUMMATIONRECEIVED, "Current Tier 2 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK1SUMMATIONRECEIVED, "Current Tier 3 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK2SUMMATIONRECEIVED, "Current Tier 3 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK3SUMMATIONRECEIVED, "Current Tier 3 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK4SUMMATIONRECEIVED, "Current Tier 3 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK5SUMMATIONRECEIVED, "Current Tier 3 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK6SUMMATIONRECEIVED, "Current Tier 3 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK7SUMMATIONRECEIVED, "Current Tier 3 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK8SUMMATIONRECEIVED, "Current Tier 3 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK9SUMMATIONRECEIVED, "Current Tier 3 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK10SUMMATIONRECEIVED, "Current Tier 3 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK11SUMMATIONRECEIVED, "Current Tier 3 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK12SUMMATIONRECEIVED, "Current Tier 3 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK13SUMMATIONRECEIVED, "Current Tier 3 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK14SUMMATIONRECEIVED, "Current Tier 3 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK15SUMMATIONRECEIVED, "Current Tier 3 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER3BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER3BLOCK16SUMMATIONRECEIVED, "Current Tier 3 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK1SUMMATIONRECEIVED, "Current Tier 4 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK2SUMMATIONRECEIVED, "Current Tier 4 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK3SUMMATIONRECEIVED, "Current Tier 4 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK4SUMMATIONRECEIVED, "Current Tier 4 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK5SUMMATIONRECEIVED, "Current Tier 4 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK6SUMMATIONRECEIVED, "Current Tier 4 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK7SUMMATIONRECEIVED, "Current Tier 4 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK8SUMMATIONRECEIVED, "Current Tier 4 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK9SUMMATIONRECEIVED, "Current Tier 4 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK10SUMMATIONRECEIVED, "Current Tier 4 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK11SUMMATIONRECEIVED, "Current Tier 4 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK12SUMMATIONRECEIVED, "Current Tier 4 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK13SUMMATIONRECEIVED, "Current Tier 4 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK14SUMMATIONRECEIVED, "Current Tier 4 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK15SUMMATIONRECEIVED, "Current Tier 4 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER4BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER4BLOCK16SUMMATIONRECEIVED, "Current Tier 4 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK1SUMMATIONRECEIVED, "Current Tier 5 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK2SUMMATIONRECEIVED, "Current Tier 5 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK3SUMMATIONRECEIVED, "Current Tier 5 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK4SUMMATIONRECEIVED, "Current Tier 5 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK5SUMMATIONRECEIVED, "Current Tier 5 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK6SUMMATIONRECEIVED, "Current Tier 5 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK7SUMMATIONRECEIVED, "Current Tier 5 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK8SUMMATIONRECEIVED, "Current Tier 5 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK9SUMMATIONRECEIVED, "Current Tier 5 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK10SUMMATIONRECEIVED, "Current Tier 5 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK11SUMMATIONRECEIVED, "Current Tier 5 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK12SUMMATIONRECEIVED, "Current Tier 5 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK13SUMMATIONRECEIVED, "Current Tier 5 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK14SUMMATIONRECEIVED, "Current Tier 5 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK15SUMMATIONRECEIVED, "Current Tier 5 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER5BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER5BLOCK16SUMMATIONRECEIVED, "Current Tier 5 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK1SUMMATIONRECEIVED, "Current Tier 6 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK2SUMMATIONRECEIVED, "Current Tier 6 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK3SUMMATIONRECEIVED, "Current Tier 6 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK4SUMMATIONRECEIVED, "Current Tier 6 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK5SUMMATIONRECEIVED, "Current Tier 6 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK6SUMMATIONRECEIVED, "Current Tier 6 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK7SUMMATIONRECEIVED, "Current Tier 6 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK8SUMMATIONRECEIVED, "Current Tier 6 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK9SUMMATIONRECEIVED, "Current Tier 6 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK10SUMMATIONRECEIVED, "Current Tier 6 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK11SUMMATIONRECEIVED, "Current Tier 6 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK12SUMMATIONRECEIVED, "Current Tier 6 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK13SUMMATIONRECEIVED, "Current Tier 6 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK14SUMMATIONRECEIVED, "Current Tier 6 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK15SUMMATIONRECEIVED, "Current Tier 6 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER6BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER6BLOCK16SUMMATIONRECEIVED, "Current Tier 6 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK1SUMMATIONRECEIVED, "Current Tier 7 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK2SUMMATIONRECEIVED, "Current Tier 7 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK3SUMMATIONRECEIVED, "Current Tier 7 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK4SUMMATIONRECEIVED, "Current Tier 7 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK5SUMMATIONRECEIVED, "Current Tier 7 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK6SUMMATIONRECEIVED, "Current Tier 7 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK7SUMMATIONRECEIVED, "Current Tier 7 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK8SUMMATIONRECEIVED, "Current Tier 7 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK9SUMMATIONRECEIVED, "Current Tier 7 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK10SUMMATIONRECEIVED, "Current Tier 7 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK11SUMMATIONRECEIVED, "Current Tier 7 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK12SUMMATIONRECEIVED, "Current Tier 7 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK13SUMMATIONRECEIVED, "Current Tier 7 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK14SUMMATIONRECEIVED, "Current Tier 7 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK15SUMMATIONRECEIVED, "Current Tier 7 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER7BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER7BLOCK16SUMMATIONRECEIVED, "Current Tier 7 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK1SUMMATIONRECEIVED, "Current Tier 8 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK2SUMMATIONRECEIVED, "Current Tier 8 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK3SUMMATIONRECEIVED, "Current Tier 8 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK4SUMMATIONRECEIVED, "Current Tier 8 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK5SUMMATIONRECEIVED, "Current Tier 8 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK6SUMMATIONRECEIVED, "Current Tier 8 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK7SUMMATIONRECEIVED, "Current Tier 8 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK8SUMMATIONRECEIVED, "Current Tier 8 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK9SUMMATIONRECEIVED, "Current Tier 8 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK10SUMMATIONRECEIVED, "Current Tier 8 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK11SUMMATIONRECEIVED, "Current Tier 8 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK12SUMMATIONRECEIVED, "Current Tier 8 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK13SUMMATIONRECEIVED, "Current Tier 8 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK14SUMMATIONRECEIVED, "Current Tier 8 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK15SUMMATIONRECEIVED, "Current Tier 8 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER8BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER8BLOCK16SUMMATIONRECEIVED, "Current Tier 8 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK1SUMMATIONRECEIVED, "Current Tier 9 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK2SUMMATIONRECEIVED, "Current Tier 9 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK3SUMMATIONRECEIVED, "Current Tier 9 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK4SUMMATIONRECEIVED, "Current Tier 9 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK5SUMMATIONRECEIVED, "Current Tier 9 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK6SUMMATIONRECEIVED, "Current Tier 9 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK7SUMMATIONRECEIVED, "Current Tier 9 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK8SUMMATIONRECEIVED, "Current Tier 9 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK9SUMMATIONRECEIVED, "Current Tier 9 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK10SUMMATIONRECEIVED, "Current Tier 9 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK11SUMMATIONRECEIVED, "Current Tier 9 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK12SUMMATIONRECEIVED, "Current Tier 9 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK13SUMMATIONRECEIVED, "Current Tier 9 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK14SUMMATIONRECEIVED, "Current Tier 9 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK15SUMMATIONRECEIVED, "Current Tier 9 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER9BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER9BLOCK16SUMMATIONRECEIVED, "Current Tier 9 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK1SUMMATIONRECEIVED, "Current Tier 10 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK2SUMMATIONRECEIVED, "Current Tier 10 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK3SUMMATIONRECEIVED, "Current Tier 10 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK4SUMMATIONRECEIVED, "Current Tier 10 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK5SUMMATIONRECEIVED, "Current Tier 10 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK6SUMMATIONRECEIVED, "Current Tier 10 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK7SUMMATIONRECEIVED, "Current Tier 10 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK8SUMMATIONRECEIVED, "Current Tier 10 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK9SUMMATIONRECEIVED, "Current Tier 10 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK10SUMMATIONRECEIVED, "Current Tier 10 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK11SUMMATIONRECEIVED, "Current Tier 10 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK12SUMMATIONRECEIVED, "Current Tier 10 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK13SUMMATIONRECEIVED, "Current Tier 10 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK14SUMMATIONRECEIVED, "Current Tier 10 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK15SUMMATIONRECEIVED, "Current Tier 10 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER10BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER10BLOCK16SUMMATIONRECEIVED, "Current Tier 10 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK1SUMMATIONRECEIVED, "Current Tier 11 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK2SUMMATIONRECEIVED, "Current Tier 11 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK3SUMMATIONRECEIVED, "Current Tier 11 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK4SUMMATIONRECEIVED, "Current Tier 11 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK5SUMMATIONRECEIVED, "Current Tier 11 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK6SUMMATIONRECEIVED, "Current Tier 11 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK7SUMMATIONRECEIVED, "Current Tier 11 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK8SUMMATIONRECEIVED, "Current Tier 11 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK9SUMMATIONRECEIVED, "Current Tier 11 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK10SUMMATIONRECEIVED, "Current Tier 11 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK11SUMMATIONRECEIVED, "Current Tier 11 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK12SUMMATIONRECEIVED, "Current Tier 11 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK13SUMMATIONRECEIVED, "Current Tier 11 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK14SUMMATIONRECEIVED, "Current Tier 11 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK15SUMMATIONRECEIVED, "Current Tier 11 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER11BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER11BLOCK16SUMMATIONRECEIVED, "Current Tier 11 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK1SUMMATIONRECEIVED, "Current Tier 12 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK2SUMMATIONRECEIVED, "Current Tier 12 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK3SUMMATIONRECEIVED, "Current Tier 12 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK4SUMMATIONRECEIVED, "Current Tier 12 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK5SUMMATIONRECEIVED, "Current Tier 12 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK6SUMMATIONRECEIVED, "Current Tier 12 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK7SUMMATIONRECEIVED, "Current Tier 12 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK8SUMMATIONRECEIVED, "Current Tier 12 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK9SUMMATIONRECEIVED, "Current Tier 12 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK10SUMMATIONRECEIVED, "Current Tier 12 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK11SUMMATIONRECEIVED, "Current Tier 12 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK12SUMMATIONRECEIVED, "Current Tier 12 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK13SUMMATIONRECEIVED, "Current Tier 12 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK14SUMMATIONRECEIVED, "Current Tier 12 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK15SUMMATIONRECEIVED, "Current Tier 12 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER12BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER12BLOCK16SUMMATIONRECEIVED, "Current Tier 12 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK1SUMMATIONRECEIVED, "Current Tier 13 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK2SUMMATIONRECEIVED, "Current Tier 13 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK3SUMMATIONRECEIVED, "Current Tier 13 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK4SUMMATIONRECEIVED, "Current Tier 13 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK5SUMMATIONRECEIVED, "Current Tier 13 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK6SUMMATIONRECEIVED, "Current Tier 13 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK7SUMMATIONRECEIVED, "Current Tier 13 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK8SUMMATIONRECEIVED, "Current Tier 13 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK9SUMMATIONRECEIVED, "Current Tier 13 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK10SUMMATIONRECEIVED, "Current Tier 13 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK11SUMMATIONRECEIVED, "Current Tier 13 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK12SUMMATIONRECEIVED, "Current Tier 13 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK13SUMMATIONRECEIVED, "Current Tier 13 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK14SUMMATIONRECEIVED, "Current Tier 13 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK15SUMMATIONRECEIVED, "Current Tier 13 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER13BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER13BLOCK16SUMMATIONRECEIVED, "Current Tier 13 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK1SUMMATIONRECEIVED, "Current Tier 14 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK2SUMMATIONRECEIVED, "Current Tier 14 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK3SUMMATIONRECEIVED, "Current Tier 14 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK4SUMMATIONRECEIVED, "Current Tier 14 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK5SUMMATIONRECEIVED, "Current Tier 14 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK6SUMMATIONRECEIVED, "Current Tier 14 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK7SUMMATIONRECEIVED, "Current Tier 14 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK8SUMMATIONRECEIVED, "Current Tier 14 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK9SUMMATIONRECEIVED, "Current Tier 14 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK10SUMMATIONRECEIVED, "Current Tier 14 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK11SUMMATIONRECEIVED, "Current Tier 14 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK12SUMMATIONRECEIVED, "Current Tier 14 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK13SUMMATIONRECEIVED, "Current Tier 14 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK14SUMMATIONRECEIVED, "Current Tier 14 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK15SUMMATIONRECEIVED, "Current Tier 14 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER14BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER14BLOCK16SUMMATIONRECEIVED, "Current Tier 14 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK1SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK1SUMMATIONRECEIVED, "Current Tier 15 Block 1 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK2SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK2SUMMATIONRECEIVED, "Current Tier 15 Block 2 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK3SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK3SUMMATIONRECEIVED, "Current Tier 15 Block 3 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK4SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK4SUMMATIONRECEIVED, "Current Tier 15 Block 4 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK5SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK5SUMMATIONRECEIVED, "Current Tier 15 Block 5 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK6SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK6SUMMATIONRECEIVED, "Current Tier 15 Block 6 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK7SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK7SUMMATIONRECEIVED, "Current Tier 15 Block 7 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK8SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK8SUMMATIONRECEIVED, "Current Tier 15 Block 8 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK9SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK9SUMMATIONRECEIVED, "Current Tier 15 Block 9 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK10SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK10SUMMATIONRECEIVED, "Current Tier 15 Block 10 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK11SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK11SUMMATIONRECEIVED, "Current Tier 15 Block 11 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK12SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK12SUMMATIONRECEIVED, "Current Tier 15 Block 12 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK13SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK13SUMMATIONRECEIVED, "Current Tier 15 Block 13 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK14SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK14SUMMATIONRECEIVED, "Current Tier 15 Block 14 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK15SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK15SUMMATIONRECEIVED, "Current Tier 15 Block 15 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTTIER15BLOCK16SUMMATIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTTIER15BLOCK16SUMMATIONRECEIVED, "Current Tier 15 Block 16 Summation Received", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_BILLTODATEDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_BILLTODATEDELIVERED, "Bill To Date Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_BILLTODATETIMESTAMPDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_BILLTODATETIMESTAMPDELIVERED, "Bill To Date Time Stamp Delivered", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_PROJECTEDBILLDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PROJECTEDBILLDELIVERED, "Projected Bill Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PROJECTEDBILLTIMESTAMPDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PROJECTEDBILLTIMESTAMPDELIVERED, "Projected Bill Time Stamp Delivered", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_BILLDELIVEREDTRAILINGDIGIT, new ZclAttribute(ZclClusterType.METERING, ATTR_BILLDELIVEREDTRAILINGDIGIT, "Bill Delivered Trailing Digit", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_BILLTODATERECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_BILLTODATERECEIVED, "Bill To Date Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_BILLTODATETIMESTAMPRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_BILLTODATETIMESTAMPRECEIVED, "Bill To Date Time Stamp Received", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_PROJECTEDBILLRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PROJECTEDBILLRECEIVED, "Projected Bill Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PROJECTEDBILLTIMESTAMPRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PROJECTEDBILLTIMESTAMPRECEIVED, "Projected Bill Time Stamp Received", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_BILLRECEIVEDTRAILINGDIGIT, new ZclAttribute(ZclClusterType.METERING, ATTR_BILLRECEIVEDTRAILINGDIGIT, "Bill Received Trailing Digit", ZclDataType.BITMAP_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_PROPOSEDCHANGESUPPLYIMPLEMENTATIONTIME, new ZclAttribute(ZclClusterType.METERING, ATTR_PROPOSEDCHANGESUPPLYIMPLEMENTATIONTIME, "Proposed Change Supply Implementation Time", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_PROPOSEDCHANGESUPPLYSTATUS, new ZclAttribute(ZclClusterType.METERING, ATTR_PROPOSEDCHANGESUPPLYSTATUS, "Proposed Change Supply Status", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_UNCONTROLLEDFLOWTHRESHOLD, new ZclAttribute(ZclClusterType.METERING, ATTR_UNCONTROLLEDFLOWTHRESHOLD, "Uncontrolled Flow Threshold", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_UNCONTROLLEDFLOWTHRESHOLDUNITOFMEASURE, new ZclAttribute(ZclClusterType.METERING, ATTR_UNCONTROLLEDFLOWTHRESHOLDUNITOFMEASURE, "Uncontrolled Flow Threshold Unit Of Measure", ZclDataType.ENUMERATION_8_BIT, true, true, false, false));
        attributeMap.put(ATTR_UNCONTROLLEDFLOWTHRESHOLDMULTIPLIER, new ZclAttribute(ZclClusterType.METERING, ATTR_UNCONTROLLEDFLOWTHRESHOLDMULTIPLIER, "Uncontrolled Flow Threshold Multiplier", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_UNCONTROLLEDFLOWTHRESHOLDDIVISOR, new ZclAttribute(ZclClusterType.METERING, ATTR_UNCONTROLLEDFLOWTHRESHOLDDIVISOR, "Uncontrolled Flow Threshold Divisor", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_FLOWSTABILIZATIONPERIOD, new ZclAttribute(ZclClusterType.METERING, ATTR_FLOWSTABILIZATIONPERIOD, "Flow Stabilization Period", ZclDataType.UNSIGNED_8_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_FLOWMEASUREMENTPERIOD, new ZclAttribute(ZclClusterType.METERING, ATTR_FLOWMEASUREMENTPERIOD, "Flow Measurement Period", ZclDataType.UNSIGNED_16_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_ALTERNATIVEINSTANTANEOUSDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_ALTERNATIVEINSTANTANEOUSDEMAND, "Alternative Instantaneous Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYALTERNATIVECONSUMPTIONDELIVERED, "Current Day Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYALTERNATIVECONSUMPTIONRECEIVED, "Current Day Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONDELIVERED, "Previous Day Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONRECEIVED, "Previous Day Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMEDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMEDELIVERED, "Current Alternative Partial Profile Interval Start Time Delivered", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMERECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMERECEIVED, "Current Alternative Partial Profile Interval Start Time Received", ZclDataType.UTCTIME, true, true, false, false));
        attributeMap.put(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUEDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUEDELIVERED, "Current Alternative Partial Profile Interval Value Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUERECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUERECEIVED, "Current Alternative Partial Profile Interval Value Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYALTERNATIVEMAXPRESSURE, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYALTERNATIVEMAXPRESSURE, "Current Day Alternative Max Pressure", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYALTERNATIVEMINPRESSURE, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYALTERNATIVEMINPRESSURE, "Current Day Alternative Min Pressure", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYALTERNATIVEMAXPRESSURE, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYALTERNATIVEMAXPRESSURE, "Previous Day Alternative Max Pressure", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYALTERNATIVEMINPRESSURE, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYALTERNATIVEMINPRESSURE, "Previous Day Alternative Min Pressure", ZclDataType.UNSIGNED_48_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTDAYALTERNATIVEMAXDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTDAYALTERNATIVEMAXDEMAND, "Current Day Alternative Max Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAYALTERNATIVEMAXDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAYALTERNATIVEMAXDEMAND, "Previous Day Alternative Max Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMONTHALTERNATIVEMAXDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMONTHALTERNATIVEMAXDEMAND, "Current Month Alternative Max Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTYEARALTERNATIVEMAXDEMAND, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTYEARALTERNATIVEMAXDEMAND, "Current Year Alternative Max Demand", ZclDataType.SIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONDELIVERED, "Previous Day 2 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY4ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY4ALTERNATIVECONSUMPTIONDELIVERED, "Previous Day 4 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY6ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY6ALTERNATIVECONSUMPTIONDELIVERED, "Previous Day 6 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY8ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY8ALTERNATIVECONSUMPTIONDELIVERED, "Previous Day 8 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY10ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY10ALTERNATIVECONSUMPTIONDELIVERED, "Previous Day 10 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY12ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY12ALTERNATIVECONSUMPTIONDELIVERED, "Previous Day 12 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONRECEIVED, "Previous Day 2 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY4ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY4ALTERNATIVECONSUMPTIONRECEIVED, "Previous Day 4 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY6ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY6ALTERNATIVECONSUMPTIONRECEIVED, "Previous Day 6 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY8ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY8ALTERNATIVECONSUMPTIONRECEIVED, "Previous Day 8 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY10ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY10ALTERNATIVECONSUMPTIONRECEIVED, "Previous Day 10 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSDAY12ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSDAY12ALTERNATIVECONSUMPTIONRECEIVED, "Previous Day 12 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONDELIVERED, "Current Week Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONRECEIVED, "Current Week Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONDELIVERED, "Previous Week 1 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK3ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK3ALTERNATIVECONSUMPTIONDELIVERED, "Previous Week 3 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK5ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK5ALTERNATIVECONSUMPTIONDELIVERED, "Previous Week 5 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK7ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK7ALTERNATIVECONSUMPTIONDELIVERED, "Previous Week 7 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK9ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK9ALTERNATIVECONSUMPTIONDELIVERED, "Previous Week 9 Alternative Consumption Delivered", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONRECEIVED, "Previous Week 1 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK3ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK3ALTERNATIVECONSUMPTIONRECEIVED, "Previous Week 3 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK5ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK5ALTERNATIVECONSUMPTIONRECEIVED, "Previous Week 5 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK7ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK7ALTERNATIVECONSUMPTIONRECEIVED, "Previous Week 7 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSWEEK9ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSWEEK9ALTERNATIVECONSUMPTIONRECEIVED, "Previous Week 9 Alternative Consumption Received", ZclDataType.UNSIGNED_24_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONDELIVERED, "Current Month Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONRECEIVED, "Current Month Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 1 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH3ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH3ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 3 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH5ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH5ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 5 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH7ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH7ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 7 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH9ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH9ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 9 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH11ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH11ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 11 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH13ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH13ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 13 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH15ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH15ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 15 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH17ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH17ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 17 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH19ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH19ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 19 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH21ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH21ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 21 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH23ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH23ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 23 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH25ALTERNATIVECONSUMPTIONDELIVERED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH25ALTERNATIVECONSUMPTIONDELIVERED, "Previous Month 25 Alternative Consumption Delivered", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 1 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH3ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH3ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 3 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH5ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH5ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 5 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH7ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH7ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 7 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH9ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH9ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 9 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH11ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH11ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 11 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH13ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH13ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 13 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH15ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH15ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 15 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH17ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH17ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 17 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH19ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH19ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 19 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH21ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH21ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 21 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH23ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH23ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 23 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));
        attributeMap.put(ATTR_PREVIOUSMONTH25ALTERNATIVECONSUMPTIONRECEIVED, new ZclAttribute(ZclClusterType.METERING, ATTR_PREVIOUSMONTH25ALTERNATIVECONSUMPTIONRECEIVED, "Previous Month 25 Alternative Consumption Received", ZclDataType.UNSIGNED_32_BIT_INTEGER, true, true, false, false));

        return attributeMap;
    }

    @Override
    protected Map<Integer, Class<? extends ZclCommand>> initializeServerCommands() {
        Map<Integer, Class<? extends ZclCommand>> commandMap = new ConcurrentHashMap<>(14);

        commandMap.put(0x0000, GetProfileResponse.class);
        commandMap.put(0x0001, RequestMirror.class);
        commandMap.put(0x0002, RemoveMirror.class);
        commandMap.put(0x0003, RequestFastPollModeResponse.class);
        commandMap.put(0x0004, ScheduleSnapshotResponse.class);
        commandMap.put(0x0005, TakeSnapshotResponse.class);
        commandMap.put(0x0006, PublishSnapshot.class);
        commandMap.put(0x0007, GetSampledDataResponse.class);
        commandMap.put(0x0008, ConfigureMirror.class);
        commandMap.put(0x0009, ConfigureNotificationScheme.class);
        commandMap.put(0x000A, ConfigureNotificationFlags.class);
        commandMap.put(0x000B, GetNotifiedMessage.class);
        commandMap.put(0x000C, SupplyStatusResponse.class);
        commandMap.put(0x000D, StartSamplingResponse.class);

        return commandMap;
    }

    @Override
    protected Map<Integer, Class<? extends ZclCommand>> initializeClientCommands() {
        Map<Integer, Class<? extends ZclCommand>> commandMap = new ConcurrentHashMap<>(15);

        commandMap.put(0x0000, GetProfile.class);
        commandMap.put(0x0001, RequestMirrorResponse.class);
        commandMap.put(0x0002, MirrorRemoved.class);
        commandMap.put(0x0003, RequestFastPollMode.class);
        commandMap.put(0x0004, ScheduleSnapshot.class);
        commandMap.put(0x0005, TakeSnapshot.class);
        commandMap.put(0x0006, GetSnapshot.class);
        commandMap.put(0x0007, StartSampling.class);
        commandMap.put(0x0008, GetSampledData.class);
        commandMap.put(0x0009, MirrorReportAttributeResponse.class);
        commandMap.put(0x000A, ResetLoadLimitCounter.class);
        commandMap.put(0x000B, ChangeSupply.class);
        commandMap.put(0x000C, LocalChangeSupply.class);
        commandMap.put(0x000D, SetSupplyStatus.class);
        commandMap.put(0x000E, SetUncontrolledFlowThreshold.class);

        return commandMap;
    }

    /**
     * Default constructor to create a Metering cluster.
     *
     * @param zigbeeEndpoint the {@link ZigBeeEndpoint} this cluster is contained within
     */
    public ZclMeteringCluster(final ZigBeeEndpoint zigbeeEndpoint) {
        super(zigbeeEndpoint, CLUSTER_ID, CLUSTER_NAME);
    }

    /**
     * Get the <i>Functional Notification Flags</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * The FunctionalNotificationFlags attribute is implemented as a set of bit flags which
     * are have a predefined action associated with a bit that is not based on a specific
     * command, but may require the Mirrored device to trigger some additional functionality
     * within the system.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getFunctionalNotificationFlagsAsync() {
        return read(attributes.get(ATTR_FUNCTIONALNOTIFICATIONFLAGS));
    }

    /**
     * Synchronously get the <i>Functional Notification Flags</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * The FunctionalNotificationFlags attribute is implemented as a set of bit flags which
     * are have a predefined action associated with a bit that is not based on a specific
     * command, but may require the Mirrored device to trigger some additional functionality
     * within the system.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getFunctionalNotificationFlags(final long refreshPeriod) {
        if (attributes.get(ATTR_FUNCTIONALNOTIFICATIONFLAGS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_FUNCTIONALNOTIFICATIONFLAGS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_FUNCTIONALNOTIFICATIONFLAGS));
    }

    /**
     * Set reporting for the <i>Functional Notification Flags</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * The FunctionalNotificationFlags attribute is implemented as a set of bit flags which
     * are have a predefined action associated with a bit that is not based on a specific
     * command, but may require the Mirrored device to trigger some additional functionality
     * within the system.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setFunctionalNotificationFlagsReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_FUNCTIONALNOTIFICATIONFLAGS), minInterval, maxInterval);
    }

    /**
     * Get the <i>Notification Flags {{count}}</i> attribute [attribute ID <b>0x0001</b>].
     * <p>
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 8)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNotificationFlagsAsync(final int arrayOffset) {
        if (arrayOffset < 2 || arrayOffset > 8) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_NOTIFICATIONFLAGS2 + arrayOffset));
    }

    /**
     * Synchronously get the <i>Notification Flags {{count}}</i> attribute [attribute ID <b>0x0001</b>].
     * <p>
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 8)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNotificationFlags(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_NOTIFICATIONFLAGS2 + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NOTIFICATIONFLAGS2 + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NOTIFICATIONFLAGS2 + arrayOffset));
    }

    /**
     * Set reporting for the <i>Notification Flags {{count}}</i> attribute [attribute ID <b>0x0001</b>].
     * <p>
     * NotificationFlags2 to NotificationFlags8 are 32-bit bitmaps that each represent a
     * series of flags. Each flag represents an outstanding command that the Mirror is holding
     * on behalf of the BOMD. Each flag represents a different command. The format of these
     * attributes is dictated by the scheme that is currently in operation.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 8)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNotificationFlags2Reporting(final int arrayOffset, final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_NOTIFICATIONFLAGS2 + arrayOffset - 1), minInterval, maxInterval);
    }

    /**
     * Get the <i>Current Summation Delivered</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * CurrentSummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered and consumed in the premises. CurrentSummationDelivered is
     * mandatory and must be provided as part of the minimum data set to be provided by the
     * metering device. CurrentSummationDelivered is updated continuously as new
     * measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentSummationDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTSUMMATIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Summation Delivered</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * CurrentSummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered and consumed in the premises. CurrentSummationDelivered is
     * mandatory and must be provided as part of the minimum data set to be provided by the
     * metering device. CurrentSummationDelivered is updated continuously as new
     * measurements are made.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentSummationDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTSUMMATIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTSUMMATIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTSUMMATIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Summation Delivered</i> attribute [attribute ID <b>0x0000</b>].
     * <p>
     * CurrentSummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered and consumed in the premises. CurrentSummationDelivered is
     * mandatory and must be provided as part of the minimum data set to be provided by the
     * metering device. CurrentSummationDelivered is updated continuously as new
     * measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentSummationDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTSUMMATIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Summation Received</i> attribute [attribute ID <b>0x0001</b>].
     * <p>
     * CurrentSummationReceived represents the most recent summed value of Energy, Gas, or
     * Water generated and delivered from the premises. If optionally provided,
     * CurrentSummationReceived is updated continuously as new measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentSummationReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTSUMMATIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Summation Received</i> attribute [attribute ID <b>0x0001</b>].
     * <p>
     * CurrentSummationReceived represents the most recent summed value of Energy, Gas, or
     * Water generated and delivered from the premises. If optionally provided,
     * CurrentSummationReceived is updated continuously as new measurements are made.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentSummationReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTSUMMATIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTSUMMATIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTSUMMATIONRECEIVED));
    }

    /**
     * Get the <i>Current Max Demand Delivered</i> attribute [attribute ID <b>0x0002</b>].
     * <p>
     * CurrentMaxDemandDelivered represents the maximum demand or rate of delivered value
     * of Energy, Gas, or Water being utilized at the premises. If optionally provided,
     * CurrentMaxDemandDelivered is updated continuously as new measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMaxDemandDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTMAXDEMANDDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Max Demand Delivered</i> attribute [attribute ID <b>0x0002</b>].
     * <p>
     * CurrentMaxDemandDelivered represents the maximum demand or rate of delivered value
     * of Energy, Gas, or Water being utilized at the premises. If optionally provided,
     * CurrentMaxDemandDelivered is updated continuously as new measurements are made.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMaxDemandDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMAXDEMANDDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMAXDEMANDDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMAXDEMANDDELIVERED));
    }

    /**
     * Get the <i>Current Max Demand Received</i> attribute [attribute ID <b>0x0003</b>].
     * <p>
     * CurrentMaxDemandReceived represents the maximum demand or rate of received value of
     * Energy, Gas, or Water being utilized by the utility. If optionally provided,
     * CurrentMaxDemandReceived is updated continuously as new measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMaxDemandReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTMAXDEMANDRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Max Demand Received</i> attribute [attribute ID <b>0x0003</b>].
     * <p>
     * CurrentMaxDemandReceived represents the maximum demand or rate of received value of
     * Energy, Gas, or Water being utilized by the utility. If optionally provided,
     * CurrentMaxDemandReceived is updated continuously as new measurements are made.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMaxDemandReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMAXDEMANDRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMAXDEMANDRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMAXDEMANDRECEIVED));
    }

    /**
     * Get the <i>Dft Summation</i> attribute [attribute ID <b>0x0004</b>].
     * <p>
     * DFTSummation represents a snapshot of attribute CurrentSummationDelivered
     * captured at the time indicated by attribute DailyFreezeTime. If optionally provided,
     * DFTSummation is updated once every 24 hours.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDftSummationAsync() {
        return read(attributes.get(ATTR_DFTSUMMATION));
    }

    /**
     * Synchronously get the <i>Dft Summation</i> attribute [attribute ID <b>0x0004</b>].
     * <p>
     * DFTSummation represents a snapshot of attribute CurrentSummationDelivered
     * captured at the time indicated by attribute DailyFreezeTime. If optionally provided,
     * DFTSummation is updated once every 24 hours.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDftSummation(final long refreshPeriod) {
        if (attributes.get(ATTR_DFTSUMMATION).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DFTSUMMATION).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DFTSUMMATION));
    }

    /**
     * Get the <i>Daily Freeze Time</i> attribute [attribute ID <b>0x0005</b>].
     * <p>
     * DailyFreezeTime represents the time of day when DFTSummation is captured.
     * DailyFreezeTime is an unsigned 16-bit value representing the hour and minutes for DFT.
     * <p>
     * Bits 0 to 7: Range of 0 to 0x3B representing the number of minutes past the top of the hour.
     * <p>
     * Bits 8 to 15: Range of 0 to 0x17 representing the hour of the day (in 24-hour format). Note
     * that midnight shall be represented as 00:00 only.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDailyFreezeTimeAsync() {
        return read(attributes.get(ATTR_DAILYFREEZETIME));
    }

    /**
     * Synchronously get the <i>Daily Freeze Time</i> attribute [attribute ID <b>0x0005</b>].
     * <p>
     * DailyFreezeTime represents the time of day when DFTSummation is captured.
     * DailyFreezeTime is an unsigned 16-bit value representing the hour and minutes for DFT.
     * <p>
     * Bits 0 to 7: Range of 0 to 0x3B representing the number of minutes past the top of the hour.
     * <p>
     * Bits 8 to 15: Range of 0 to 0x17 representing the hour of the day (in 24-hour format). Note
     * that midnight shall be represented as 00:00 only.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDailyFreezeTime(final long refreshPeriod) {
        if (attributes.get(ATTR_DAILYFREEZETIME).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DAILYFREEZETIME).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DAILYFREEZETIME));
    }

    /**
     * Get the <i>Power Factor</i> attribute [attribute ID <b>0x0006</b>].
     * <p>
     * PowerFactor contains the Average Power Factor ratio in 1/100ths. Valid values are 0 to
     * 99.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPowerFactorAsync() {
        return read(attributes.get(ATTR_POWERFACTOR));
    }

    /**
     * Synchronously get the <i>Power Factor</i> attribute [attribute ID <b>0x0006</b>].
     * <p>
     * PowerFactor contains the Average Power Factor ratio in 1/100ths. Valid values are 0 to
     * 99.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPowerFactor(final long refreshPeriod) {
        if (attributes.get(ATTR_POWERFACTOR).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_POWERFACTOR).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_POWERFACTOR));
    }

    /**
     * Set the <i>Reading Snapshot Time</i> attribute [attribute ID <b>0x0007</b>].
     * <p>
     * The ReadingSnapshotTime attribute represents the last time all of the
     * CurrentSummationDelivered, CurrentSummationReceived,
     * CurrentMaxDemandDelivered, and CurrentMaxDemandReceived attributes that are
     * supported by the device were updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param readingSnapshotTime the {@link Calendar} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setReadingSnapshotTime(final Calendar value) {
        return write(attributes.get(ATTR_READINGSNAPSHOTTIME), value);
    }

    /**
     * Get the <i>Reading Snapshot Time</i> attribute [attribute ID <b>0x0007</b>].
     * <p>
     * The ReadingSnapshotTime attribute represents the last time all of the
     * CurrentSummationDelivered, CurrentSummationReceived,
     * CurrentMaxDemandDelivered, and CurrentMaxDemandReceived attributes that are
     * supported by the device were updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getReadingSnapshotTimeAsync() {
        return read(attributes.get(ATTR_READINGSNAPSHOTTIME));
    }

    /**
     * Synchronously get the <i>Reading Snapshot Time</i> attribute [attribute ID <b>0x0007</b>].
     * <p>
     * The ReadingSnapshotTime attribute represents the last time all of the
     * CurrentSummationDelivered, CurrentSummationReceived,
     * CurrentMaxDemandDelivered, and CurrentMaxDemandReceived attributes that are
     * supported by the device were updated.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getReadingSnapshotTime(final long refreshPeriod) {
        if (attributes.get(ATTR_READINGSNAPSHOTTIME).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_READINGSNAPSHOTTIME).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_READINGSNAPSHOTTIME));
    }

    /**
     * Set reporting for the <i>Reading Snapshot Time</i> attribute [attribute ID <b>0x0007</b>].
     * <p>
     * The ReadingSnapshotTime attribute represents the last time all of the
     * CurrentSummationDelivered, CurrentSummationReceived,
     * CurrentMaxDemandDelivered, and CurrentMaxDemandReceived attributes that are
     * supported by the device were updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setReadingSnapshotTimeReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_READINGSNAPSHOTTIME), minInterval, maxInterval, reportableChange);
    }

    /**
     * Set the <i>Current Max Demand Delivered Time</i> attribute [attribute ID <b>0x0008</b>].
     * <p>
     * The CurrentMaxDemandDeliveredTime attribute represents the time when
     * CurrentMaxDemandDelivered reading was captured.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param currentMaxDemandDeliveredTime the {@link Calendar} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMaxDemandDeliveredTime(final Calendar value) {
        return write(attributes.get(ATTR_CURRENTMAXDEMANDDELIVEREDTIME), value);
    }

    /**
     * Get the <i>Current Max Demand Delivered Time</i> attribute [attribute ID <b>0x0008</b>].
     * <p>
     * The CurrentMaxDemandDeliveredTime attribute represents the time when
     * CurrentMaxDemandDelivered reading was captured.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMaxDemandDeliveredTimeAsync() {
        return read(attributes.get(ATTR_CURRENTMAXDEMANDDELIVEREDTIME));
    }

    /**
     * Synchronously get the <i>Current Max Demand Delivered Time</i> attribute [attribute ID <b>0x0008</b>].
     * <p>
     * The CurrentMaxDemandDeliveredTime attribute represents the time when
     * CurrentMaxDemandDelivered reading was captured.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getCurrentMaxDemandDeliveredTime(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMAXDEMANDDELIVEREDTIME).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_CURRENTMAXDEMANDDELIVEREDTIME).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_CURRENTMAXDEMANDDELIVEREDTIME));
    }

    /**
     * Set reporting for the <i>Current Max Demand Delivered Time</i> attribute [attribute ID <b>0x0008</b>].
     * <p>
     * The CurrentMaxDemandDeliveredTime attribute represents the time when
     * CurrentMaxDemandDelivered reading was captured.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMaxDemandDeliveredTimeReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMAXDEMANDDELIVEREDTIME), minInterval, maxInterval, reportableChange);
    }

    /**
     * Set the <i>Current Max Demand Received Time</i> attribute [attribute ID <b>0x0009</b>].
     * <p>
     * The CurrentMaxDemandReceivedTime attribute represents the time when
     * CurrentMaxDemandReceived reading was captured.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param currentMaxDemandReceivedTime the {@link Calendar} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMaxDemandReceivedTime(final Calendar value) {
        return write(attributes.get(ATTR_CURRENTMAXDEMANDRECEIVEDTIME), value);
    }

    /**
     * Get the <i>Current Max Demand Received Time</i> attribute [attribute ID <b>0x0009</b>].
     * <p>
     * The CurrentMaxDemandReceivedTime attribute represents the time when
     * CurrentMaxDemandReceived reading was captured.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMaxDemandReceivedTimeAsync() {
        return read(attributes.get(ATTR_CURRENTMAXDEMANDRECEIVEDTIME));
    }

    /**
     * Synchronously get the <i>Current Max Demand Received Time</i> attribute [attribute ID <b>0x0009</b>].
     * <p>
     * The CurrentMaxDemandReceivedTime attribute represents the time when
     * CurrentMaxDemandReceived reading was captured.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getCurrentMaxDemandReceivedTime(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMAXDEMANDRECEIVEDTIME).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_CURRENTMAXDEMANDRECEIVEDTIME).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_CURRENTMAXDEMANDRECEIVEDTIME));
    }

    /**
     * Set reporting for the <i>Current Max Demand Received Time</i> attribute [attribute ID <b>0x0009</b>].
     * <p>
     * The CurrentMaxDemandReceivedTime attribute represents the time when
     * CurrentMaxDemandReceived reading was captured.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMaxDemandReceivedTimeReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMAXDEMANDRECEIVEDTIME), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Default Update Period</i> attribute [attribute ID <b>0x000A</b>].
     * <p>
     * The DefaultUpdatePeriod attribute represents the interval (seconds) at which the
     * InstantaneousDemand attribute is updated when not in fast poll mode.
     * InstantaneousDemand may be continuously updated as new measurements are acquired,
     * but at a minimum InstantaneousDemand must be updated at the DefaultUpdatePeriod. The
     * DefaultUpdatePeriod may apply to other attributes as defined by the device
     * manufacturer.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDefaultUpdatePeriodAsync() {
        return read(attributes.get(ATTR_DEFAULTUPDATEPERIOD));
    }

    /**
     * Synchronously get the <i>Default Update Period</i> attribute [attribute ID <b>0x000A</b>].
     * <p>
     * The DefaultUpdatePeriod attribute represents the interval (seconds) at which the
     * InstantaneousDemand attribute is updated when not in fast poll mode.
     * InstantaneousDemand may be continuously updated as new measurements are acquired,
     * but at a minimum InstantaneousDemand must be updated at the DefaultUpdatePeriod. The
     * DefaultUpdatePeriod may apply to other attributes as defined by the device
     * manufacturer.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDefaultUpdatePeriod(final long refreshPeriod) {
        if (attributes.get(ATTR_DEFAULTUPDATEPERIOD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DEFAULTUPDATEPERIOD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DEFAULTUPDATEPERIOD));
    }

    /**
     * Get the <i>Fast Poll Update Period</i> attribute [attribute ID <b>0x000B</b>].
     * <p>
     * The FastPollUpdatePeriod attribute represents the interval (seconds) at which the
     * InstantaneousDemandattribute is updated when in fast poll mode.
     * InstantaneousDemand may be continuously updated as new measurements are acquired,
     * but at a minimum, InstantaneousDemand must be updated at the FastPollUpdatePeriod.
     * The FastPollUpdatePeriod may apply to other attributes as defined by the device
     * manufacturer.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getFastPollUpdatePeriodAsync() {
        return read(attributes.get(ATTR_FASTPOLLUPDATEPERIOD));
    }

    /**
     * Synchronously get the <i>Fast Poll Update Period</i> attribute [attribute ID <b>0x000B</b>].
     * <p>
     * The FastPollUpdatePeriod attribute represents the interval (seconds) at which the
     * InstantaneousDemandattribute is updated when in fast poll mode.
     * InstantaneousDemand may be continuously updated as new measurements are acquired,
     * but at a minimum, InstantaneousDemand must be updated at the FastPollUpdatePeriod.
     * The FastPollUpdatePeriod may apply to other attributes as defined by the device
     * manufacturer.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getFastPollUpdatePeriod(final long refreshPeriod) {
        if (attributes.get(ATTR_FASTPOLLUPDATEPERIOD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_FASTPOLLUPDATEPERIOD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_FASTPOLLUPDATEPERIOD));
    }

    /**
     * Get the <i>Current Block Period Consumption Delivered</i> attribute [attribute ID <b>0x000C</b>].
     * <p>
     * The CurrentBlockPeriodConsumptionDelivered attribute represents the most recent
     * summed value of Energy, Gas or Water delivered and consumed in the premises during the
     * Block Tariff Period.
     * <p>
     * The CurrentBlockPeriodConsumptionDelivered is reset at the start of each Block
     * Tariff Period.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentBlockPeriodConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTBLOCKPERIODCONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Block Period Consumption Delivered</i> attribute [attribute ID <b>0x000C</b>].
     * <p>
     * The CurrentBlockPeriodConsumptionDelivered attribute represents the most recent
     * summed value of Energy, Gas or Water delivered and consumed in the premises during the
     * Block Tariff Period.
     * <p>
     * The CurrentBlockPeriodConsumptionDelivered is reset at the start of each Block
     * Tariff Period.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentBlockPeriodConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTBLOCKPERIODCONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTBLOCKPERIODCONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTBLOCKPERIODCONSUMPTIONDELIVERED));
    }

    /**
     * Get the <i>Daily Consumption Target</i> attribute [attribute ID <b>0x000D</b>].
     * <p>
     * The DailyConsumptionTarget attribute is a daily target consumption amount that can be
     * displayed to the consumer on a HAN device, with the intent that it can be used to compare to
     * actual daily consumption (e.g. compare to the CurrentDayConsumptionDelivered).
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDailyConsumptionTargetAsync() {
        return read(attributes.get(ATTR_DAILYCONSUMPTIONTARGET));
    }

    /**
     * Synchronously get the <i>Daily Consumption Target</i> attribute [attribute ID <b>0x000D</b>].
     * <p>
     * The DailyConsumptionTarget attribute is a daily target consumption amount that can be
     * displayed to the consumer on a HAN device, with the intent that it can be used to compare to
     * actual daily consumption (e.g. compare to the CurrentDayConsumptionDelivered).
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDailyConsumptionTarget(final long refreshPeriod) {
        if (attributes.get(ATTR_DAILYCONSUMPTIONTARGET).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DAILYCONSUMPTIONTARGET).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DAILYCONSUMPTIONTARGET));
    }

    /**
     * Get the <i>Current Block</i> attribute [attribute ID <b>0x000E</b>].
     * <p>
     * When Block Tariffs are enabled, CurrentBlock is an 8-bit Enumeration which indicates
     * the currently active block. If blocks are active then the current active block is based
     * on the CurrentBlockPeriodConsumptionDelivered and the block thresholds. Block 1 is
     * active when the value of CurrentBlockPeriodConsumptionDelivered is less than or
     * equal to the Block1Threshold value, Block 2 is active when
     * CurrentBlockPeriodConsumptionDelivered is greater than Block1Threshold value and
     * less than or equal to the8 Block2Threshold value, and so on. Block 16 is active when the
     * value of CurrentBlockPeriodConsumptionDelivered is greater than Block15Threshold
     * value.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentBlockAsync() {
        return read(attributes.get(ATTR_CURRENTBLOCK));
    }

    /**
     * Synchronously get the <i>Current Block</i> attribute [attribute ID <b>0x000E</b>].
     * <p>
     * When Block Tariffs are enabled, CurrentBlock is an 8-bit Enumeration which indicates
     * the currently active block. If blocks are active then the current active block is based
     * on the CurrentBlockPeriodConsumptionDelivered and the block thresholds. Block 1 is
     * active when the value of CurrentBlockPeriodConsumptionDelivered is less than or
     * equal to the Block1Threshold value, Block 2 is active when
     * CurrentBlockPeriodConsumptionDelivered is greater than Block1Threshold value and
     * less than or equal to the8 Block2Threshold value, and so on. Block 16 is active when the
     * value of CurrentBlockPeriodConsumptionDelivered is greater than Block15Threshold
     * value.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentBlock(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTBLOCK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTBLOCK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTBLOCK));
    }

    /**
     * Get the <i>Profile Interval Period</i> attribute [attribute ID <b>0x000F</b>].
     * <p>
     * The ProfileIntervalPeriod attribute is currently included in the Get Profile
     * Response command payload, but does not appear in an attribute set. This represents the
     * duration of each interval. ProfileIntervalPeriod represents the interval or time
     * frame used to capture metered Energy, Gas, and Water consumption for profiling
     * purposes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProfileIntervalPeriodAsync() {
        return read(attributes.get(ATTR_PROFILEINTERVALPERIOD));
    }

    /**
     * Synchronously get the <i>Profile Interval Period</i> attribute [attribute ID <b>0x000F</b>].
     * <p>
     * The ProfileIntervalPeriod attribute is currently included in the Get Profile
     * Response command payload, but does not appear in an attribute set. This represents the
     * duration of each interval. ProfileIntervalPeriod represents the interval or time
     * frame used to capture metered Energy, Gas, and Water consumption for profiling
     * purposes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getProfileIntervalPeriod(final long refreshPeriod) {
        if (attributes.get(ATTR_PROFILEINTERVALPERIOD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PROFILEINTERVALPERIOD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PROFILEINTERVALPERIOD));
    }

    /**
     * Get the <i>Interval Read Reporting Period</i> attribute [attribute ID <b>0x0010</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getIntervalReadReportingPeriodAsync() {
        return read(attributes.get(ATTR_INTERVALREADREPORTINGPERIOD));
    }

    /**
     * Synchronously get the <i>Interval Read Reporting Period</i> attribute [attribute ID <b>0x0010</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getIntervalReadReportingPeriod(final long refreshPeriod) {
        if (attributes.get(ATTR_INTERVALREADREPORTINGPERIOD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_INTERVALREADREPORTINGPERIOD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_INTERVALREADREPORTINGPERIOD));
    }

    /**
     * Get the <i>Preset Reading Time</i> attribute [attribute ID <b>0x0011</b>].
     * <p>
     * The PresetReadingTime attribute represents the time of day (in quarter hour
     * increments) at which the meter will wake up and report a register reading even if there
     * has been no consumption for the previous 24 hours. PresetReadingTime is an unsigned
     * 16-bit value representing the hour and minutes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPresetReadingTimeAsync() {
        return read(attributes.get(ATTR_PRESETREADINGTIME));
    }

    /**
     * Synchronously get the <i>Preset Reading Time</i> attribute [attribute ID <b>0x0011</b>].
     * <p>
     * The PresetReadingTime attribute represents the time of day (in quarter hour
     * increments) at which the meter will wake up and report a register reading even if there
     * has been no consumption for the previous 24 hours. PresetReadingTime is an unsigned
     * 16-bit value representing the hour and minutes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPresetReadingTime(final long refreshPeriod) {
        if (attributes.get(ATTR_PRESETREADINGTIME).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PRESETREADINGTIME).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PRESETREADINGTIME));
    }

    /**
     * Get the <i>Volume Per Report</i> attribute [attribute ID <b>0x0012</b>].
     * <p>
     * The VolumePerReport attribute represents the volume per report increment from the
     * water or gas meter. For example a gas meter might be set to report its register reading for
     * every time 1 cubic meter of gas is used. For a water meter it might report the register
     * value every 10 liters of water usage.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getVolumePerReportAsync() {
        return read(attributes.get(ATTR_VOLUMEPERREPORT));
    }

    /**
     * Synchronously get the <i>Volume Per Report</i> attribute [attribute ID <b>0x0012</b>].
     * <p>
     * The VolumePerReport attribute represents the volume per report increment from the
     * water or gas meter. For example a gas meter might be set to report its register reading for
     * every time 1 cubic meter of gas is used. For a water meter it might report the register
     * value every 10 liters of water usage.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getVolumePerReport(final long refreshPeriod) {
        if (attributes.get(ATTR_VOLUMEPERREPORT).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_VOLUMEPERREPORT).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_VOLUMEPERREPORT));
    }

    /**
     * Get the <i>Flow Restriction</i> attribute [attribute ID <b>0x0013</b>].
     * <p>
     * The FlowRestriction attribute represents the volume per minute limit set in the flow
     * restrictor. This applies to water but not for gas. A setting of 0xFF indicates this
     * feature is disabled.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getFlowRestrictionAsync() {
        return read(attributes.get(ATTR_FLOWRESTRICTION));
    }

    /**
     * Synchronously get the <i>Flow Restriction</i> attribute [attribute ID <b>0x0013</b>].
     * <p>
     * The FlowRestriction attribute represents the volume per minute limit set in the flow
     * restrictor. This applies to water but not for gas. A setting of 0xFF indicates this
     * feature is disabled.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getFlowRestriction(final long refreshPeriod) {
        if (attributes.get(ATTR_FLOWRESTRICTION).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_FLOWRESTRICTION).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_FLOWRESTRICTION));
    }

    /**
     * Get the <i>Supply Status</i> attribute [attribute ID <b>0x0014</b>].
     * <p>
     * The SupplyStatus attribute represents the state of the supply at the customer's
     * premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSupplyStatusAsync() {
        return read(attributes.get(ATTR_SUPPLYSTATUS));
    }

    /**
     * Synchronously get the <i>Supply Status</i> attribute [attribute ID <b>0x0014</b>].
     * <p>
     * The SupplyStatus attribute represents the state of the supply at the customer's
     * premises.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getSupplyStatus(final long refreshPeriod) {
        if (attributes.get(ATTR_SUPPLYSTATUS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_SUPPLYSTATUS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_SUPPLYSTATUS));
    }

    /**
     * Get the <i>Current Inlet Energy Carrier Summation</i> attribute [attribute ID <b>0x0015</b>].
     * <p>
     * CurrentInletEnergyCarrierSummation is the current integrated volume of a given
     * energy carrier measured on the inlet. The formatting and unit of measure for this value
     * is specified in the EnergyCarrierUnitOfMeasure and
     * EnergyCarrierSummationFormatting attributes
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentInletEnergyCarrierSummationAsync() {
        return read(attributes.get(ATTR_CURRENTINLETENERGYCARRIERSUMMATION));
    }

    /**
     * Synchronously get the <i>Current Inlet Energy Carrier Summation</i> attribute [attribute ID <b>0x0015</b>].
     * <p>
     * CurrentInletEnergyCarrierSummation is the current integrated volume of a given
     * energy carrier measured on the inlet. The formatting and unit of measure for this value
     * is specified in the EnergyCarrierUnitOfMeasure and
     * EnergyCarrierSummationFormatting attributes
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentInletEnergyCarrierSummation(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTINLETENERGYCARRIERSUMMATION).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTINLETENERGYCARRIERSUMMATION).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTINLETENERGYCARRIERSUMMATION));
    }

    /**
     * Get the <i>Current Outlet Energy Carrier Summation</i> attribute [attribute ID <b>0x0016</b>].
     * <p>
     * CurrentOutletEnergyCarrierSummation is the current integrated volume of a given
     * energy carrier measured on the outlet. The formatting and unit of measure for this value
     * is specified in the EnergyCarrierUnitOfMeasure and
     * EnergyCarrierSummationFormatting attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentOutletEnergyCarrierSummationAsync() {
        return read(attributes.get(ATTR_CURRENTOUTLETENERGYCARRIERSUMMATION));
    }

    /**
     * Synchronously get the <i>Current Outlet Energy Carrier Summation</i> attribute [attribute ID <b>0x0016</b>].
     * <p>
     * CurrentOutletEnergyCarrierSummation is the current integrated volume of a given
     * energy carrier measured on the outlet. The formatting and unit of measure for this value
     * is specified in the EnergyCarrierUnitOfMeasure and
     * EnergyCarrierSummationFormatting attributes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentOutletEnergyCarrierSummation(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTOUTLETENERGYCARRIERSUMMATION).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTOUTLETENERGYCARRIERSUMMATION).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTOUTLETENERGYCARRIERSUMMATION));
    }

    /**
     * Get the <i>Inlet Temperature</i> attribute [attribute ID <b>0x0017</b>].
     * <p>
     * InletTemperature is the temperature measured on the energy carrier inlet.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getInletTemperatureAsync() {
        return read(attributes.get(ATTR_INLETTEMPERATURE));
    }

    /**
     * Synchronously get the <i>Inlet Temperature</i> attribute [attribute ID <b>0x0017</b>].
     * <p>
     * InletTemperature is the temperature measured on the energy carrier inlet.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getInletTemperature(final long refreshPeriod) {
        if (attributes.get(ATTR_INLETTEMPERATURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_INLETTEMPERATURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_INLETTEMPERATURE));
    }

    /**
     * Get the <i>Outlet Temperature</i> attribute [attribute ID <b>0x0018</b>].
     * <p>
     * OutletTemperature is the temperature measured on the energy carrier outlet.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getOutletTemperatureAsync() {
        return read(attributes.get(ATTR_OUTLETTEMPERATURE));
    }

    /**
     * Synchronously get the <i>Outlet Temperature</i> attribute [attribute ID <b>0x0018</b>].
     * <p>
     * OutletTemperature is the temperature measured on the energy carrier outlet.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getOutletTemperature(final long refreshPeriod) {
        if (attributes.get(ATTR_OUTLETTEMPERATURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_OUTLETTEMPERATURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_OUTLETTEMPERATURE));
    }

    /**
     * Get the <i>Control Temperature</i> attribute [attribute ID <b>0x0019</b>].
     * <p>
     * ControlTemperature is a reference temperature measured on the meter used to validate
     * the Inlet/Outlet temperatures.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getControlTemperatureAsync() {
        return read(attributes.get(ATTR_CONTROLTEMPERATURE));
    }

    /**
     * Synchronously get the <i>Control Temperature</i> attribute [attribute ID <b>0x0019</b>].
     * <p>
     * ControlTemperature is a reference temperature measured on the meter used to validate
     * the Inlet/Outlet temperatures.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getControlTemperature(final long refreshPeriod) {
        if (attributes.get(ATTR_CONTROLTEMPERATURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CONTROLTEMPERATURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CONTROLTEMPERATURE));
    }

    /**
     * Get the <i>Current Inlet Energy Carrier Demand</i> attribute [attribute ID <b>0x001A</b>].
     * <p>
     * CurrentInletEnergyCarrierDemand is the current absolute demand on the energy
     * carrier inlet.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentInletEnergyCarrierDemandAsync() {
        return read(attributes.get(ATTR_CURRENTINLETENERGYCARRIERDEMAND));
    }

    /**
     * Synchronously get the <i>Current Inlet Energy Carrier Demand</i> attribute [attribute ID <b>0x001A</b>].
     * <p>
     * CurrentInletEnergyCarrierDemand is the current absolute demand on the energy
     * carrier inlet.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentInletEnergyCarrierDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTINLETENERGYCARRIERDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTINLETENERGYCARRIERDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTINLETENERGYCARRIERDEMAND));
    }

    /**
     * Get the <i>Current Outlet Energy Carrier Demand</i> attribute [attribute ID <b>0x001B</b>].
     * <p>
     * CurrentOutletEnergyCarrierDemand is the current absolute demand on the energy
     * carrier outlet.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentOutletEnergyCarrierDemandAsync() {
        return read(attributes.get(ATTR_CURRENTOUTLETENERGYCARRIERDEMAND));
    }

    /**
     * Synchronously get the <i>Current Outlet Energy Carrier Demand</i> attribute [attribute ID <b>0x001B</b>].
     * <p>
     * CurrentOutletEnergyCarrierDemand is the current absolute demand on the energy
     * carrier outlet.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentOutletEnergyCarrierDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTOUTLETENERGYCARRIERDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTOUTLETENERGYCARRIERDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTOUTLETENERGYCARRIERDEMAND));
    }

    /**
     * Get the <i>Previous Block Period Consumption Delivered</i> attribute [attribute ID <b>0x001C</b>].
     * <p>
     * The PreviousBlockPeriodConsumptionDelivered attribute represents the total value
     * of Energy, Gas or Water delivered and consumed in the premises at the end of the previous
     * Block Tariff Period. If supported, the PreviousBlockPeriodConsumptionDelivered
     * attribute is updated at the end of each Block Tariff Period.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousBlockPeriodConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_PREVIOUSBLOCKPERIODCONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Previous Block Period Consumption Delivered</i> attribute [attribute ID <b>0x001C</b>].
     * <p>
     * The PreviousBlockPeriodConsumptionDelivered attribute represents the total value
     * of Energy, Gas or Water delivered and consumed in the premises at the end of the previous
     * Block Tariff Period. If supported, the PreviousBlockPeriodConsumptionDelivered
     * attribute is updated at the end of each Block Tariff Period.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousBlockPeriodConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSBLOCKPERIODCONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSBLOCKPERIODCONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSBLOCKPERIODCONSUMPTIONDELIVERED));
    }

    /**
     * Get the <i>Current Block Period Consumption Received</i> attribute [attribute ID <b>0x001D</b>].
     * <p>
     * The CurrentBlockPeriodConsumptionReceived attribute represents the most recent
     * summed value of Energy, Gas or Water received by the energy supplier from the premises
     * during the Block Tariff Period. The CurrentBlockPeriodConsumptionReceived
     * attribute is reset at the start of each Block Tariff Period.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentBlockPeriodConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTBLOCKPERIODCONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Block Period Consumption Received</i> attribute [attribute ID <b>0x001D</b>].
     * <p>
     * The CurrentBlockPeriodConsumptionReceived attribute represents the most recent
     * summed value of Energy, Gas or Water received by the energy supplier from the premises
     * during the Block Tariff Period. The CurrentBlockPeriodConsumptionReceived
     * attribute is reset at the start of each Block Tariff Period.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentBlockPeriodConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTBLOCKPERIODCONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTBLOCKPERIODCONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTBLOCKPERIODCONSUMPTIONRECEIVED));
    }

    /**
     * Get the <i>Current Block Received</i> attribute [attribute ID <b>0x001E</b>].
     * <p>
     * When Block Tariffs are enabled, CurrentBlockReceived is an 8-bit Enumeration which
     * indicates the currently active block. If blocks are active then the current active
     * block is based on the CurrentBlockPeriodConsumptionReceived and the block
     * thresholds. Block 1 is active when the value of
     * CurrentBlockPeriodConsumptionReceived is less than or equal to the Block1Threshold
     * value, Block 2 is active when CurrentBlockPeriodConsumptionReceived is greater than
     * Block1Threshold value and less than or equal to the Block2Threshold value, and so on.
     * Block 16 is active when the value of CurrentBlockPeriodConsumptionReceived is
     * greater than Block15Threshold value.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentBlockReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTBLOCKRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Block Received</i> attribute [attribute ID <b>0x001E</b>].
     * <p>
     * When Block Tariffs are enabled, CurrentBlockReceived is an 8-bit Enumeration which
     * indicates the currently active block. If blocks are active then the current active
     * block is based on the CurrentBlockPeriodConsumptionReceived and the block
     * thresholds. Block 1 is active when the value of
     * CurrentBlockPeriodConsumptionReceived is less than or equal to the Block1Threshold
     * value, Block 2 is active when CurrentBlockPeriodConsumptionReceived is greater than
     * Block1Threshold value and less than or equal to the Block2Threshold value, and so on.
     * Block 16 is active when the value of CurrentBlockPeriodConsumptionReceived is
     * greater than Block15Threshold value.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentBlockReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTBLOCKRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTBLOCKRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTBLOCKRECEIVED));
    }

    /**
     * Get the <i>Dft Summation Received</i> attribute [attribute ID <b>0x001F</b>].
     * <p>
     * DFTSummationReceived represents a snapshot of attribute CurrentSummationReceived
     * captured at the time indicated by the DailyFreezeTime attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDftSummationReceivedAsync() {
        return read(attributes.get(ATTR_DFTSUMMATIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Dft Summation Received</i> attribute [attribute ID <b>0x001F</b>].
     * <p>
     * DFTSummationReceived represents a snapshot of attribute CurrentSummationReceived
     * captured at the time indicated by the DailyFreezeTime attribute.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDftSummationReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_DFTSUMMATIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DFTSUMMATIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DFTSUMMATIONRECEIVED));
    }

    /**
     * Get the <i>Active Register Tier Delivered</i> attribute [attribute ID <b>0x0020</b>].
     * <p>
     * The ActiveRegisterTierDelivered attribute indicates the current register tier that
     * the energy consumed is being accumulated against.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getActiveRegisterTierDeliveredAsync() {
        return read(attributes.get(ATTR_ACTIVEREGISTERTIERDELIVERED));
    }

    /**
     * Synchronously get the <i>Active Register Tier Delivered</i> attribute [attribute ID <b>0x0020</b>].
     * <p>
     * The ActiveRegisterTierDelivered attribute indicates the current register tier that
     * the energy consumed is being accumulated against.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getActiveRegisterTierDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_ACTIVEREGISTERTIERDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ACTIVEREGISTERTIERDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ACTIVEREGISTERTIERDELIVERED));
    }

    /**
     * Get the <i>Active Register Tier Received</i> attribute [attribute ID <b>0x0021</b>].
     * <p>
     * The ActiveRegisterTierReceived attribute indicates the current register tier that
     * the energy generated is being accumulated against.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getActiveRegisterTierReceivedAsync() {
        return read(attributes.get(ATTR_ACTIVEREGISTERTIERRECEIVED));
    }

    /**
     * Synchronously get the <i>Active Register Tier Received</i> attribute [attribute ID <b>0x0021</b>].
     * <p>
     * The ActiveRegisterTierReceived attribute indicates the current register tier that
     * the energy generated is being accumulated against.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getActiveRegisterTierReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_ACTIVEREGISTERTIERRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ACTIVEREGISTERTIERRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ACTIVEREGISTERTIERRECEIVED));
    }

    /**
     * Get the <i>Last Block Switch Time</i> attribute [attribute ID <b>0x0022</b>].
     * <p>
     * This attribute allows other devices to determine the time at which a meter switches from
     * one block to another.
     * <p>
     * When Block Tariffs are enabled, the LastBlockSwitchTime attribute represents the
     * timestamp of the last update to the CurrentBlock attribute, as a result of the
     * consumption exceeding a threshold, or the start of a new block period and/or billing
     * period.
     * <p>
     * If, at the start of a new block period and/or billing period, the value of the
     * CurrentBlock attribute is still set to Block1 (0x01), the CurrentBlock attribute
     * value will not change but the LastBlockSwitchTime attribute shall be updated to
     * indicate this change.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getLastBlockSwitchTimeAsync() {
        return read(attributes.get(ATTR_LASTBLOCKSWITCHTIME));
    }

    /**
     * Synchronously get the <i>Last Block Switch Time</i> attribute [attribute ID <b>0x0022</b>].
     * <p>
     * This attribute allows other devices to determine the time at which a meter switches from
     * one block to another.
     * <p>
     * When Block Tariffs are enabled, the LastBlockSwitchTime attribute represents the
     * timestamp of the last update to the CurrentBlock attribute, as a result of the
     * consumption exceeding a threshold, or the start of a new block period and/or billing
     * period.
     * <p>
     * If, at the start of a new block period and/or billing period, the value of the
     * CurrentBlock attribute is still set to Block1 (0x01), the CurrentBlock attribute
     * value will not change but the LastBlockSwitchTime attribute shall be updated to
     * indicate this change.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getLastBlockSwitchTime(final long refreshPeriod) {
        if (attributes.get(ATTR_LASTBLOCKSWITCHTIME).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_LASTBLOCKSWITCHTIME).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_LASTBLOCKSWITCHTIME));
    }

    /**
     * Get the <i>Current Tier {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0100</b>].
     * <p>
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 48)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTierSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 48) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0100</b>].
     * <p>
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 48)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTierSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0100</b>].
     * <p>
     * Attributes CurrentTier1SummationDelivered through
     * CurrentTierNSummationDelivered represent the most recent summed value of Energy,
     * Gas, or Water delivered to the premises (i.e. delivered to the customer from the
     * utility) at a specific price tier as defined by a TOU schedule or a real time pricing
     * period. If optionally provided, attributes CurrentTier1SummationDelivered
     * through CurrentTierNSummationDelivered are updated continuously as new
     * measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 48)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER1SUMMATIONDELIVERED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier {{count}} Summation Received</i> attribute [attribute ID <b>0x0101</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 48)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTierSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 48) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier {{count}} Summation Received</i> attribute [attribute ID <b>0x0101</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 48)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTierSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier {{count}} Summation Received</i> attribute [attribute ID <b>0x0101</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 48)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER1SUMMATIONRECEIVED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>CPP 1 Summation Delivered</i> attribute [attribute ID <b>0x01FC</b>].
     * <p>
     * CPP1SummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered to the premises (i.e. delivered to the customer from the utility) while
     * Critical Peak Price CPP1 was being applied. If optionally provided, attribute
     * CPP1SummationDelivered is updated continuously as new measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCpp1SummationDeliveredAsync() {
        return read(attributes.get(ATTR_CPP1SUMMATIONDELIVERED));
    }

    /**
     * Synchronously get the <i>CPP 1 Summation Delivered</i> attribute [attribute ID <b>0x01FC</b>].
     * <p>
     * CPP1SummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered to the premises (i.e. delivered to the customer from the utility) while
     * Critical Peak Price CPP1 was being applied. If optionally provided, attribute
     * CPP1SummationDelivered is updated continuously as new measurements are made.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCpp1SummationDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CPP1SUMMATIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CPP1SUMMATIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CPP1SUMMATIONDELIVERED));
    }

    /**
     * Set reporting for the <i>CPP 1 Summation Delivered</i> attribute [attribute ID <b>0x01FC</b>].
     * <p>
     * CPP1SummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered to the premises (i.e. delivered to the customer from the utility) while
     * Critical Peak Price CPP1 was being applied. If optionally provided, attribute
     * CPP1SummationDelivered is updated continuously as new measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCpp1SummationDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CPP1SUMMATIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>CPP 2 Summation Delivered</i> attribute [attribute ID <b>0x01FE</b>].
     * <p>
     * CPP2SummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered to the premises (i.e. delivered to the customer from the utility) while
     * Critical Peak Price CPP2 was being applied. If optionally provided, attribute
     * CPP2SummationDelivered is updated continuously as new measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCpp2SummationDeliveredAsync() {
        return read(attributes.get(ATTR_CPP2SUMMATIONDELIVERED));
    }

    /**
     * Synchronously get the <i>CPP 2 Summation Delivered</i> attribute [attribute ID <b>0x01FE</b>].
     * <p>
     * CPP2SummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered to the premises (i.e. delivered to the customer from the utility) while
     * Critical Peak Price CPP2 was being applied. If optionally provided, attribute
     * CPP2SummationDelivered is updated continuously as new measurements are made.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCpp2SummationDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CPP2SUMMATIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CPP2SUMMATIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CPP2SUMMATIONDELIVERED));
    }

    /**
     * Set reporting for the <i>CPP 2 Summation Delivered</i> attribute [attribute ID <b>0x01FE</b>].
     * <p>
     * CPP2SummationDelivered represents the most recent summed value of Energy, Gas, or
     * Water delivered to the premises (i.e. delivered to the customer from the utility) while
     * Critical Peak Price CPP2 was being applied. If optionally provided, attribute
     * CPP2SummationDelivered is updated continuously as new measurements are made.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCpp2SummationDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CPP2SUMMATIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Status</i> attribute [attribute ID <b>0x0200</b>].
     * <p>
     * The Status attribute provides indicators reflecting the current error conditions
     * found by the metering device. This attribute is an 8-bit field where when an individual
     * bit is set, an error or warning condition exists. The behavior causing the setting or
     * resetting each bit is device specific. In other words, the application within the
     * metering device will determine and control when these settings are either set or
     * cleared.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getStatusAsync() {
        return read(attributes.get(ATTR_STATUS));
    }

    /**
     * Synchronously get the <i>Status</i> attribute [attribute ID <b>0x0200</b>].
     * <p>
     * The Status attribute provides indicators reflecting the current error conditions
     * found by the metering device. This attribute is an 8-bit field where when an individual
     * bit is set, an error or warning condition exists. The behavior causing the setting or
     * resetting each bit is device specific. In other words, the application within the
     * metering device will determine and control when these settings are either set or
     * cleared.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getStatus(final long refreshPeriod) {
        if (attributes.get(ATTR_STATUS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_STATUS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_STATUS));
    }

    /**
     * Set reporting for the <i>Status</i> attribute [attribute ID <b>0x0200</b>].
     * <p>
     * The Status attribute provides indicators reflecting the current error conditions
     * found by the metering device. This attribute is an 8-bit field where when an individual
     * bit is set, an error or warning condition exists. The behavior causing the setting or
     * resetting each bit is device specific. In other words, the application within the
     * metering device will determine and control when these settings are either set or
     * cleared.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setStatusReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_STATUS), minInterval, maxInterval);
    }

    /**
     * Get the <i>Remaining Battery Life</i> attribute [attribute ID <b>0x0201</b>].
     * <p>
     * RemainingBatteryLife represents the estimated remaining life of the battery in % of
     * capacity. A setting of 0xFF indicates this feature is disabled. The range 0 - 100 where
     * 100 = 100%, 0xFF = Unknown.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getRemainingBatteryLifeAsync() {
        return read(attributes.get(ATTR_REMAININGBATTERYLIFE));
    }

    /**
     * Synchronously get the <i>Remaining Battery Life</i> attribute [attribute ID <b>0x0201</b>].
     * <p>
     * RemainingBatteryLife represents the estimated remaining life of the battery in % of
     * capacity. A setting of 0xFF indicates this feature is disabled. The range 0 - 100 where
     * 100 = 100%, 0xFF = Unknown.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getRemainingBatteryLife(final long refreshPeriod) {
        if (attributes.get(ATTR_REMAININGBATTERYLIFE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_REMAININGBATTERYLIFE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_REMAININGBATTERYLIFE));
    }

    /**
     * Set reporting for the <i>Remaining Battery Life</i> attribute [attribute ID <b>0x0201</b>].
     * <p>
     * RemainingBatteryLife represents the estimated remaining life of the battery in % of
     * capacity. A setting of 0xFF indicates this feature is disabled. The range 0 - 100 where
     * 100 = 100%, 0xFF = Unknown.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setRemainingBatteryLifeReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_REMAININGBATTERYLIFE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Hours In Operation</i> attribute [attribute ID <b>0x0202</b>].
     * <p>
     * HoursInOperation is a counter that increments once every hour during operation. This
     * may be used as a check for tampering.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getHoursInOperationAsync() {
        return read(attributes.get(ATTR_HOURSINOPERATION));
    }

    /**
     * Synchronously get the <i>Hours In Operation</i> attribute [attribute ID <b>0x0202</b>].
     * <p>
     * HoursInOperation is a counter that increments once every hour during operation. This
     * may be used as a check for tampering.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getHoursInOperation(final long refreshPeriod) {
        if (attributes.get(ATTR_HOURSINOPERATION).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_HOURSINOPERATION).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_HOURSINOPERATION));
    }

    /**
     * Set reporting for the <i>Hours In Operation</i> attribute [attribute ID <b>0x0202</b>].
     * <p>
     * HoursInOperation is a counter that increments once every hour during operation. This
     * may be used as a check for tampering.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setHoursInOperationReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_HOURSINOPERATION), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Hours In Fault</i> attribute [attribute ID <b>0x0203</b>].
     * <p>
     * HoursInFault is a counter that increments once every hour when the device is in
     * operation with a fault detected. This may be used as a check for tampering.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getHoursInFaultAsync() {
        return read(attributes.get(ATTR_HOURSINFAULT));
    }

    /**
     * Synchronously get the <i>Hours In Fault</i> attribute [attribute ID <b>0x0203</b>].
     * <p>
     * HoursInFault is a counter that increments once every hour when the device is in
     * operation with a fault detected. This may be used as a check for tampering.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getHoursInFault(final long refreshPeriod) {
        if (attributes.get(ATTR_HOURSINFAULT).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_HOURSINFAULT).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_HOURSINFAULT));
    }

    /**
     * Set reporting for the <i>Hours In Fault</i> attribute [attribute ID <b>0x0203</b>].
     * <p>
     * HoursInFault is a counter that increments once every hour when the device is in
     * operation with a fault detected. This may be used as a check for tampering.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setHoursInFaultReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_HOURSINFAULT), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Extended Status</i> attribute [attribute ID <b>0x0204</b>].
     * <p>
     * The ExtendedStatus attribute reflects the state of items in a meter that the standard
     * Status attribute cannot show. The Extended Status BitMap is split into two groups of
     * flags: general flags and metering type specific flags. Flags are currently defined for
     * electricity and gas meters; flag definitions for other commodities will be added as and
     * when their usage is agreed.
     * <p>
     * These flags are set and reset by the meter autonomously; they cannot be reset by other
     * devices.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getExtendedStatusAsync() {
        return read(attributes.get(ATTR_EXTENDEDSTATUS));
    }

    /**
     * Synchronously get the <i>Extended Status</i> attribute [attribute ID <b>0x0204</b>].
     * <p>
     * The ExtendedStatus attribute reflects the state of items in a meter that the standard
     * Status attribute cannot show. The Extended Status BitMap is split into two groups of
     * flags: general flags and metering type specific flags. Flags are currently defined for
     * electricity and gas meters; flag definitions for other commodities will be added as and
     * when their usage is agreed.
     * <p>
     * These flags are set and reset by the meter autonomously; they cannot be reset by other
     * devices.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getExtendedStatus(final long refreshPeriod) {
        if (attributes.get(ATTR_EXTENDEDSTATUS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_EXTENDEDSTATUS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_EXTENDEDSTATUS));
    }

    /**
     * Set reporting for the <i>Extended Status</i> attribute [attribute ID <b>0x0204</b>].
     * <p>
     * The ExtendedStatus attribute reflects the state of items in a meter that the standard
     * Status attribute cannot show. The Extended Status BitMap is split into two groups of
     * flags: general flags and metering type specific flags. Flags are currently defined for
     * electricity and gas meters; flag definitions for other commodities will be added as and
     * when their usage is agreed.
     * <p>
     * These flags are set and reset by the meter autonomously; they cannot be reset by other
     * devices.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setExtendedStatusReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_EXTENDEDSTATUS), minInterval, maxInterval);
    }

    /**
     * Get the <i>Remaining Battery Life In Days</i> attribute [attribute ID <b>0x0205</b>].
     * <p>
     * RemainingBatteryLifeInDays attribute represents the estimated remaining life of
     * the battery in days of capacity. The range is 0  0xFFFE, where 0xFFFF represents
     * 'Invalid', 'Unused' and 'Disabled'.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getRemainingBatteryLifeInDaysAsync() {
        return read(attributes.get(ATTR_REMAININGBATTERYLIFEINDAYS));
    }

    /**
     * Synchronously get the <i>Remaining Battery Life In Days</i> attribute [attribute ID <b>0x0205</b>].
     * <p>
     * RemainingBatteryLifeInDays attribute represents the estimated remaining life of
     * the battery in days of capacity. The range is 0  0xFFFE, where 0xFFFF represents
     * 'Invalid', 'Unused' and 'Disabled'.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getRemainingBatteryLifeInDays(final long refreshPeriod) {
        if (attributes.get(ATTR_REMAININGBATTERYLIFEINDAYS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_REMAININGBATTERYLIFEINDAYS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_REMAININGBATTERYLIFEINDAYS));
    }

    /**
     * Set reporting for the <i>Remaining Battery Life In Days</i> attribute [attribute ID <b>0x0205</b>].
     * <p>
     * RemainingBatteryLifeInDays attribute represents the estimated remaining life of
     * the battery in days of capacity. The range is 0  0xFFFE, where 0xFFFF represents
     * 'Invalid', 'Unused' and 'Disabled'.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setRemainingBatteryLifeInDaysReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_REMAININGBATTERYLIFEINDAYS), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Meter ID</i> attribute [attribute ID <b>0x0206</b>].
     * <p>
     * CurrentMeterID attribute is the current ID for the Meter. This could be the current
     * firmware version supported on the meter.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMeterIdAsync() {
        return read(attributes.get(ATTR_CURRENTMETERID));
    }

    /**
     * Synchronously get the <i>Current Meter ID</i> attribute [attribute ID <b>0x0206</b>].
     * <p>
     * CurrentMeterID attribute is the current ID for the Meter. This could be the current
     * firmware version supported on the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link ByteArray} attribute value, or null on error
     */
    public ByteArray getCurrentMeterId(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMETERID).isLastValueCurrent(refreshPeriod)) {
            return (ByteArray) attributes.get(ATTR_CURRENTMETERID).getLastValue();
        }

        return (ByteArray) readSync(attributes.get(ATTR_CURRENTMETERID));
    }

    /**
     * Set reporting for the <i>Current Meter ID</i> attribute [attribute ID <b>0x0206</b>].
     * <p>
     * CurrentMeterID attribute is the current ID for the Meter. This could be the current
     * firmware version supported on the meter.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMeterIdReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_CURRENTMETERID), minInterval, maxInterval);
    }

    /**
     * Get the <i>Ambient Consumption Indicator</i> attribute [attribute ID <b>0x0207</b>].
     * <p>
     * The AmbientConsumptionIndicator attribute is an 8-bit enumeration which provides a
     * simple (i.e. Low/Medium/High) indication of the amount of a commodity being consumed
     * within the premises. The status is achieved by comparing the current value of the
     * InstantaneousDemand attribute with low/medium and medium/high thresholds.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getAmbientConsumptionIndicatorAsync() {
        return read(attributes.get(ATTR_AMBIENTCONSUMPTIONINDICATOR));
    }

    /**
     * Synchronously get the <i>Ambient Consumption Indicator</i> attribute [attribute ID <b>0x0207</b>].
     * <p>
     * The AmbientConsumptionIndicator attribute is an 8-bit enumeration which provides a
     * simple (i.e. Low/Medium/High) indication of the amount of a commodity being consumed
     * within the premises. The status is achieved by comparing the current value of the
     * InstantaneousDemand attribute with low/medium and medium/high thresholds.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getAmbientConsumptionIndicator(final long refreshPeriod) {
        if (attributes.get(ATTR_AMBIENTCONSUMPTIONINDICATOR).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_AMBIENTCONSUMPTIONINDICATOR).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_AMBIENTCONSUMPTIONINDICATOR));
    }

    /**
     * Set reporting for the <i>Ambient Consumption Indicator</i> attribute [attribute ID <b>0x0207</b>].
     * <p>
     * The AmbientConsumptionIndicator attribute is an 8-bit enumeration which provides a
     * simple (i.e. Low/Medium/High) indication of the amount of a commodity being consumed
     * within the premises. The status is achieved by comparing the current value of the
     * InstantaneousDemand attribute with low/medium and medium/high thresholds.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setAmbientConsumptionIndicatorReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_AMBIENTCONSUMPTIONINDICATOR), minInterval, maxInterval);
    }

    /**
     * Get the <i>Unit Of Measure</i> attribute [attribute ID <b>0x0300</b>].
     * <p>
     * UnitofMeasure provides a label for the Energy, Gas, or Water being measured by the
     * metering device. The unit of measure applies to all summations, consumptions/ profile
     * interval and demand/rate supported by this cluster other than those specifically
     * identified as being based upon the EnergyCarrierUnitOfMeasure or the
     * AlternativeUnitofMeasure. Other measurements such as the power factor are self
     * describing.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getUnitOfMeasureAsync() {
        return read(attributes.get(ATTR_UNITOFMEASURE));
    }

    /**
     * Synchronously get the <i>Unit Of Measure</i> attribute [attribute ID <b>0x0300</b>].
     * <p>
     * UnitofMeasure provides a label for the Energy, Gas, or Water being measured by the
     * metering device. The unit of measure applies to all summations, consumptions/ profile
     * interval and demand/rate supported by this cluster other than those specifically
     * identified as being based upon the EnergyCarrierUnitOfMeasure or the
     * AlternativeUnitofMeasure. Other measurements such as the power factor are self
     * describing.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getUnitOfMeasure(final long refreshPeriod) {
        if (attributes.get(ATTR_UNITOFMEASURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_UNITOFMEASURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_UNITOFMEASURE));
    }

    /**
     * Set reporting for the <i>Unit Of Measure</i> attribute [attribute ID <b>0x0300</b>].
     * <p>
     * UnitofMeasure provides a label for the Energy, Gas, or Water being measured by the
     * metering device. The unit of measure applies to all summations, consumptions/ profile
     * interval and demand/rate supported by this cluster other than those specifically
     * identified as being based upon the EnergyCarrierUnitOfMeasure or the
     * AlternativeUnitofMeasure. Other measurements such as the power factor are self
     * describing.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setUnitOfMeasureReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_UNITOFMEASURE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Multiplier</i> attribute [attribute ID <b>0x0301</b>].
     * <p>
     * Multiplier provides a value to be multiplied against a raw or uncompensated sensor
     * count of Energy, Gas, or Water being measured by the metering device. If present, this
     * attribute must be applied against all summation, consumption and demand values to
     * derive the delivered and received values expressed in the unit of measure specified.
     * This attribute must be used in conjunction with the Divisor attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getMultiplierAsync() {
        return read(attributes.get(ATTR_MULTIPLIER));
    }

    /**
     * Synchronously get the <i>Multiplier</i> attribute [attribute ID <b>0x0301</b>].
     * <p>
     * Multiplier provides a value to be multiplied against a raw or uncompensated sensor
     * count of Energy, Gas, or Water being measured by the metering device. If present, this
     * attribute must be applied against all summation, consumption and demand values to
     * derive the delivered and received values expressed in the unit of measure specified.
     * This attribute must be used in conjunction with the Divisor attribute.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getMultiplier(final long refreshPeriod) {
        if (attributes.get(ATTR_MULTIPLIER).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_MULTIPLIER).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_MULTIPLIER));
    }

    /**
     * Set reporting for the <i>Multiplier</i> attribute [attribute ID <b>0x0301</b>].
     * <p>
     * Multiplier provides a value to be multiplied against a raw or uncompensated sensor
     * count of Energy, Gas, or Water being measured by the metering device. If present, this
     * attribute must be applied against all summation, consumption and demand values to
     * derive the delivered and received values expressed in the unit of measure specified.
     * This attribute must be used in conjunction with the Divisor attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setMultiplierReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_MULTIPLIER), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Divisor</i> attribute [attribute ID <b>0x0302</b>].
     * <p>
     * Divisor provides a value to divide the results of applying the Multiplier Attribute
     * against a raw or uncompensated sensor count of Energy, Gas, or Water being measured by
     * the metering device. If present, this attribute must be applied against all summation,
     * consumption and demand values to derive the delivered and received values expressed in
     * the unit of measure specified. This attribute must be used in conjunction with the
     * Multiplier attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDivisorAsync() {
        return read(attributes.get(ATTR_DIVISOR));
    }

    /**
     * Synchronously get the <i>Divisor</i> attribute [attribute ID <b>0x0302</b>].
     * <p>
     * Divisor provides a value to divide the results of applying the Multiplier Attribute
     * against a raw or uncompensated sensor count of Energy, Gas, or Water being measured by
     * the metering device. If present, this attribute must be applied against all summation,
     * consumption and demand values to derive the delivered and received values expressed in
     * the unit of measure specified. This attribute must be used in conjunction with the
     * Multiplier attribute.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDivisor(final long refreshPeriod) {
        if (attributes.get(ATTR_DIVISOR).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DIVISOR).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DIVISOR));
    }

    /**
     * Set reporting for the <i>Divisor</i> attribute [attribute ID <b>0x0302</b>].
     * <p>
     * Divisor provides a value to divide the results of applying the Multiplier Attribute
     * against a raw or uncompensated sensor count of Energy, Gas, or Water being measured by
     * the metering device. If present, this attribute must be applied against all summation,
     * consumption and demand values to derive the delivered and received values expressed in
     * the unit of measure specified. This attribute must be used in conjunction with the
     * Multiplier attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDivisorReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_DIVISOR), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Summation Formatting</i> attribute [attribute ID <b>0x0303</b>].
     * <p>
     * SummationFormatting provides a method to properly decipher the number of digits and
     * the decimal location of the values found in the Summation Information Set of
     * attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSummationFormattingAsync() {
        return read(attributes.get(ATTR_SUMMATIONFORMATTING));
    }

    /**
     * Synchronously get the <i>Summation Formatting</i> attribute [attribute ID <b>0x0303</b>].
     * <p>
     * SummationFormatting provides a method to properly decipher the number of digits and
     * the decimal location of the values found in the Summation Information Set of
     * attributes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getSummationFormatting(final long refreshPeriod) {
        if (attributes.get(ATTR_SUMMATIONFORMATTING).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_SUMMATIONFORMATTING).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_SUMMATIONFORMATTING));
    }

    /**
     * Set reporting for the <i>Summation Formatting</i> attribute [attribute ID <b>0x0303</b>].
     * <p>
     * SummationFormatting provides a method to properly decipher the number of digits and
     * the decimal location of the values found in the Summation Information Set of
     * attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSummationFormattingReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_SUMMATIONFORMATTING), minInterval, maxInterval);
    }

    /**
     * Get the <i>Demand Formatting</i> attribute [attribute ID <b>0x0304</b>].
     * <p>
     * DemandFormatting provides a method to properly decipher the number of digits and the
     * decimal location of the values found in the Demand-related attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDemandFormattingAsync() {
        return read(attributes.get(ATTR_DEMANDFORMATTING));
    }

    /**
     * Synchronously get the <i>Demand Formatting</i> attribute [attribute ID <b>0x0304</b>].
     * <p>
     * DemandFormatting provides a method to properly decipher the number of digits and the
     * decimal location of the values found in the Demand-related attributes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDemandFormatting(final long refreshPeriod) {
        if (attributes.get(ATTR_DEMANDFORMATTING).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DEMANDFORMATTING).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DEMANDFORMATTING));
    }

    /**
     * Set reporting for the <i>Demand Formatting</i> attribute [attribute ID <b>0x0304</b>].
     * <p>
     * DemandFormatting provides a method to properly decipher the number of digits and the
     * decimal location of the values found in the Demand-related attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDemandFormattingReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_DEMANDFORMATTING), minInterval, maxInterval);
    }

    /**
     * Get the <i>Historical Consumption Formatting</i> attribute [attribute ID <b>0x0305</b>].
     * <p>
     * HistoricalConsumptionFormatting provides a method to properly decipher the number
     * of digits and the decimal location of the values found in the Historical Consumption Set
     * of attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getHistoricalConsumptionFormattingAsync() {
        return read(attributes.get(ATTR_HISTORICALCONSUMPTIONFORMATTING));
    }

    /**
     * Synchronously get the <i>Historical Consumption Formatting</i> attribute [attribute ID <b>0x0305</b>].
     * <p>
     * HistoricalConsumptionFormatting provides a method to properly decipher the number
     * of digits and the decimal location of the values found in the Historical Consumption Set
     * of attributes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getHistoricalConsumptionFormatting(final long refreshPeriod) {
        if (attributes.get(ATTR_HISTORICALCONSUMPTIONFORMATTING).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_HISTORICALCONSUMPTIONFORMATTING).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_HISTORICALCONSUMPTIONFORMATTING));
    }

    /**
     * Set reporting for the <i>Historical Consumption Formatting</i> attribute [attribute ID <b>0x0305</b>].
     * <p>
     * HistoricalConsumptionFormatting provides a method to properly decipher the number
     * of digits and the decimal location of the values found in the Historical Consumption Set
     * of attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setHistoricalConsumptionFormattingReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_HISTORICALCONSUMPTIONFORMATTING), minInterval, maxInterval);
    }

    /**
     * Get the <i>Metering Device Type</i> attribute [attribute ID <b>0x0306</b>].
     * <p>
     * MeteringDeviceType provides a label for identifying the type of metering device
     * present. The attribute are values representing Energy, Gas, Water, Thermal, Heat,
     * Cooling, and mirrored metering devices.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getMeteringDeviceTypeAsync() {
        return read(attributes.get(ATTR_METERINGDEVICETYPE));
    }

    /**
     * Synchronously get the <i>Metering Device Type</i> attribute [attribute ID <b>0x0306</b>].
     * <p>
     * MeteringDeviceType provides a label for identifying the type of metering device
     * present. The attribute are values representing Energy, Gas, Water, Thermal, Heat,
     * Cooling, and mirrored metering devices.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getMeteringDeviceType(final long refreshPeriod) {
        if (attributes.get(ATTR_METERINGDEVICETYPE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_METERINGDEVICETYPE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_METERINGDEVICETYPE));
    }

    /**
     * Set reporting for the <i>Metering Device Type</i> attribute [attribute ID <b>0x0306</b>].
     * <p>
     * MeteringDeviceType provides a label for identifying the type of metering device
     * present. The attribute are values representing Energy, Gas, Water, Thermal, Heat,
     * Cooling, and mirrored metering devices.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setMeteringDeviceTypeReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_METERINGDEVICETYPE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Site ID</i> attribute [attribute ID <b>0x0307</b>].
     * <p>
     * The SiteID is a ZCL Octet String field capable of storing a 32 character string (the first
     * Octet indicates length) encoded in UTF-8 format. The SiteID is a text string, known in
     * the UK as the MPAN number for electricity, MPRN for gas and 'Stand Point' in South Africa.
     * These numbers specify the meter point location in a standardized way. The field is
     * defined to accommodate the number of characters typically found in the UK and Europe (16
     * digits). Generally speaking the field is numeric but is defined for the possibility of
     * an alpha-numeric format by specifying an octet string.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSiteIdAsync() {
        return read(attributes.get(ATTR_SITEID));
    }

    /**
     * Synchronously get the <i>Site ID</i> attribute [attribute ID <b>0x0307</b>].
     * <p>
     * The SiteID is a ZCL Octet String field capable of storing a 32 character string (the first
     * Octet indicates length) encoded in UTF-8 format. The SiteID is a text string, known in
     * the UK as the MPAN number for electricity, MPRN for gas and 'Stand Point' in South Africa.
     * These numbers specify the meter point location in a standardized way. The field is
     * defined to accommodate the number of characters typically found in the UK and Europe (16
     * digits). Generally speaking the field is numeric but is defined for the possibility of
     * an alpha-numeric format by specifying an octet string.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link ByteArray} attribute value, or null on error
     */
    public ByteArray getSiteId(final long refreshPeriod) {
        if (attributes.get(ATTR_SITEID).isLastValueCurrent(refreshPeriod)) {
            return (ByteArray) attributes.get(ATTR_SITEID).getLastValue();
        }

        return (ByteArray) readSync(attributes.get(ATTR_SITEID));
    }

    /**
     * Set reporting for the <i>Site ID</i> attribute [attribute ID <b>0x0307</b>].
     * <p>
     * The SiteID is a ZCL Octet String field capable of storing a 32 character string (the first
     * Octet indicates length) encoded in UTF-8 format. The SiteID is a text string, known in
     * the UK as the MPAN number for electricity, MPRN for gas and 'Stand Point' in South Africa.
     * These numbers specify the meter point location in a standardized way. The field is
     * defined to accommodate the number of characters typically found in the UK and Europe (16
     * digits). Generally speaking the field is numeric but is defined for the possibility of
     * an alpha-numeric format by specifying an octet string.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSiteIdReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_SITEID), minInterval, maxInterval);
    }

    /**
     * Get the <i>Meter Serial Number</i> attribute [attribute ID <b>0x0308</b>].
     * <p>
     * The MeterSerialNumber is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format. It is used to provide
     * a unique identification of the metering device.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getMeterSerialNumberAsync() {
        return read(attributes.get(ATTR_METERSERIALNUMBER));
    }

    /**
     * Synchronously get the <i>Meter Serial Number</i> attribute [attribute ID <b>0x0308</b>].
     * <p>
     * The MeterSerialNumber is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format. It is used to provide
     * a unique identification of the metering device.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link ByteArray} attribute value, or null on error
     */
    public ByteArray getMeterSerialNumber(final long refreshPeriod) {
        if (attributes.get(ATTR_METERSERIALNUMBER).isLastValueCurrent(refreshPeriod)) {
            return (ByteArray) attributes.get(ATTR_METERSERIALNUMBER).getLastValue();
        }

        return (ByteArray) readSync(attributes.get(ATTR_METERSERIALNUMBER));
    }

    /**
     * Set reporting for the <i>Meter Serial Number</i> attribute [attribute ID <b>0x0308</b>].
     * <p>
     * The MeterSerialNumber is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format. It is used to provide
     * a unique identification of the metering device.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setMeterSerialNumberReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_METERSERIALNUMBER), minInterval, maxInterval);
    }

    /**
     * Get the <i>Energy Carrier Unit Of Measure</i> attribute [attribute ID <b>0x0309</b>].
     * <p>
     * The EnergyCarrierUnitOfMeasure specifies the unit of measure that the EnergyCarrier
     * is measured in. This unit of measure is typically a unit of volume or flow and cannot be an
     * amount of energy.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getEnergyCarrierUnitOfMeasureAsync() {
        return read(attributes.get(ATTR_ENERGYCARRIERUNITOFMEASURE));
    }

    /**
     * Synchronously get the <i>Energy Carrier Unit Of Measure</i> attribute [attribute ID <b>0x0309</b>].
     * <p>
     * The EnergyCarrierUnitOfMeasure specifies the unit of measure that the EnergyCarrier
     * is measured in. This unit of measure is typically a unit of volume or flow and cannot be an
     * amount of energy.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getEnergyCarrierUnitOfMeasure(final long refreshPeriod) {
        if (attributes.get(ATTR_ENERGYCARRIERUNITOFMEASURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ENERGYCARRIERUNITOFMEASURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ENERGYCARRIERUNITOFMEASURE));
    }

    /**
     * Set reporting for the <i>Energy Carrier Unit Of Measure</i> attribute [attribute ID <b>0x0309</b>].
     * <p>
     * The EnergyCarrierUnitOfMeasure specifies the unit of measure that the EnergyCarrier
     * is measured in. This unit of measure is typically a unit of volume or flow and cannot be an
     * amount of energy.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setEnergyCarrierUnitOfMeasureReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_ENERGYCARRIERUNITOFMEASURE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Energy Carrier Summation Formatting</i> attribute [attribute ID <b>0x030A</b>].
     * <p>
     * EnergyCarrierSummationFormatting provides a method to properly decipher the number
     * of digits and the decimal location of the values found in the Summation- related
     * attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getEnergyCarrierSummationFormattingAsync() {
        return read(attributes.get(ATTR_ENERGYCARRIERSUMMATIONFORMATTING));
    }

    /**
     * Synchronously get the <i>Energy Carrier Summation Formatting</i> attribute [attribute ID <b>0x030A</b>].
     * <p>
     * EnergyCarrierSummationFormatting provides a method to properly decipher the number
     * of digits and the decimal location of the values found in the Summation- related
     * attributes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getEnergyCarrierSummationFormatting(final long refreshPeriod) {
        if (attributes.get(ATTR_ENERGYCARRIERSUMMATIONFORMATTING).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ENERGYCARRIERSUMMATIONFORMATTING).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ENERGYCARRIERSUMMATIONFORMATTING));
    }

    /**
     * Set reporting for the <i>Energy Carrier Summation Formatting</i> attribute [attribute ID <b>0x030A</b>].
     * <p>
     * EnergyCarrierSummationFormatting provides a method to properly decipher the number
     * of digits and the decimal location of the values found in the Summation- related
     * attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setEnergyCarrierSummationFormattingReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_ENERGYCARRIERSUMMATIONFORMATTING), minInterval, maxInterval);
    }

    /**
     * Get the <i>Energy Carrier Demand Formatting</i> attribute [attribute ID <b>0x030B</b>].
     * <p>
     * EnergyCarrierDemandFormatting provides a method to properly decipher the number of
     * digits and the decimal location of the values found in the Demand-related attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getEnergyCarrierDemandFormattingAsync() {
        return read(attributes.get(ATTR_ENERGYCARRIERDEMANDFORMATTING));
    }

    /**
     * Synchronously get the <i>Energy Carrier Demand Formatting</i> attribute [attribute ID <b>0x030B</b>].
     * <p>
     * EnergyCarrierDemandFormatting provides a method to properly decipher the number of
     * digits and the decimal location of the values found in the Demand-related attributes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getEnergyCarrierDemandFormatting(final long refreshPeriod) {
        if (attributes.get(ATTR_ENERGYCARRIERDEMANDFORMATTING).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ENERGYCARRIERDEMANDFORMATTING).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ENERGYCARRIERDEMANDFORMATTING));
    }

    /**
     * Set reporting for the <i>Energy Carrier Demand Formatting</i> attribute [attribute ID <b>0x030B</b>].
     * <p>
     * EnergyCarrierDemandFormatting provides a method to properly decipher the number of
     * digits and the decimal location of the values found in the Demand-related attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setEnergyCarrierDemandFormattingReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_ENERGYCARRIERDEMANDFORMATTING), minInterval, maxInterval);
    }

    /**
     * Get the <i>Temperature Unit Of Measure</i> attribute [attribute ID <b>0x030C</b>].
     * <p>
     * TemperatureFormatting provides a method to properly decipher the number of digits and
     * the decimal location of the values found in the Temperature-related attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getTemperatureUnitOfMeasureAsync() {
        return read(attributes.get(ATTR_TEMPERATUREUNITOFMEASURE));
    }

    /**
     * Synchronously get the <i>Temperature Unit Of Measure</i> attribute [attribute ID <b>0x030C</b>].
     * <p>
     * TemperatureFormatting provides a method to properly decipher the number of digits and
     * the decimal location of the values found in the Temperature-related attributes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getTemperatureUnitOfMeasure(final long refreshPeriod) {
        if (attributes.get(ATTR_TEMPERATUREUNITOFMEASURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_TEMPERATUREUNITOFMEASURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_TEMPERATUREUNITOFMEASURE));
    }

    /**
     * Set reporting for the <i>Temperature Unit Of Measure</i> attribute [attribute ID <b>0x030C</b>].
     * <p>
     * TemperatureFormatting provides a method to properly decipher the number of digits and
     * the decimal location of the values found in the Temperature-related attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setTemperatureUnitOfMeasureReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_TEMPERATUREUNITOFMEASURE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Temperature Formatting</i> attribute [attribute ID <b>0x030D</b>].
     * <p>
     * The TemperatureUnitOfMeasure specifies the unit of measure that temperatures are
     * measured in.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getTemperatureFormattingAsync() {
        return read(attributes.get(ATTR_TEMPERATUREFORMATTING));
    }

    /**
     * Synchronously get the <i>Temperature Formatting</i> attribute [attribute ID <b>0x030D</b>].
     * <p>
     * The TemperatureUnitOfMeasure specifies the unit of measure that temperatures are
     * measured in.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getTemperatureFormatting(final long refreshPeriod) {
        if (attributes.get(ATTR_TEMPERATUREFORMATTING).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_TEMPERATUREFORMATTING).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_TEMPERATUREFORMATTING));
    }

    /**
     * Set reporting for the <i>Temperature Formatting</i> attribute [attribute ID <b>0x030D</b>].
     * <p>
     * The TemperatureUnitOfMeasure specifies the unit of measure that temperatures are
     * measured in.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setTemperatureFormattingReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_TEMPERATUREFORMATTING), minInterval, maxInterval);
    }

    /**
     * Get the <i>Module Serial Number</i> attribute [attribute ID <b>0x030E</b>].
     * <p>
     * The ModuleSerialNumber attribute represents the serial number (unique identifier)
     * of the meter module. It is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format. It shall be used to
     * uniquely identify the meter communications module.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getModuleSerialNumberAsync() {
        return read(attributes.get(ATTR_MODULESERIALNUMBER));
    }

    /**
     * Synchronously get the <i>Module Serial Number</i> attribute [attribute ID <b>0x030E</b>].
     * <p>
     * The ModuleSerialNumber attribute represents the serial number (unique identifier)
     * of the meter module. It is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format. It shall be used to
     * uniquely identify the meter communications module.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link ByteArray} attribute value, or null on error
     */
    public ByteArray getModuleSerialNumber(final long refreshPeriod) {
        if (attributes.get(ATTR_MODULESERIALNUMBER).isLastValueCurrent(refreshPeriod)) {
            return (ByteArray) attributes.get(ATTR_MODULESERIALNUMBER).getLastValue();
        }

        return (ByteArray) readSync(attributes.get(ATTR_MODULESERIALNUMBER));
    }

    /**
     * Set reporting for the <i>Module Serial Number</i> attribute [attribute ID <b>0x030E</b>].
     * <p>
     * The ModuleSerialNumber attribute represents the serial number (unique identifier)
     * of the meter module. It is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format. It shall be used to
     * uniquely identify the meter communications module.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setModuleSerialNumberReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_MODULESERIALNUMBER), minInterval, maxInterval);
    }

    /**
     * Get the <i>Operating Tariff Label Delivered</i> attribute [attribute ID <b>0x030F</b>].
     * <p>
     * The OperatingTariffLabelDelivered attribute is the meters version of the
     * TariffLabel attribute that is found within the Tariff Information attribute set of the
     * Price Cluster. It is used to identify the current consumption tariff operating on the
     * meter. The attribute is a ZCL Octet String field capable of storing a 24 character string
     * (the first Octet indicates length) encoded in UTF-8 format.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getOperatingTariffLabelDeliveredAsync() {
        return read(attributes.get(ATTR_OPERATINGTARIFFLABELDELIVERED));
    }

    /**
     * Synchronously get the <i>Operating Tariff Label Delivered</i> attribute [attribute ID <b>0x030F</b>].
     * <p>
     * The OperatingTariffLabelDelivered attribute is the meters version of the
     * TariffLabel attribute that is found within the Tariff Information attribute set of the
     * Price Cluster. It is used to identify the current consumption tariff operating on the
     * meter. The attribute is a ZCL Octet String field capable of storing a 24 character string
     * (the first Octet indicates length) encoded in UTF-8 format.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link ByteArray} attribute value, or null on error
     */
    public ByteArray getOperatingTariffLabelDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_OPERATINGTARIFFLABELDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (ByteArray) attributes.get(ATTR_OPERATINGTARIFFLABELDELIVERED).getLastValue();
        }

        return (ByteArray) readSync(attributes.get(ATTR_OPERATINGTARIFFLABELDELIVERED));
    }

    /**
     * Set reporting for the <i>Operating Tariff Label Delivered</i> attribute [attribute ID <b>0x030F</b>].
     * <p>
     * The OperatingTariffLabelDelivered attribute is the meters version of the
     * TariffLabel attribute that is found within the Tariff Information attribute set of the
     * Price Cluster. It is used to identify the current consumption tariff operating on the
     * meter. The attribute is a ZCL Octet String field capable of storing a 24 character string
     * (the first Octet indicates length) encoded in UTF-8 format.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setOperatingTariffLabelDeliveredReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_OPERATINGTARIFFLABELDELIVERED), minInterval, maxInterval);
    }

    /**
     * Get the <i>Operating Tariff Label Received</i> attribute [attribute ID <b>0x0310</b>].
     * <p>
     * The OperatingTariffLabelReceived attribute is the meters version of the
     * ReceivedTariffLabel attribute that is found within the Tariff Information attribute
     * set of the Price Cluster. It is used to identify the current generation tariff operating
     * on the meter. The attribute is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getOperatingTariffLabelReceivedAsync() {
        return read(attributes.get(ATTR_OPERATINGTARIFFLABELRECEIVED));
    }

    /**
     * Synchronously get the <i>Operating Tariff Label Received</i> attribute [attribute ID <b>0x0310</b>].
     * <p>
     * The OperatingTariffLabelReceived attribute is the meters version of the
     * ReceivedTariffLabel attribute that is found within the Tariff Information attribute
     * set of the Price Cluster. It is used to identify the current generation tariff operating
     * on the meter. The attribute is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link ByteArray} attribute value, or null on error
     */
    public ByteArray getOperatingTariffLabelReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_OPERATINGTARIFFLABELRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (ByteArray) attributes.get(ATTR_OPERATINGTARIFFLABELRECEIVED).getLastValue();
        }

        return (ByteArray) readSync(attributes.get(ATTR_OPERATINGTARIFFLABELRECEIVED));
    }

    /**
     * Set reporting for the <i>Operating Tariff Label Received</i> attribute [attribute ID <b>0x0310</b>].
     * <p>
     * The OperatingTariffLabelReceived attribute is the meters version of the
     * ReceivedTariffLabel attribute that is found within the Tariff Information attribute
     * set of the Price Cluster. It is used to identify the current generation tariff operating
     * on the meter. The attribute is a ZCL Octet String field capable of storing a 24 character
     * string (the first Octet indicates length) encoded in UTF-8 format.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setOperatingTariffLabelReceivedReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_OPERATINGTARIFFLABELRECEIVED), minInterval, maxInterval);
    }

    /**
     * Get the <i>Customer ID Number</i> attribute [attribute ID <b>0x0311</b>].
     * <p>
     * The CustomerIDNumber attribute provides a customer identification which may be used
     * to confirm the customer at the premises. The attribute is a ZCL Octet String field
     * capable of storing a 24 character string (not including the first Octet which indicates
     * length) encoded in UTF-8 format.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCustomerIdNumberAsync() {
        return read(attributes.get(ATTR_CUSTOMERIDNUMBER));
    }

    /**
     * Synchronously get the <i>Customer ID Number</i> attribute [attribute ID <b>0x0311</b>].
     * <p>
     * The CustomerIDNumber attribute provides a customer identification which may be used
     * to confirm the customer at the premises. The attribute is a ZCL Octet String field
     * capable of storing a 24 character string (not including the first Octet which indicates
     * length) encoded in UTF-8 format.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link ByteArray} attribute value, or null on error
     */
    public ByteArray getCustomerIdNumber(final long refreshPeriod) {
        if (attributes.get(ATTR_CUSTOMERIDNUMBER).isLastValueCurrent(refreshPeriod)) {
            return (ByteArray) attributes.get(ATTR_CUSTOMERIDNUMBER).getLastValue();
        }

        return (ByteArray) readSync(attributes.get(ATTR_CUSTOMERIDNUMBER));
    }

    /**
     * Set reporting for the <i>Customer ID Number</i> attribute [attribute ID <b>0x0311</b>].
     * <p>
     * The CustomerIDNumber attribute provides a customer identification which may be used
     * to confirm the customer at the premises. The attribute is a ZCL Octet String field
     * capable of storing a 24 character string (not including the first Octet which indicates
     * length) encoded in UTF-8 format.
     * <p>
     * The attribute is of type {@link ByteArray}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCustomerIdNumberReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_CUSTOMERIDNUMBER), minInterval, maxInterval);
    }

    /**
     * Get the <i>Alternative Unit Of Measure</i> attribute [attribute ID <b>0x0312</b>].
     * <p>
     * Unless stated otherwise, the AlternativeUnitofMeasure attribute provides a base for
     * the attributes in the Alternative Historical Consumption attribute set.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getAlternativeUnitOfMeasureAsync() {
        return read(attributes.get(ATTR_ALTERNATIVEUNITOFMEASURE));
    }

    /**
     * Synchronously get the <i>Alternative Unit Of Measure</i> attribute [attribute ID <b>0x0312</b>].
     * <p>
     * Unless stated otherwise, the AlternativeUnitofMeasure attribute provides a base for
     * the attributes in the Alternative Historical Consumption attribute set.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getAlternativeUnitOfMeasure(final long refreshPeriod) {
        if (attributes.get(ATTR_ALTERNATIVEUNITOFMEASURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ALTERNATIVEUNITOFMEASURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ALTERNATIVEUNITOFMEASURE));
    }

    /**
     * Set reporting for the <i>Alternative Unit Of Measure</i> attribute [attribute ID <b>0x0312</b>].
     * <p>
     * Unless stated otherwise, the AlternativeUnitofMeasure attribute provides a base for
     * the attributes in the Alternative Historical Consumption attribute set.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setAlternativeUnitOfMeasureReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_ALTERNATIVEUNITOFMEASURE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Alternative Demand Formatting</i> attribute [attribute ID <b>0x0313</b>].
     * <p>
     * AlternativeDemandFormatting provides a method to properly decipher the number of
     * digits and the decimal location of the values found in the Alternative Demand-related
     * attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getAlternativeDemandFormattingAsync() {
        return read(attributes.get(ATTR_ALTERNATIVEDEMANDFORMATTING));
    }

    /**
     * Synchronously get the <i>Alternative Demand Formatting</i> attribute [attribute ID <b>0x0313</b>].
     * <p>
     * AlternativeDemandFormatting provides a method to properly decipher the number of
     * digits and the decimal location of the values found in the Alternative Demand-related
     * attributes.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getAlternativeDemandFormatting(final long refreshPeriod) {
        if (attributes.get(ATTR_ALTERNATIVEDEMANDFORMATTING).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ALTERNATIVEDEMANDFORMATTING).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ALTERNATIVEDEMANDFORMATTING));
    }

    /**
     * Set reporting for the <i>Alternative Demand Formatting</i> attribute [attribute ID <b>0x0313</b>].
     * <p>
     * AlternativeDemandFormatting provides a method to properly decipher the number of
     * digits and the decimal location of the values found in the Alternative Demand-related
     * attributes.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setAlternativeDemandFormattingReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_ALTERNATIVEDEMANDFORMATTING), minInterval, maxInterval);
    }

    /**
     * Get the <i>Alternative Consumption Formatting</i> attribute [attribute ID <b>0x0314</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getAlternativeConsumptionFormattingAsync() {
        return read(attributes.get(ATTR_ALTERNATIVECONSUMPTIONFORMATTING));
    }

    /**
     * Synchronously get the <i>Alternative Consumption Formatting</i> attribute [attribute ID <b>0x0314</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getAlternativeConsumptionFormatting(final long refreshPeriod) {
        if (attributes.get(ATTR_ALTERNATIVECONSUMPTIONFORMATTING).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ALTERNATIVECONSUMPTIONFORMATTING).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ALTERNATIVECONSUMPTIONFORMATTING));
    }

    /**
     * Set reporting for the <i>Alternative Consumption Formatting</i> attribute [attribute ID <b>0x0314</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setAlternativeConsumptionFormattingReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_ALTERNATIVECONSUMPTIONFORMATTING), minInterval, maxInterval);
    }

    /**
     * Get the <i>Instantaneous Demand</i> attribute [attribute ID <b>0x0400</b>].
     * <p>
     * InstantaneousDemand represents the current Demand of Energy, Gas, or Water delivered
     * or received at the premises. Positive values indicate demand delivered to the premises
     * where negative values indicate demand received from the premises.
     * InstantaneousDemand is updated continuously as new measurements are made. The
     * frequency of updates to this field is specific to the metering device, but should be
     * within the range of once every second to once every 5 seconds.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getInstantaneousDemandAsync() {
        return read(attributes.get(ATTR_INSTANTANEOUSDEMAND));
    }

    /**
     * Synchronously get the <i>Instantaneous Demand</i> attribute [attribute ID <b>0x0400</b>].
     * <p>
     * InstantaneousDemand represents the current Demand of Energy, Gas, or Water delivered
     * or received at the premises. Positive values indicate demand delivered to the premises
     * where negative values indicate demand received from the premises.
     * InstantaneousDemand is updated continuously as new measurements are made. The
     * frequency of updates to this field is specific to the metering device, but should be
     * within the range of once every second to once every 5 seconds.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getInstantaneousDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_INSTANTANEOUSDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_INSTANTANEOUSDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_INSTANTANEOUSDEMAND));
    }

    /**
     * Set reporting for the <i>Instantaneous Demand</i> attribute [attribute ID <b>0x0400</b>].
     * <p>
     * InstantaneousDemand represents the current Demand of Energy, Gas, or Water delivered
     * or received at the premises. Positive values indicate demand delivered to the premises
     * where negative values indicate demand received from the premises.
     * InstantaneousDemand is updated continuously as new measurements are made. The
     * frequency of updates to this field is specific to the metering device, but should be
     * within the range of once every second to once every 5 seconds.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setInstantaneousDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_INSTANTANEOUSDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Consumption Delivered</i> attribute [attribute ID <b>0x0401</b>].
     * <p>
     * CurrentDayConsumptionDelivered represents the summed value of Energy, Gas, or Water
     * delivered to the premises since the Historical Freeze Time (HFT). If optionally
     * provided, CurrentDayConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTDAYCONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Day Consumption Delivered</i> attribute [attribute ID <b>0x0401</b>].
     * <p>
     * CurrentDayConsumptionDelivered represents the summed value of Energy, Gas, or Water
     * delivered to the premises since the Historical Freeze Time (HFT). If optionally
     * provided, CurrentDayConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYCONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYCONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYCONSUMPTIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Day Consumption Delivered</i> attribute [attribute ID <b>0x0401</b>].
     * <p>
     * CurrentDayConsumptionDelivered represents the summed value of Energy, Gas, or Water
     * delivered to the premises since the Historical Freeze Time (HFT). If optionally
     * provided, CurrentDayConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayConsumptionDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYCONSUMPTIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Consumption Received</i> attribute [attribute ID <b>0x0402</b>].
     * <p>
     * CurrentDayConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises since the Historical Freeze Time (HFT). If optionally
     * provided, CurrentDayConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTDAYCONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Day Consumption Received</i> attribute [attribute ID <b>0x0402</b>].
     * <p>
     * CurrentDayConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises since the Historical Freeze Time (HFT). If optionally
     * provided, CurrentDayConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYCONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYCONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYCONSUMPTIONRECEIVED));
    }

    /**
     * Set reporting for the <i>Current Day Consumption Received</i> attribute [attribute ID <b>0x0402</b>].
     * <p>
     * CurrentDayConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises since the Historical Freeze Time (HFT). If optionally
     * provided, CurrentDayConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayConsumptionReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYCONSUMPTIONRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Consumption Delivered</i> attribute [attribute ID <b>0x0403</b>].
     * <p>
     * PreviousDayConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayConsumptionDelivered is updated every HFT. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Previous Day Consumption Delivered</i> attribute [attribute ID <b>0x0403</b>].
     * <p>
     * PreviousDayConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayConsumptionDelivered is updated every HFT. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Previous Day Consumption Delivered</i> attribute [attribute ID <b>0x0403</b>].
     * <p>
     * PreviousDayConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayConsumptionDelivered is updated every HFT. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayConsumptionDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Consumption Received</i> attribute [attribute ID <b>0x0404</b>].
     * <p>
     * PreviousDayConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayConsumptionReceived is updated every HFT. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Previous Day Consumption Received</i> attribute [attribute ID <b>0x0404</b>].
     * <p>
     * PreviousDayConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayConsumptionReceived is updated every HFT. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONRECEIVED));
    }

    /**
     * Set reporting for the <i>Previous Day Consumption Received</i> attribute [attribute ID <b>0x0404</b>].
     * <p>
     * PreviousDayConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayConsumptionReceived is updated every HFT. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayConsumptionReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYCONSUMPTIONRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Partial Profile Interval Start Time Delivered</i> attribute [attribute ID <b>0x0405</b>].
     * <p>
     * CurrentPartialProfileIntervalStartTimeDelivered represents the start time of the
     * current Load Profile interval being accumulated for commodity delivered.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentPartialProfileIntervalStartTimeDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMEDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Partial Profile Interval Start Time Delivered</i> attribute [attribute ID <b>0x0405</b>].
     * <p>
     * CurrentPartialProfileIntervalStartTimeDelivered represents the start time of the
     * current Load Profile interval being accumulated for commodity delivered.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getCurrentPartialProfileIntervalStartTimeDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMEDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMEDELIVERED).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMEDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Partial Profile Interval Start Time Delivered</i> attribute [attribute ID <b>0x0405</b>].
     * <p>
     * CurrentPartialProfileIntervalStartTimeDelivered represents the start time of the
     * current Load Profile interval being accumulated for commodity delivered.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentPartialProfileIntervalStartTimeDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMEDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Partial Profile Interval Start Time Received</i> attribute [attribute ID <b>0x0406</b>].
     * <p>
     * CurrentPartialProfileIntervalStartTimeReceived represents the start time of the
     * current Load Profile interval being accumulated for commodity received.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentPartialProfileIntervalStartTimeReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMERECEIVED));
    }

    /**
     * Synchronously get the <i>Current Partial Profile Interval Start Time Received</i> attribute [attribute ID <b>0x0406</b>].
     * <p>
     * CurrentPartialProfileIntervalStartTimeReceived represents the start time of the
     * current Load Profile interval being accumulated for commodity received.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getCurrentPartialProfileIntervalStartTimeReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMERECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMERECEIVED).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMERECEIVED));
    }

    /**
     * Set reporting for the <i>Current Partial Profile Interval Start Time Received</i> attribute [attribute ID <b>0x0406</b>].
     * <p>
     * CurrentPartialProfileIntervalStartTimeReceived represents the start time of the
     * current Load Profile interval being accumulated for commodity received.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentPartialProfileIntervalStartTimeReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALSTARTTIMERECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Partial Profile Interval Value Delivered</i> attribute [attribute ID <b>0x0407</b>].
     * <p>
     * CurrentPartialProfileIntervalValueDelivered represents the value of the current
     * Load Profile interval being accumulated for commodity delivered.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentPartialProfileIntervalValueDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUEDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Partial Profile Interval Value Delivered</i> attribute [attribute ID <b>0x0407</b>].
     * <p>
     * CurrentPartialProfileIntervalValueDelivered represents the value of the current
     * Load Profile interval being accumulated for commodity delivered.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentPartialProfileIntervalValueDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUEDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUEDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUEDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Partial Profile Interval Value Delivered</i> attribute [attribute ID <b>0x0407</b>].
     * <p>
     * CurrentPartialProfileIntervalValueDelivered represents the value of the current
     * Load Profile interval being accumulated for commodity delivered.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentPartialProfileIntervalValueDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUEDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Partial Profile Interval Value Received</i> attribute [attribute ID <b>0x0408</b>].
     * <p>
     * CurrentPartialProfileIntervalValueReceived represents the value of the current
     * Load Profile interval being accumulated for commodity received.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentPartialProfileIntervalValueReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUERECEIVED));
    }

    /**
     * Synchronously get the <i>Current Partial Profile Interval Value Received</i> attribute [attribute ID <b>0x0408</b>].
     * <p>
     * CurrentPartialProfileIntervalValueReceived represents the value of the current
     * Load Profile interval being accumulated for commodity received.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentPartialProfileIntervalValueReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUERECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUERECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUERECEIVED));
    }

    /**
     * Set reporting for the <i>Current Partial Profile Interval Value Received</i> attribute [attribute ID <b>0x0408</b>].
     * <p>
     * CurrentPartialProfileIntervalValueReceived represents the value of the current
     * Load Profile interval being accumulated for commodity received.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentPartialProfileIntervalValueReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTPARTIALPROFILEINTERVALVALUERECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Max Pressure</i> attribute [attribute ID <b>0x0409</b>].
     * <p>
     * CurrentDayMaxPressure is the maximum pressure reported during a day from the water or
     * gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayMaxPressureAsync() {
        return read(attributes.get(ATTR_CURRENTDAYMAXPRESSURE));
    }

    /**
     * Synchronously get the <i>Current Day Max Pressure</i> attribute [attribute ID <b>0x0409</b>].
     * <p>
     * CurrentDayMaxPressure is the maximum pressure reported during a day from the water or
     * gas meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayMaxPressure(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYMAXPRESSURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYMAXPRESSURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYMAXPRESSURE));
    }

    /**
     * Set reporting for the <i>Current Day Max Pressure</i> attribute [attribute ID <b>0x0409</b>].
     * <p>
     * CurrentDayMaxPressure is the maximum pressure reported during a day from the water or
     * gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayMaxPressureReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYMAXPRESSURE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Min Pressure</i> attribute [attribute ID <b>0x040A</b>].
     * <p>
     * CurrentDayMinPressure is the minimum pressure reported during a day from the water or
     * gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayMinPressureAsync() {
        return read(attributes.get(ATTR_CURRENTDAYMINPRESSURE));
    }

    /**
     * Synchronously get the <i>Current Day Min Pressure</i> attribute [attribute ID <b>0x040A</b>].
     * <p>
     * CurrentDayMinPressure is the minimum pressure reported during a day from the water or
     * gas meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayMinPressure(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYMINPRESSURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYMINPRESSURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYMINPRESSURE));
    }

    /**
     * Set reporting for the <i>Current Day Min Pressure</i> attribute [attribute ID <b>0x040A</b>].
     * <p>
     * CurrentDayMinPressure is the minimum pressure reported during a day from the water or
     * gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayMinPressureReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYMINPRESSURE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Max Pressure</i> attribute [attribute ID <b>0x040B</b>].
     * <p>
     * PreviousDayMaxPressure represents the maximum pressure reported during previous
     * day from the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayMaxPressureAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYMAXPRESSURE));
    }

    /**
     * Synchronously get the <i>Previous Day Max Pressure</i> attribute [attribute ID <b>0x040B</b>].
     * <p>
     * PreviousDayMaxPressure represents the maximum pressure reported during previous
     * day from the water or gas meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayMaxPressure(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYMAXPRESSURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYMAXPRESSURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYMAXPRESSURE));
    }

    /**
     * Set reporting for the <i>Previous Day Max Pressure</i> attribute [attribute ID <b>0x040B</b>].
     * <p>
     * PreviousDayMaxPressure represents the maximum pressure reported during previous
     * day from the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayMaxPressureReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYMAXPRESSURE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Min Pressure</i> attribute [attribute ID <b>0x040C</b>].
     * <p>
     * PreviousDayMinPressure represents the minimum pressure reported during previous
     * day from the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayMinPressureAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYMINPRESSURE));
    }

    /**
     * Synchronously get the <i>Previous Day Min Pressure</i> attribute [attribute ID <b>0x040C</b>].
     * <p>
     * PreviousDayMinPressure represents the minimum pressure reported during previous
     * day from the water or gas meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayMinPressure(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYMINPRESSURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYMINPRESSURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYMINPRESSURE));
    }

    /**
     * Set reporting for the <i>Previous Day Min Pressure</i> attribute [attribute ID <b>0x040C</b>].
     * <p>
     * PreviousDayMinPressure represents the minimum pressure reported during previous
     * day from the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayMinPressureReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYMINPRESSURE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Max Demand</i> attribute [attribute ID <b>0x040D</b>].
     * <p>
     * CurrentDayMaxDemand represents the maximum demand or rate of delivered value of
     * Energy, Gas, or Water being utilized at the premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayMaxDemandAsync() {
        return read(attributes.get(ATTR_CURRENTDAYMAXDEMAND));
    }

    /**
     * Synchronously get the <i>Current Day Max Demand</i> attribute [attribute ID <b>0x040D</b>].
     * <p>
     * CurrentDayMaxDemand represents the maximum demand or rate of delivered value of
     * Energy, Gas, or Water being utilized at the premises.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayMaxDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYMAXDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYMAXDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYMAXDEMAND));
    }

    /**
     * Set reporting for the <i>Current Day Max Demand</i> attribute [attribute ID <b>0x040D</b>].
     * <p>
     * CurrentDayMaxDemand represents the maximum demand or rate of delivered value of
     * Energy, Gas, or Water being utilized at the premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayMaxDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYMAXDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Max Demand</i> attribute [attribute ID <b>0x040E</b>].
     * <p>
     * PreviousDayMaxDemand represents the maximum demand or rate of delivered value of
     * Energy, Gas, or Water being utilized at the premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayMaxDemandAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYMAXDEMAND));
    }

    /**
     * Synchronously get the <i>Previous Day Max Demand</i> attribute [attribute ID <b>0x040E</b>].
     * <p>
     * PreviousDayMaxDemand represents the maximum demand or rate of delivered value of
     * Energy, Gas, or Water being utilized at the premises.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayMaxDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYMAXDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYMAXDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYMAXDEMAND));
    }

    /**
     * Set reporting for the <i>Previous Day Max Demand</i> attribute [attribute ID <b>0x040E</b>].
     * <p>
     * PreviousDayMaxDemand represents the maximum demand or rate of delivered value of
     * Energy, Gas, or Water being utilized at the premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayMaxDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYMAXDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Month Max Demand</i> attribute [attribute ID <b>0x040F</b>].
     * <p>
     * CurrentMonthMaxDemand is the maximum demand reported during a month from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMonthMaxDemandAsync() {
        return read(attributes.get(ATTR_CURRENTMONTHMAXDEMAND));
    }

    /**
     * Synchronously get the <i>Current Month Max Demand</i> attribute [attribute ID <b>0x040F</b>].
     * <p>
     * CurrentMonthMaxDemand is the maximum demand reported during a month from the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMonthMaxDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMONTHMAXDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMONTHMAXDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMONTHMAXDEMAND));
    }

    /**
     * Set reporting for the <i>Current Month Max Demand</i> attribute [attribute ID <b>0x040F</b>].
     * <p>
     * CurrentMonthMaxDemand is the maximum demand reported during a month from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMonthMaxDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMONTHMAXDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Year Max Demand</i> attribute [attribute ID <b>0x0410</b>].
     * <p>
     * CurrentYearMaxDemand is the maximum demand reported during a year from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentYearMaxDemandAsync() {
        return read(attributes.get(ATTR_CURRENTYEARMAXDEMAND));
    }

    /**
     * Synchronously get the <i>Current Year Max Demand</i> attribute [attribute ID <b>0x0410</b>].
     * <p>
     * CurrentYearMaxDemand is the maximum demand reported during a year from the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentYearMaxDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTYEARMAXDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTYEARMAXDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTYEARMAXDEMAND));
    }

    /**
     * Set reporting for the <i>Current Year Max Demand</i> attribute [attribute ID <b>0x0410</b>].
     * <p>
     * CurrentYearMaxDemand is the maximum demand reported during a year from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentYearMaxDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTYEARMAXDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0411</b>].
     * <p>
     * CurrentDayMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a day from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayMaxEnergyCarrierDemandAsync() {
        return read(attributes.get(ATTR_CURRENTDAYMAXENERGYCARRIERDEMAND));
    }

    /**
     * Synchronously get the <i>Current Day Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0411</b>].
     * <p>
     * CurrentDayMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a day from the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayMaxEnergyCarrierDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYMAXENERGYCARRIERDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYMAXENERGYCARRIERDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYMAXENERGYCARRIERDEMAND));
    }

    /**
     * Set reporting for the <i>Current Day Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0411</b>].
     * <p>
     * CurrentDayMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a day from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayMaxEnergyCarrierDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYMAXENERGYCARRIERDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0412</b>].
     * <p>
     * PreviousDayMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during the previous day from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayMaxEnergyCarrierDemandAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYMAXENERGYCARRIERDEMAND));
    }

    /**
     * Synchronously get the <i>Previous Day Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0412</b>].
     * <p>
     * PreviousDayMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during the previous day from the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayMaxEnergyCarrierDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYMAXENERGYCARRIERDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYMAXENERGYCARRIERDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYMAXENERGYCARRIERDEMAND));
    }

    /**
     * Set reporting for the <i>Previous Day Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0412</b>].
     * <p>
     * PreviousDayMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during the previous day from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayMaxEnergyCarrierDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYMAXENERGYCARRIERDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Month Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0413</b>].
     * <p>
     * CurrentMonthMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a month from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMonthMaxEnergyCarrierDemandAsync() {
        return read(attributes.get(ATTR_CURRENTMONTHMAXENERGYCARRIERDEMAND));
    }

    /**
     * Synchronously get the <i>Current Month Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0413</b>].
     * <p>
     * CurrentMonthMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a month from the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMonthMaxEnergyCarrierDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMONTHMAXENERGYCARRIERDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMONTHMAXENERGYCARRIERDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMONTHMAXENERGYCARRIERDEMAND));
    }

    /**
     * Set reporting for the <i>Current Month Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0413</b>].
     * <p>
     * CurrentMonthMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a month from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMonthMaxEnergyCarrierDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMONTHMAXENERGYCARRIERDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Month Min Energy Carrier Demand</i> attribute [attribute ID <b>0x0414</b>].
     * <p>
     * CurrentMonthMinEnergyCarrierDemand is the minimum energy carrier demand reported
     * during a month from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMonthMinEnergyCarrierDemandAsync() {
        return read(attributes.get(ATTR_CURRENTMONTHMINENERGYCARRIERDEMAND));
    }

    /**
     * Synchronously get the <i>Current Month Min Energy Carrier Demand</i> attribute [attribute ID <b>0x0414</b>].
     * <p>
     * CurrentMonthMinEnergyCarrierDemand is the minimum energy carrier demand reported
     * during a month from the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMonthMinEnergyCarrierDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMONTHMINENERGYCARRIERDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMONTHMINENERGYCARRIERDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMONTHMINENERGYCARRIERDEMAND));
    }

    /**
     * Set reporting for the <i>Current Month Min Energy Carrier Demand</i> attribute [attribute ID <b>0x0414</b>].
     * <p>
     * CurrentMonthMinEnergyCarrierDemand is the minimum energy carrier demand reported
     * during a month from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMonthMinEnergyCarrierDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMONTHMINENERGYCARRIERDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Year Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0415</b>].
     * <p>
     * CurrentYearMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a year from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentYearMaxEnergyCarrierDemandAsync() {
        return read(attributes.get(ATTR_CURRENTYEARMAXENERGYCARRIERDEMAND));
    }

    /**
     * Synchronously get the <i>Current Year Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0415</b>].
     * <p>
     * CurrentYearMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a year from the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentYearMaxEnergyCarrierDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTYEARMAXENERGYCARRIERDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTYEARMAXENERGYCARRIERDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTYEARMAXENERGYCARRIERDEMAND));
    }

    /**
     * Set reporting for the <i>Current Year Max Energy Carrier Demand</i> attribute [attribute ID <b>0x0415</b>].
     * <p>
     * CurrentYearMaxEnergyCarrierDemand is the maximum energy carrier demand reported
     * during a year from the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentYearMaxEnergyCarrierDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTYEARMAXENERGYCARRIERDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Year Min Energy Carrier Demand</i> attribute [attribute ID <b>0x0416</b>].
     * <p>
     * CurrentYearMinEnergyCarrierDemand is the minimum energy carrier demand reported
     * during a year from the heat meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentYearMinEnergyCarrierDemandAsync() {
        return read(attributes.get(ATTR_CURRENTYEARMINENERGYCARRIERDEMAND));
    }

    /**
     * Synchronously get the <i>Current Year Min Energy Carrier Demand</i> attribute [attribute ID <b>0x0416</b>].
     * <p>
     * CurrentYearMinEnergyCarrierDemand is the minimum energy carrier demand reported
     * during a year from the heat meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentYearMinEnergyCarrierDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTYEARMINENERGYCARRIERDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTYEARMINENERGYCARRIERDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTYEARMINENERGYCARRIERDEMAND));
    }

    /**
     * Set reporting for the <i>Current Year Min Energy Carrier Demand</i> attribute [attribute ID <b>0x0416</b>].
     * <p>
     * CurrentYearMinEnergyCarrierDemand is the minimum energy carrier demand reported
     * during a year from the heat meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentYearMinEnergyCarrierDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTYEARMINENERGYCARRIERDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0420</b>].
     * <p>
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 9)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayConsumptionDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 2 || arrayOffset > 9) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Day {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0420</b>].
     * <p>
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 9)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayConsumptionDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Day {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0420</b>].
     * <p>
     * PreviousDayNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 9)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDay2ConsumptionDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONDELIVERED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day {{count}} Consumption Received</i> attribute [attribute ID <b>0x0421</b>].
     * <p>
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 9)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayConsumptionReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 2 || arrayOffset > 9) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Day {{count}} Consumption Received</i> attribute [attribute ID <b>0x0421</b>].
     * <p>
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 9)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayConsumptionReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Day {{count}} Consumption Received</i> attribute [attribute ID <b>0x0421</b>].
     * <p>
     * PreviousDayNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous 24 hour period starting at the
     * Historical Freeze Time (HFT). If the optional HFT attribute is not available, default
     * to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 9)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDay2ConsumptionReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAY2CONSUMPTIONRECEIVED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Week Consumption Delivered</i> attribute [attribute ID <b>0x0430</b>].
     * <p>
     * CurrentWeekConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises since the Historical Freeze Time (HFT) on Monday to the
     * last HFT read. If optionally provided, CurrentWeekConsumptionDelivered is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentWeekConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTWEEKCONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Week Consumption Delivered</i> attribute [attribute ID <b>0x0430</b>].
     * <p>
     * CurrentWeekConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises since the Historical Freeze Time (HFT) on Monday to the
     * last HFT read. If optionally provided, CurrentWeekConsumptionDelivered is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentWeekConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTWEEKCONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTWEEKCONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTWEEKCONSUMPTIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Week Consumption Delivered</i> attribute [attribute ID <b>0x0430</b>].
     * <p>
     * CurrentWeekConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises since the Historical Freeze Time (HFT) on Monday to the
     * last HFT read. If optionally provided, CurrentWeekConsumptionDelivered is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentWeekConsumptionDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTWEEKCONSUMPTIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Week Consumption Received</i> attribute [attribute ID <b>0x0431</b>].
     * <p>
     * CurrentWeekConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises since the Historical Freeze Time (HFT) on Monday to the last
     * HFT read. If optionally provided, CurrentWeekConsumptionReceived is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentWeekConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTWEEKCONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Week Consumption Received</i> attribute [attribute ID <b>0x0431</b>].
     * <p>
     * CurrentWeekConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises since the Historical Freeze Time (HFT) on Monday to the last
     * HFT read. If optionally provided, CurrentWeekConsumptionReceived is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentWeekConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTWEEKCONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTWEEKCONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTWEEKCONSUMPTIONRECEIVED));
    }

    /**
     * Set reporting for the <i>Current Week Consumption Received</i> attribute [attribute ID <b>0x0431</b>].
     * <p>
     * CurrentWeekConsumptionReceived represents the summed value of Energy, Gas, or Water
     * received from the premises since the Historical Freeze Time (HFT) on Monday to the last
     * HFT read. If optionally provided, CurrentWeekConsumptionReceived is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentWeekConsumptionReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTWEEKCONSUMPTIONRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Week {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0432</b>].
     * <p>
     * PreviousWeekNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousWeekConsumptionDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 5) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Week {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0432</b>].
     * <p>
     * PreviousWeekNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousWeekConsumptionDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Week {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0432</b>].
     * <p>
     * PreviousWeekNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousWeek1ConsumptionDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONDELIVERED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Week {{count}} Consumption Received</i> attribute [attribute ID <b>0x0433</b>].
     * <p>
     * PreviousWeekNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousWeekConsumptionReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 5) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Week {{count}} Consumption Received</i> attribute [attribute ID <b>0x0433</b>].
     * <p>
     * PreviousWeekNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousWeekConsumptionReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Week {{count}} Consumption Received</i> attribute [attribute ID <b>0x0433</b>].
     * <p>
     * PreviousWeekNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous week period starting at the
     * Historical Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute
     * is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousWeek1ConsumptionReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSWEEK1CONSUMPTIONRECEIVED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Month Consumption Delivered</i> attribute [attribute ID <b>0x0440</b>].
     * <p>
     * CurrentMonthConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises since the Historical Freeze Time (HFT) on the 1st of the
     * month to the last HFT read. If optionally provided,
     * CurrentMonthConsumptionDelivered is updated continuously as new measurements are
     * made. If the optional HFT attribute is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMonthConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTMONTHCONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Month Consumption Delivered</i> attribute [attribute ID <b>0x0440</b>].
     * <p>
     * CurrentMonthConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises since the Historical Freeze Time (HFT) on the 1st of the
     * month to the last HFT read. If optionally provided,
     * CurrentMonthConsumptionDelivered is updated continuously as new measurements are
     * made. If the optional HFT attribute is not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMonthConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMONTHCONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMONTHCONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMONTHCONSUMPTIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Month Consumption Delivered</i> attribute [attribute ID <b>0x0440</b>].
     * <p>
     * CurrentMonthConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises since the Historical Freeze Time (HFT) on the 1st of the
     * month to the last HFT read. If optionally provided,
     * CurrentMonthConsumptionDelivered is updated continuously as new measurements are
     * made. If the optional HFT attribute is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMonthConsumptionDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMONTHCONSUMPTIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Month Consumption Received</i> attribute [attribute ID <b>0x0441</b>].
     * <p>
     * CurrentMonthConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises since the Historical Freeze Time (HFT) on the 1st of the
     * month to the last HFT read. If optionally provided, CurrentMonthConsumptionReceived
     * is updated continuously as new measurements are made. If the optional HFT attribute is
     * not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMonthConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTMONTHCONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Month Consumption Received</i> attribute [attribute ID <b>0x0441</b>].
     * <p>
     * CurrentMonthConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises since the Historical Freeze Time (HFT) on the 1st of the
     * month to the last HFT read. If optionally provided, CurrentMonthConsumptionReceived
     * is updated continuously as new measurements are made. If the optional HFT attribute is
     * not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMonthConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMONTHCONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMONTHCONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMONTHCONSUMPTIONRECEIVED));
    }

    /**
     * Set reporting for the <i>Current Month Consumption Received</i> attribute [attribute ID <b>0x0441</b>].
     * <p>
     * CurrentMonthConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises since the Historical Freeze Time (HFT) on the 1st of the
     * month to the last HFT read. If optionally provided, CurrentMonthConsumptionReceived
     * is updated continuously as new measurements are made. If the optional HFT attribute is
     * not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMonthConsumptionReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMONTHCONSUMPTIONRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Month {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0442</b>].
     * <p>
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousMonthConsumptionDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 13) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Month {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0442</b>].
     * <p>
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousMonthConsumptionDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Month {{count}} Consumption Delivered</i> attribute [attribute ID <b>0x0442</b>].
     * <p>
     * PreviousMonthNConsumptionDelivered represents the summed value of Energy, Gas, or
     * Water delivered to the premises within the previous Month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousMonth1ConsumptionDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONDELIVERED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Month {{count}} Consumption Received</i> attribute [attribute ID <b>0x0443</b>].
     * <p>
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousMonthConsumptionReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 13) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Month {{count}} Consumption Received</i> attribute [attribute ID <b>0x0443</b>].
     * <p>
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousMonthConsumptionReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Month {{count}} Consumption Received</i> attribute [attribute ID <b>0x0443</b>].
     * <p>
     * PreviousMonthNConsumptionReceived represents the summed value of Energy, Gas, or
     * Water received from the premises within the previous month period starting at the
     * Historical Freeze Time (HFT) on the 1st of the month to the last day of the month. If the
     * optional HFT attribute is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousMonth1ConsumptionReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSMONTH1CONSUMPTIONRECEIVED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Historical Freeze Time</i> attribute [attribute ID <b>0x045C</b>].
     * <p>
     * HistoricalFreezeTime (HFT) represents the time of day, in Local Time, when Historical
     * Consumption attributes and/or Alternative Historical Consumption attributes are
     * captured. HistoricalFreezeTime is an unsigned 16-bit value representing the hour and
     * minutes for HFT.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getHistoricalFreezeTimeAsync() {
        return read(attributes.get(ATTR_HISTORICALFREEZETIME));
    }

    /**
     * Synchronously get the <i>Historical Freeze Time</i> attribute [attribute ID <b>0x045C</b>].
     * <p>
     * HistoricalFreezeTime (HFT) represents the time of day, in Local Time, when Historical
     * Consumption attributes and/or Alternative Historical Consumption attributes are
     * captured. HistoricalFreezeTime is an unsigned 16-bit value representing the hour and
     * minutes for HFT.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getHistoricalFreezeTime(final long refreshPeriod) {
        if (attributes.get(ATTR_HISTORICALFREEZETIME).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_HISTORICALFREEZETIME).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_HISTORICALFREEZETIME));
    }

    /**
     * Set reporting for the <i>Historical Freeze Time</i> attribute [attribute ID <b>0x045C</b>].
     * <p>
     * HistoricalFreezeTime (HFT) represents the time of day, in Local Time, when Historical
     * Consumption attributes and/or Alternative Historical Consumption attributes are
     * captured. HistoricalFreezeTime is an unsigned 16-bit value representing the hour and
     * minutes for HFT.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setHistoricalFreezeTimeReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_HISTORICALFREEZETIME), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Max Number Of Periods Delivered</i> attribute [attribute ID <b>0x0500</b>].
     * <p>
     * MaxNumberofPeriodsDelivered represents the maximum number of intervals the device
     * is capable of returning in one Get Profile Response command. It is required
     * MaxNumberofPeriodsDelivered fit within the default Fragmentation ASDU size of 128
     * bytes, or an optionally agreed upon larger Fragmentation ASDU size supported by both
     * devices.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getMaxNumberOfPeriodsDeliveredAsync() {
        return read(attributes.get(ATTR_MAXNUMBEROFPERIODSDELIVERED));
    }

    /**
     * Synchronously get the <i>Max Number Of Periods Delivered</i> attribute [attribute ID <b>0x0500</b>].
     * <p>
     * MaxNumberofPeriodsDelivered represents the maximum number of intervals the device
     * is capable of returning in one Get Profile Response command. It is required
     * MaxNumberofPeriodsDelivered fit within the default Fragmentation ASDU size of 128
     * bytes, or an optionally agreed upon larger Fragmentation ASDU size supported by both
     * devices.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getMaxNumberOfPeriodsDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_MAXNUMBEROFPERIODSDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_MAXNUMBEROFPERIODSDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_MAXNUMBEROFPERIODSDELIVERED));
    }

    /**
     * Set reporting for the <i>Max Number Of Periods Delivered</i> attribute [attribute ID <b>0x0500</b>].
     * <p>
     * MaxNumberofPeriodsDelivered represents the maximum number of intervals the device
     * is capable of returning in one Get Profile Response command. It is required
     * MaxNumberofPeriodsDelivered fit within the default Fragmentation ASDU size of 128
     * bytes, or an optionally agreed upon larger Fragmentation ASDU size supported by both
     * devices.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setMaxNumberOfPeriodsDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_MAXNUMBEROFPERIODSDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Demand Delivered</i> attribute [attribute ID <b>0x0600</b>].
     * <p>
     * CurrentDemandDelivered represents the current Demand of Energy, Gas, or Water
     * delivered at the premises. CurrentDemandDelivered may be continuously updated as new
     * measurements are acquired, but at a minimum CurrentDemandDelivered must be updated at
     * the end of each integration sub- period, which can be obtained by dividing the
     * DemandIntegrationPeriod by the NumberOfDemandSubintervals.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDemandDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTDEMANDDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Demand Delivered</i> attribute [attribute ID <b>0x0600</b>].
     * <p>
     * CurrentDemandDelivered represents the current Demand of Energy, Gas, or Water
     * delivered at the premises. CurrentDemandDelivered may be continuously updated as new
     * measurements are acquired, but at a minimum CurrentDemandDelivered must be updated at
     * the end of each integration sub- period, which can be obtained by dividing the
     * DemandIntegrationPeriod by the NumberOfDemandSubintervals.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDemandDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDEMANDDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDEMANDDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDEMANDDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Demand Delivered</i> attribute [attribute ID <b>0x0600</b>].
     * <p>
     * CurrentDemandDelivered represents the current Demand of Energy, Gas, or Water
     * delivered at the premises. CurrentDemandDelivered may be continuously updated as new
     * measurements are acquired, but at a minimum CurrentDemandDelivered must be updated at
     * the end of each integration sub- period, which can be obtained by dividing the
     * DemandIntegrationPeriod by the NumberOfDemandSubintervals.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDemandDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDEMANDDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Demand Limit</i> attribute [attribute ID <b>0x0601</b>].
     * <p>
     * DemandLimit reflects the current supply demand limit set in the meter. This value can be
     * compared to the CurrentDemandDelivered attribute to understand if limits are being
     * approached or exceeded.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDemandLimitAsync() {
        return read(attributes.get(ATTR_DEMANDLIMIT));
    }

    /**
     * Synchronously get the <i>Demand Limit</i> attribute [attribute ID <b>0x0601</b>].
     * <p>
     * DemandLimit reflects the current supply demand limit set in the meter. This value can be
     * compared to the CurrentDemandDelivered attribute to understand if limits are being
     * approached or exceeded.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDemandLimit(final long refreshPeriod) {
        if (attributes.get(ATTR_DEMANDLIMIT).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DEMANDLIMIT).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DEMANDLIMIT));
    }

    /**
     * Set reporting for the <i>Demand Limit</i> attribute [attribute ID <b>0x0601</b>].
     * <p>
     * DemandLimit reflects the current supply demand limit set in the meter. This value can be
     * compared to the CurrentDemandDelivered attribute to understand if limits are being
     * approached or exceeded.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDemandLimitReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_DEMANDLIMIT), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Demand Integration Period</i> attribute [attribute ID <b>0x0602</b>].
     * <p>
     * DemandIntegrationPeriod is the number of minutes over which the
     * CurrentDemandDelivered attribute is calculated. Valid range is 0x01 to 0xFF. 0x00 is a
     * reserved value.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDemandIntegrationPeriodAsync() {
        return read(attributes.get(ATTR_DEMANDINTEGRATIONPERIOD));
    }

    /**
     * Synchronously get the <i>Demand Integration Period</i> attribute [attribute ID <b>0x0602</b>].
     * <p>
     * DemandIntegrationPeriod is the number of minutes over which the
     * CurrentDemandDelivered attribute is calculated. Valid range is 0x01 to 0xFF. 0x00 is a
     * reserved value.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDemandIntegrationPeriod(final long refreshPeriod) {
        if (attributes.get(ATTR_DEMANDINTEGRATIONPERIOD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DEMANDINTEGRATIONPERIOD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DEMANDINTEGRATIONPERIOD));
    }

    /**
     * Set reporting for the <i>Demand Integration Period</i> attribute [attribute ID <b>0x0602</b>].
     * <p>
     * DemandIntegrationPeriod is the number of minutes over which the
     * CurrentDemandDelivered attribute is calculated. Valid range is 0x01 to 0xFF. 0x00 is a
     * reserved value.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDemandIntegrationPeriodReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_DEMANDINTEGRATIONPERIOD), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Number Of Demand Subintervals</i> attribute [attribute ID <b>0x0603</b>].
     * <p>
     * NumberOfDemandSubintervals represents the number of subintervals used within the
     * DemandIntegrationPeriod. The subinterval duration (in minutes) is obtained by
     * dividing the DemandIntegrationPeriod by the NumberOfDemandSubintervals. The
     * CurrentDemandDelivered attribute is updated at the each of each subinterval. Valid
     * range is 0x01 to 0xFF. 0x00 is a reserved value.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNumberOfDemandSubintervalsAsync() {
        return read(attributes.get(ATTR_NUMBEROFDEMANDSUBINTERVALS));
    }

    /**
     * Synchronously get the <i>Number Of Demand Subintervals</i> attribute [attribute ID <b>0x0603</b>].
     * <p>
     * NumberOfDemandSubintervals represents the number of subintervals used within the
     * DemandIntegrationPeriod. The subinterval duration (in minutes) is obtained by
     * dividing the DemandIntegrationPeriod by the NumberOfDemandSubintervals. The
     * CurrentDemandDelivered attribute is updated at the each of each subinterval. Valid
     * range is 0x01 to 0xFF. 0x00 is a reserved value.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getNumberOfDemandSubintervals(final long refreshPeriod) {
        if (attributes.get(ATTR_NUMBEROFDEMANDSUBINTERVALS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_NUMBEROFDEMANDSUBINTERVALS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_NUMBEROFDEMANDSUBINTERVALS));
    }

    /**
     * Set reporting for the <i>Number Of Demand Subintervals</i> attribute [attribute ID <b>0x0603</b>].
     * <p>
     * NumberOfDemandSubintervals represents the number of subintervals used within the
     * DemandIntegrationPeriod. The subinterval duration (in minutes) is obtained by
     * dividing the DemandIntegrationPeriod by the NumberOfDemandSubintervals. The
     * CurrentDemandDelivered attribute is updated at the each of each subinterval. Valid
     * range is 0x01 to 0xFF. 0x00 is a reserved value.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setNumberOfDemandSubintervalsReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_NUMBEROFDEMANDSUBINTERVALS), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Demand Limit Arm Duration</i> attribute [attribute ID <b>0x0604</b>].
     * <p>
     * An unsigned 16-bit integer that defines the length of time, in seconds, that the supply
     * shall be disconnected if the DemandLimit attribute is enabled and the limit is
     * exceeded. At the end of the time period the meter shall move to the ARMED status. This will
     * allow the user to reconnect the supply.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getDemandLimitArmDurationAsync() {
        return read(attributes.get(ATTR_DEMANDLIMITARMDURATION));
    }

    /**
     * Synchronously get the <i>Demand Limit Arm Duration</i> attribute [attribute ID <b>0x0604</b>].
     * <p>
     * An unsigned 16-bit integer that defines the length of time, in seconds, that the supply
     * shall be disconnected if the DemandLimit attribute is enabled and the limit is
     * exceeded. At the end of the time period the meter shall move to the ARMED status. This will
     * allow the user to reconnect the supply.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getDemandLimitArmDuration(final long refreshPeriod) {
        if (attributes.get(ATTR_DEMANDLIMITARMDURATION).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_DEMANDLIMITARMDURATION).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_DEMANDLIMITARMDURATION));
    }

    /**
     * Set reporting for the <i>Demand Limit Arm Duration</i> attribute [attribute ID <b>0x0604</b>].
     * <p>
     * An unsigned 16-bit integer that defines the length of time, in seconds, that the supply
     * shall be disconnected if the DemandLimit attribute is enabled and the limit is
     * exceeded. At the end of the time period the meter shall move to the ARMED status. This will
     * allow the user to reconnect the supply.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setDemandLimitArmDurationReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_DEMANDLIMITARMDURATION), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Load Limit Supply State</i> attribute [attribute ID <b>0x0605</b>].
     * <p>
     * The LoadLimitSupplyState attribute indicates the required status of the supply once
     * device is in a load limit state.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getLoadLimitSupplyStateAsync() {
        return read(attributes.get(ATTR_LOADLIMITSUPPLYSTATE));
    }

    /**
     * Synchronously get the <i>Load Limit Supply State</i> attribute [attribute ID <b>0x0605</b>].
     * <p>
     * The LoadLimitSupplyState attribute indicates the required status of the supply once
     * device is in a load limit state.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getLoadLimitSupplyState(final long refreshPeriod) {
        if (attributes.get(ATTR_LOADLIMITSUPPLYSTATE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_LOADLIMITSUPPLYSTATE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_LOADLIMITSUPPLYSTATE));
    }

    /**
     * Set reporting for the <i>Load Limit Supply State</i> attribute [attribute ID <b>0x0605</b>].
     * <p>
     * The LoadLimitSupplyState attribute indicates the required status of the supply once
     * device is in a load limit state.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setLoadLimitSupplyStateReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_LOADLIMITSUPPLYSTATE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Load Limit Counter</i> attribute [attribute ID <b>0x0606</b>].
     * <p>
     * An unsigned 8-bit integer used for counting the number of times that the demand limit has
     * exceeded the set threshold.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getLoadLimitCounterAsync() {
        return read(attributes.get(ATTR_LOADLIMITCOUNTER));
    }

    /**
     * Synchronously get the <i>Load Limit Counter</i> attribute [attribute ID <b>0x0606</b>].
     * <p>
     * An unsigned 8-bit integer used for counting the number of times that the demand limit has
     * exceeded the set threshold.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getLoadLimitCounter(final long refreshPeriod) {
        if (attributes.get(ATTR_LOADLIMITCOUNTER).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_LOADLIMITCOUNTER).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_LOADLIMITCOUNTER));
    }

    /**
     * Set reporting for the <i>Load Limit Counter</i> attribute [attribute ID <b>0x0606</b>].
     * <p>
     * An unsigned 8-bit integer used for counting the number of times that the demand limit has
     * exceeded the set threshold.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setLoadLimitCounterReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_LOADLIMITCOUNTER), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Supply Tamper State</i> attribute [attribute ID <b>0x0607</b>].
     * <p>
     * The SupplyTamperState indicates the required status of the supply following the
     * detection of a tamper event within the metering device.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSupplyTamperStateAsync() {
        return read(attributes.get(ATTR_SUPPLYTAMPERSTATE));
    }

    /**
     * Synchronously get the <i>Supply Tamper State</i> attribute [attribute ID <b>0x0607</b>].
     * <p>
     * The SupplyTamperState indicates the required status of the supply following the
     * detection of a tamper event within the metering device.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getSupplyTamperState(final long refreshPeriod) {
        if (attributes.get(ATTR_SUPPLYTAMPERSTATE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_SUPPLYTAMPERSTATE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_SUPPLYTAMPERSTATE));
    }

    /**
     * Set reporting for the <i>Supply Tamper State</i> attribute [attribute ID <b>0x0607</b>].
     * <p>
     * The SupplyTamperState indicates the required status of the supply following the
     * detection of a tamper event within the metering device.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSupplyTamperStateReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_SUPPLYTAMPERSTATE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Supply Depletion State</i> attribute [attribute ID <b>0x0608</b>].
     * <p>
     * The SupplyDepletionState indicates the required status of the supply following
     * detection of a depleted battery within the metering device.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSupplyDepletionStateAsync() {
        return read(attributes.get(ATTR_SUPPLYDEPLETIONSTATE));
    }

    /**
     * Synchronously get the <i>Supply Depletion State</i> attribute [attribute ID <b>0x0608</b>].
     * <p>
     * The SupplyDepletionState indicates the required status of the supply following
     * detection of a depleted battery within the metering device.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getSupplyDepletionState(final long refreshPeriod) {
        if (attributes.get(ATTR_SUPPLYDEPLETIONSTATE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_SUPPLYDEPLETIONSTATE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_SUPPLYDEPLETIONSTATE));
    }

    /**
     * Set reporting for the <i>Supply Depletion State</i> attribute [attribute ID <b>0x0608</b>].
     * <p>
     * The SupplyDepletionState indicates the required status of the supply following
     * detection of a depleted battery within the metering device.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSupplyDepletionStateReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_SUPPLYDEPLETIONSTATE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Supply Uncontrolled Flow State</i> attribute [attribute ID <b>0x0609</b>].
     * <p>
     * The SupplyUncontrolledFlowState indicates the required status of the supply
     * following detection of an uncontrolled flow event within the metering device.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSupplyUncontrolledFlowStateAsync() {
        return read(attributes.get(ATTR_SUPPLYUNCONTROLLEDFLOWSTATE));
    }

    /**
     * Synchronously get the <i>Supply Uncontrolled Flow State</i> attribute [attribute ID <b>0x0609</b>].
     * <p>
     * The SupplyUncontrolledFlowState indicates the required status of the supply
     * following detection of an uncontrolled flow event within the metering device.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getSupplyUncontrolledFlowState(final long refreshPeriod) {
        if (attributes.get(ATTR_SUPPLYUNCONTROLLEDFLOWSTATE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_SUPPLYUNCONTROLLEDFLOWSTATE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_SUPPLYUNCONTROLLEDFLOWSTATE));
    }

    /**
     * Set reporting for the <i>Supply Uncontrolled Flow State</i> attribute [attribute ID <b>0x0609</b>].
     * <p>
     * The SupplyUncontrolledFlowState indicates the required status of the supply
     * following detection of an uncontrolled flow event within the metering device.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSupplyUncontrolledFlowStateReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_SUPPLYUNCONTROLLEDFLOWSTATE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Current No Tier Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0700</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentNoTierBlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current No Tier Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0700</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentNoTierBlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current No Tier Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0700</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentNoTierBlock1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 1 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0710</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier1BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 1 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0710</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier1BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 1 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0710</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier1Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 2 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0720</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier2BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 2 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0720</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier2BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 2 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0720</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier2Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 3 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0730</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier3BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 3 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0730</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier3BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 3 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0730</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier3Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 4 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0740</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier4BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 4 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0740</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier4BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 4 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0740</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier4Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 5 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0750</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier5BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 5 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0750</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier5BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 5 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0750</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier5Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 6 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0760</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier6BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 6 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0760</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier6BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 6 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0760</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier6Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 7 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0770</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier7BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 7 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0770</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier7BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 7 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0770</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier7Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 8 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0780</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier8BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 8 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0780</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier8BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 8 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0780</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier8Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 9 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0790</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier9BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 9 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0790</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier9BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 9 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x0790</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier9Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 10 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07A0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier10BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 10 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07A0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier10BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 10 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07A0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier10Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 11 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07B0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier11BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 11 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07B0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier11BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 11 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07B0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier11Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 12 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07C0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier12BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 12 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07C0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier12BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 12 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07C0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier12Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 13 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07D0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier13BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 13 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07D0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier13BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 13 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07D0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier13Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 14 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07E0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier14BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 14 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07E0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier14BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 14 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07E0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier14Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 15 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07F0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier15BlockSummationDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 15 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07F0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier15BlockSummationDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 15 Block {{count}} Summation Delivered</i> attribute [attribute ID <b>0x07F0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier15Block1SummationDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONDELIVERED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Set the <i>Generic Alarm Mask</i> attribute [attribute ID <b>0x0800</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param genericAlarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setGenericAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_GENERICALARMMASK), value);
    }

    /**
     * Get the <i>Generic Alarm Mask</i> attribute [attribute ID <b>0x0800</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getGenericAlarmMaskAsync() {
        return read(attributes.get(ATTR_GENERICALARMMASK));
    }

    /**
     * Synchronously get the <i>Generic Alarm Mask</i> attribute [attribute ID <b>0x0800</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getGenericAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_GENERICALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_GENERICALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_GENERICALARMMASK));
    }

    /**
     * Set the <i>Electricity Alarm Mask</i> attribute [attribute ID <b>0x0801</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param electricityAlarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setElectricityAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_ELECTRICITYALARMMASK), value);
    }

    /**
     * Get the <i>Electricity Alarm Mask</i> attribute [attribute ID <b>0x0801</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getElectricityAlarmMaskAsync() {
        return read(attributes.get(ATTR_ELECTRICITYALARMMASK));
    }

    /**
     * Synchronously get the <i>Electricity Alarm Mask</i> attribute [attribute ID <b>0x0801</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getElectricityAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_ELECTRICITYALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ELECTRICITYALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ELECTRICITYALARMMASK));
    }

    /**
     * Set the <i>Generic Flow /pressure Alarm Mask</i> attribute [attribute ID <b>0x0802</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param genericFlowPressureAlarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setGenericFlowPressureAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_GENERICFLOWPRESSUREALARMMASK), value);
    }

    /**
     * Get the <i>Generic Flow /pressure Alarm Mask</i> attribute [attribute ID <b>0x0802</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getGenericFlowPressureAlarmMaskAsync() {
        return read(attributes.get(ATTR_GENERICFLOWPRESSUREALARMMASK));
    }

    /**
     * Synchronously get the <i>Generic Flow /pressure Alarm Mask</i> attribute [attribute ID <b>0x0802</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getGenericFlowPressureAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_GENERICFLOWPRESSUREALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_GENERICFLOWPRESSUREALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_GENERICFLOWPRESSUREALARMMASK));
    }

    /**
     * Set the <i>Water Specific Alarm Mask</i> attribute [attribute ID <b>0x0803</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param waterSpecificAlarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setWaterSpecificAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_WATERSPECIFICALARMMASK), value);
    }

    /**
     * Get the <i>Water Specific Alarm Mask</i> attribute [attribute ID <b>0x0803</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getWaterSpecificAlarmMaskAsync() {
        return read(attributes.get(ATTR_WATERSPECIFICALARMMASK));
    }

    /**
     * Synchronously get the <i>Water Specific Alarm Mask</i> attribute [attribute ID <b>0x0803</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getWaterSpecificAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_WATERSPECIFICALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_WATERSPECIFICALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_WATERSPECIFICALARMMASK));
    }

    /**
     * Set the <i>Heat And Cooling Specific Alarm Mask</i> attribute [attribute ID <b>0x0804</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param heatAndCoolingSpecificAlarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setHeatAndCoolingSpecificAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_HEATANDCOOLINGSPECIFICALARMMASK), value);
    }

    /**
     * Get the <i>Heat And Cooling Specific Alarm Mask</i> attribute [attribute ID <b>0x0804</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getHeatAndCoolingSpecificAlarmMaskAsync() {
        return read(attributes.get(ATTR_HEATANDCOOLINGSPECIFICALARMMASK));
    }

    /**
     * Synchronously get the <i>Heat And Cooling Specific Alarm Mask</i> attribute [attribute ID <b>0x0804</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getHeatAndCoolingSpecificAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_HEATANDCOOLINGSPECIFICALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_HEATANDCOOLINGSPECIFICALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_HEATANDCOOLINGSPECIFICALARMMASK));
    }

    /**
     * Set the <i>Gas Specific Alarm Mask</i> attribute [attribute ID <b>0x0805</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param gasSpecificAlarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setGasSpecificAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_GASSPECIFICALARMMASK), value);
    }

    /**
     * Get the <i>Gas Specific Alarm Mask</i> attribute [attribute ID <b>0x0805</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getGasSpecificAlarmMaskAsync() {
        return read(attributes.get(ATTR_GASSPECIFICALARMMASK));
    }

    /**
     * Synchronously get the <i>Gas Specific Alarm Mask</i> attribute [attribute ID <b>0x0805</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getGasSpecificAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_GASSPECIFICALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_GASSPECIFICALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_GASSPECIFICALARMMASK));
    }

    /**
     * Set the <i>Extended Generic Alarm Mask</i> attribute [attribute ID <b>0x0806</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param extendedGenericAlarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setExtendedGenericAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_EXTENDEDGENERICALARMMASK), value);
    }

    /**
     * Get the <i>Extended Generic Alarm Mask</i> attribute [attribute ID <b>0x0806</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getExtendedGenericAlarmMaskAsync() {
        return read(attributes.get(ATTR_EXTENDEDGENERICALARMMASK));
    }

    /**
     * Synchronously get the <i>Extended Generic Alarm Mask</i> attribute [attribute ID <b>0x0806</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getExtendedGenericAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_EXTENDEDGENERICALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_EXTENDEDGENERICALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_EXTENDEDGENERICALARMMASK));
    }

    /**
     * Set the <i>Manufacture Alarm Mask</i> attribute [attribute ID <b>0x0807</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param manufactureAlarmMask the {@link Integer} attribute value to be set
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setManufactureAlarmMask(final Integer value) {
        return write(attributes.get(ATTR_MANUFACTUREALARMMASK), value);
    }

    /**
     * Get the <i>Manufacture Alarm Mask</i> attribute [attribute ID <b>0x0807</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getManufactureAlarmMaskAsync() {
        return read(attributes.get(ATTR_MANUFACTUREALARMMASK));
    }

    /**
     * Synchronously get the <i>Manufacture Alarm Mask</i> attribute [attribute ID <b>0x0807</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is OPTIONAL
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getManufactureAlarmMask(final long refreshPeriod) {
        if (attributes.get(ATTR_MANUFACTUREALARMMASK).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_MANUFACTUREALARMMASK).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_MANUFACTUREALARMMASK));
    }

    /**
     * Get the <i>Current No Tier Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0900</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentNoTierBlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current No Tier Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0900</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentNoTierBlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current No Tier Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0900</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentNoTierBlock1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTNOTIERBLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 1 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0910</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier1BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 1 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0910</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier1BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 1 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0910</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier1Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER1BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 2 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0920</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier2BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 2 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0920</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier2BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 2 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0920</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier2Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER2BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 3 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0930</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier3BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 3 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0930</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier3BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 3 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0930</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier3Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER3BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 4 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0940</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier4BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 4 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0940</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier4BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 4 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0940</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier4Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER4BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 5 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0950</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier5BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 5 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0950</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier5BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 5 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0950</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier5Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER5BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 6 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0960</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier6BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 6 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0960</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier6BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 6 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0960</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier6Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER6BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 7 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0970</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier7BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 7 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0970</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier7BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 7 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0970</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier7Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER7BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 8 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0980</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier8BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 8 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0980</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier8BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 8 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0980</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier8Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER8BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 9 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0990</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier9BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 9 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0990</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier9BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 9 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x0990</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier9Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER9BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 10 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09A0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier10BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 10 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09A0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier10BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 10 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09A0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier10Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER10BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 11 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09B0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier11BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 11 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09B0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier11BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 11 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09B0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier11Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER11BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 12 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09C0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier12BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 12 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09C0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier12BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 12 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09C0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier12Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER12BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 13 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09D0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier13BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 13 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09D0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier13BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 13 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09D0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier13Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER13BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 14 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09E0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier14BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 14 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09E0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier14BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 14 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09E0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier14Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER14BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Tier 15 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09F0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentTier15BlockSummationReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 16) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Current Tier 15 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09F0</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentTier15BlockSummationReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Current Tier 15 Block {{count}} Summation Received</i> attribute [attribute ID <b>0x09F0</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 16)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentTier15Block1SummationReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTTIER15BLOCK1SUMMATIONRECEIVED + arrayOffset - 1), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Bill To Date Delivered</i> attribute [attribute ID <b>0x0A00</b>].
     * <p>
     * BillToDateDelivered provides a value for the costs in the current billing period. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillDeliveredTrailingDigit attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getBillToDateDeliveredAsync() {
        return read(attributes.get(ATTR_BILLTODATEDELIVERED));
    }

    /**
     * Synchronously get the <i>Bill To Date Delivered</i> attribute [attribute ID <b>0x0A00</b>].
     * <p>
     * BillToDateDelivered provides a value for the costs in the current billing period. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillDeliveredTrailingDigit attribute.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getBillToDateDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_BILLTODATEDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_BILLTODATEDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_BILLTODATEDELIVERED));
    }

    /**
     * Set reporting for the <i>Bill To Date Delivered</i> attribute [attribute ID <b>0x0A00</b>].
     * <p>
     * BillToDateDelivered provides a value for the costs in the current billing period. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillDeliveredTrailingDigit attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setBillToDateDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_BILLTODATEDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Bill To Date Time Stamp Delivered</i> attribute [attribute ID <b>0x0A01</b>].
     * <p>
     * The UTC timestamp when the associated BillToDateDelivered attribute was last
     * updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getBillToDateTimeStampDeliveredAsync() {
        return read(attributes.get(ATTR_BILLTODATETIMESTAMPDELIVERED));
    }

    /**
     * Synchronously get the <i>Bill To Date Time Stamp Delivered</i> attribute [attribute ID <b>0x0A01</b>].
     * <p>
     * The UTC timestamp when the associated BillToDateDelivered attribute was last
     * updated.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getBillToDateTimeStampDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_BILLTODATETIMESTAMPDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_BILLTODATETIMESTAMPDELIVERED).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_BILLTODATETIMESTAMPDELIVERED));
    }

    /**
     * Set reporting for the <i>Bill To Date Time Stamp Delivered</i> attribute [attribute ID <b>0x0A01</b>].
     * <p>
     * The UTC timestamp when the associated BillToDateDelivered attribute was last
     * updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setBillToDateTimeStampDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_BILLTODATETIMESTAMPDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Projected Bill Delivered</i> attribute [attribute ID <b>0x0A02</b>].
     * <p>
     * ProjectedBillDelivered provides a value indicating what the estimated state of the
     * account will be at the end of the billing period based on past consumption. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillDeliveredTrailingDigit attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProjectedBillDeliveredAsync() {
        return read(attributes.get(ATTR_PROJECTEDBILLDELIVERED));
    }

    /**
     * Synchronously get the <i>Projected Bill Delivered</i> attribute [attribute ID <b>0x0A02</b>].
     * <p>
     * ProjectedBillDelivered provides a value indicating what the estimated state of the
     * account will be at the end of the billing period based on past consumption. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillDeliveredTrailingDigit attribute.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getProjectedBillDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_PROJECTEDBILLDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PROJECTEDBILLDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PROJECTEDBILLDELIVERED));
    }

    /**
     * Set reporting for the <i>Projected Bill Delivered</i> attribute [attribute ID <b>0x0A02</b>].
     * <p>
     * ProjectedBillDelivered provides a value indicating what the estimated state of the
     * account will be at the end of the billing period based on past consumption. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillDeliveredTrailingDigit attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setProjectedBillDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PROJECTEDBILLDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Projected Bill Time Stamp Delivered</i> attribute [attribute ID <b>0x0A03</b>].
     * <p>
     * The UTC timestamp when the associated ProjectedBillDelivered attribute was last
     * updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProjectedBillTimeStampDeliveredAsync() {
        return read(attributes.get(ATTR_PROJECTEDBILLTIMESTAMPDELIVERED));
    }

    /**
     * Synchronously get the <i>Projected Bill Time Stamp Delivered</i> attribute [attribute ID <b>0x0A03</b>].
     * <p>
     * The UTC timestamp when the associated ProjectedBillDelivered attribute was last
     * updated.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getProjectedBillTimeStampDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_PROJECTEDBILLTIMESTAMPDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_PROJECTEDBILLTIMESTAMPDELIVERED).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_PROJECTEDBILLTIMESTAMPDELIVERED));
    }

    /**
     * Set reporting for the <i>Projected Bill Time Stamp Delivered</i> attribute [attribute ID <b>0x0A03</b>].
     * <p>
     * The UTC timestamp when the associated ProjectedBillDelivered attribute was last
     * updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setProjectedBillTimeStampDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PROJECTEDBILLTIMESTAMPDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Bill Delivered Trailing Digit</i> attribute [attribute ID <b>0x0A04</b>].
     * <p>
     * An 8-bit BitMap used to determine where the decimal point is located in the
     * BillToDateDelivered and ProjectedBillDelivered attributes. The most significant
     * nibble indicates the number of digits to the right of the decimal point. The least
     * significant nibble is reserved and shall be 0. The BillDeliveredTrailingDigit
     * attribute represents the current active value.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getBillDeliveredTrailingDigitAsync() {
        return read(attributes.get(ATTR_BILLDELIVEREDTRAILINGDIGIT));
    }

    /**
     * Synchronously get the <i>Bill Delivered Trailing Digit</i> attribute [attribute ID <b>0x0A04</b>].
     * <p>
     * An 8-bit BitMap used to determine where the decimal point is located in the
     * BillToDateDelivered and ProjectedBillDelivered attributes. The most significant
     * nibble indicates the number of digits to the right of the decimal point. The least
     * significant nibble is reserved and shall be 0. The BillDeliveredTrailingDigit
     * attribute represents the current active value.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getBillDeliveredTrailingDigit(final long refreshPeriod) {
        if (attributes.get(ATTR_BILLDELIVEREDTRAILINGDIGIT).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_BILLDELIVEREDTRAILINGDIGIT).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_BILLDELIVEREDTRAILINGDIGIT));
    }

    /**
     * Set reporting for the <i>Bill Delivered Trailing Digit</i> attribute [attribute ID <b>0x0A04</b>].
     * <p>
     * An 8-bit BitMap used to determine where the decimal point is located in the
     * BillToDateDelivered and ProjectedBillDelivered attributes. The most significant
     * nibble indicates the number of digits to the right of the decimal point. The least
     * significant nibble is reserved and shall be 0. The BillDeliveredTrailingDigit
     * attribute represents the current active value.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setBillDeliveredTrailingDigitReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_BILLDELIVEREDTRAILINGDIGIT), minInterval, maxInterval);
    }

    /**
     * Get the <i>Bill To Date Received</i> attribute [attribute ID <b>0x0A10</b>].
     * <p>
     * BillToDateReceived provides a value for the costs in the current billing period. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillReceivedTrailingDigit attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getBillToDateReceivedAsync() {
        return read(attributes.get(ATTR_BILLTODATERECEIVED));
    }

    /**
     * Synchronously get the <i>Bill To Date Received</i> attribute [attribute ID <b>0x0A10</b>].
     * <p>
     * BillToDateReceived provides a value for the costs in the current billing period. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillReceivedTrailingDigit attribute.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getBillToDateReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_BILLTODATERECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_BILLTODATERECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_BILLTODATERECEIVED));
    }

    /**
     * Set reporting for the <i>Bill To Date Received</i> attribute [attribute ID <b>0x0A10</b>].
     * <p>
     * BillToDateReceived provides a value for the costs in the current billing period. This
     * attribute is measured in a base unit of Currency with the decimal point located as
     * indicated by the BillReceivedTrailingDigit attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setBillToDateReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_BILLTODATERECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Bill To Date Time Stamp Received</i> attribute [attribute ID <b>0x0A11</b>].
     * <p>
     * The UTC timestamp when the associated BillToDateReceived attribute was last updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getBillToDateTimeStampReceivedAsync() {
        return read(attributes.get(ATTR_BILLTODATETIMESTAMPRECEIVED));
    }

    /**
     * Synchronously get the <i>Bill To Date Time Stamp Received</i> attribute [attribute ID <b>0x0A11</b>].
     * <p>
     * The UTC timestamp when the associated BillToDateReceived attribute was last updated.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getBillToDateTimeStampReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_BILLTODATETIMESTAMPRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_BILLTODATETIMESTAMPRECEIVED).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_BILLTODATETIMESTAMPRECEIVED));
    }

    /**
     * Set reporting for the <i>Bill To Date Time Stamp Received</i> attribute [attribute ID <b>0x0A11</b>].
     * <p>
     * The UTC timestamp when the associated BillToDateReceived attribute was last updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setBillToDateTimeStampReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_BILLTODATETIMESTAMPRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Projected Bill Received</i> attribute [attribute ID <b>0x0A12</b>].
     * <p>
     * ProjectedBillReceived provides a value indicating what the estimated state of the
     * account will be at the end of the billing period based on past generation. This attribute
     * is measured in a base unit of Currency with the decimal point located as indicated by the
     * BillReceivedTrailingDigit attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProjectedBillReceivedAsync() {
        return read(attributes.get(ATTR_PROJECTEDBILLRECEIVED));
    }

    /**
     * Synchronously get the <i>Projected Bill Received</i> attribute [attribute ID <b>0x0A12</b>].
     * <p>
     * ProjectedBillReceived provides a value indicating what the estimated state of the
     * account will be at the end of the billing period based on past generation. This attribute
     * is measured in a base unit of Currency with the decimal point located as indicated by the
     * BillReceivedTrailingDigit attribute.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getProjectedBillReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_PROJECTEDBILLRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PROJECTEDBILLRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PROJECTEDBILLRECEIVED));
    }

    /**
     * Set reporting for the <i>Projected Bill Received</i> attribute [attribute ID <b>0x0A12</b>].
     * <p>
     * ProjectedBillReceived provides a value indicating what the estimated state of the
     * account will be at the end of the billing period based on past generation. This attribute
     * is measured in a base unit of Currency with the decimal point located as indicated by the
     * BillReceivedTrailingDigit attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setProjectedBillReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PROJECTEDBILLRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Projected Bill Time Stamp Received</i> attribute [attribute ID <b>0x0A13</b>].
     * <p>
     * The UTC timestamp when the associated ProjectedBillReceived attribute was last
     * updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProjectedBillTimeStampReceivedAsync() {
        return read(attributes.get(ATTR_PROJECTEDBILLTIMESTAMPRECEIVED));
    }

    /**
     * Synchronously get the <i>Projected Bill Time Stamp Received</i> attribute [attribute ID <b>0x0A13</b>].
     * <p>
     * The UTC timestamp when the associated ProjectedBillReceived attribute was last
     * updated.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getProjectedBillTimeStampReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_PROJECTEDBILLTIMESTAMPRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_PROJECTEDBILLTIMESTAMPRECEIVED).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_PROJECTEDBILLTIMESTAMPRECEIVED));
    }

    /**
     * Set reporting for the <i>Projected Bill Time Stamp Received</i> attribute [attribute ID <b>0x0A13</b>].
     * <p>
     * The UTC timestamp when the associated ProjectedBillReceived attribute was last
     * updated.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setProjectedBillTimeStampReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PROJECTEDBILLTIMESTAMPRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Bill Received Trailing Digit</i> attribute [attribute ID <b>0x0A14</b>].
     * <p>
     * An 8-bit BitMap used to determine where the decimal point is located in the
     * BillToDateReceived and ProjectedBillReceived attributes. The most significant
     * nibble indicates the number of digits to the right of the decimal point. The least
     * significant nibble is reserved and shall be 0. The BillReceivedTrailingDigit
     * attribute represents the current active value
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getBillReceivedTrailingDigitAsync() {
        return read(attributes.get(ATTR_BILLRECEIVEDTRAILINGDIGIT));
    }

    /**
     * Synchronously get the <i>Bill Received Trailing Digit</i> attribute [attribute ID <b>0x0A14</b>].
     * <p>
     * An 8-bit BitMap used to determine where the decimal point is located in the
     * BillToDateReceived and ProjectedBillReceived attributes. The most significant
     * nibble indicates the number of digits to the right of the decimal point. The least
     * significant nibble is reserved and shall be 0. The BillReceivedTrailingDigit
     * attribute represents the current active value
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getBillReceivedTrailingDigit(final long refreshPeriod) {
        if (attributes.get(ATTR_BILLRECEIVEDTRAILINGDIGIT).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_BILLRECEIVEDTRAILINGDIGIT).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_BILLRECEIVEDTRAILINGDIGIT));
    }

    /**
     * Set reporting for the <i>Bill Received Trailing Digit</i> attribute [attribute ID <b>0x0A14</b>].
     * <p>
     * An 8-bit BitMap used to determine where the decimal point is located in the
     * BillToDateReceived and ProjectedBillReceived attributes. The most significant
     * nibble indicates the number of digits to the right of the decimal point. The least
     * significant nibble is reserved and shall be 0. The BillReceivedTrailingDigit
     * attribute represents the current active value
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setBillReceivedTrailingDigitReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_BILLRECEIVEDTRAILINGDIGIT), minInterval, maxInterval);
    }

    /**
     * Get the <i>Proposed Change Supply Implementation Time</i> attribute [attribute ID <b>0x0B00</b>].
     * <p>
     * The ProposedChangeImplementationTime attribute indicates the time at which a
     * proposed change to the supply is to be implemented. If there is no change of supply
     * pending, this attribute will be set to 0xFFFFFFFF.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProposedChangeSupplyImplementationTimeAsync() {
        return read(attributes.get(ATTR_PROPOSEDCHANGESUPPLYIMPLEMENTATIONTIME));
    }

    /**
     * Synchronously get the <i>Proposed Change Supply Implementation Time</i> attribute [attribute ID <b>0x0B00</b>].
     * <p>
     * The ProposedChangeImplementationTime attribute indicates the time at which a
     * proposed change to the supply is to be implemented. If there is no change of supply
     * pending, this attribute will be set to 0xFFFFFFFF.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getProposedChangeSupplyImplementationTime(final long refreshPeriod) {
        if (attributes.get(ATTR_PROPOSEDCHANGESUPPLYIMPLEMENTATIONTIME).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_PROPOSEDCHANGESUPPLYIMPLEMENTATIONTIME).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_PROPOSEDCHANGESUPPLYIMPLEMENTATIONTIME));
    }

    /**
     * Set reporting for the <i>Proposed Change Supply Implementation Time</i> attribute [attribute ID <b>0x0B00</b>].
     * <p>
     * The ProposedChangeImplementationTime attribute indicates the time at which a
     * proposed change to the supply is to be implemented. If there is no change of supply
     * pending, this attribute will be set to 0xFFFFFFFF.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setProposedChangeSupplyImplementationTimeReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PROPOSEDCHANGESUPPLYIMPLEMENTATIONTIME), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Proposed Change Supply Status</i> attribute [attribute ID <b>0x0B01</b>].
     * <p>
     * The ProposedChangeSupplyStatus indicates the proposed status of the supply once the
     * change to the supply has be been implemented.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProposedChangeSupplyStatusAsync() {
        return read(attributes.get(ATTR_PROPOSEDCHANGESUPPLYSTATUS));
    }

    /**
     * Synchronously get the <i>Proposed Change Supply Status</i> attribute [attribute ID <b>0x0B01</b>].
     * <p>
     * The ProposedChangeSupplyStatus indicates the proposed status of the supply once the
     * change to the supply has be been implemented.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getProposedChangeSupplyStatus(final long refreshPeriod) {
        if (attributes.get(ATTR_PROPOSEDCHANGESUPPLYSTATUS).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PROPOSEDCHANGESUPPLYSTATUS).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PROPOSEDCHANGESUPPLYSTATUS));
    }

    /**
     * Set reporting for the <i>Proposed Change Supply Status</i> attribute [attribute ID <b>0x0B01</b>].
     * <p>
     * The ProposedChangeSupplyStatus indicates the proposed status of the supply once the
     * change to the supply has be been implemented.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setProposedChangeSupplyStatusReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_PROPOSEDCHANGESUPPLYSTATUS), minInterval, maxInterval);
    }

    /**
     * Get the <i>Uncontrolled Flow Threshold</i> attribute [attribute ID <b>0x0B10</b>].
     * <p>
     * The Uncontrolled Flow Threshold attribute indicates the threshold above which a flow
     * meter (e.g. Gas or Water) shall detect an uncontrolled flow. A value of 0x0000 indicates
     * the feature in unused.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getUncontrolledFlowThresholdAsync() {
        return read(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLD));
    }

    /**
     * Synchronously get the <i>Uncontrolled Flow Threshold</i> attribute [attribute ID <b>0x0B10</b>].
     * <p>
     * The Uncontrolled Flow Threshold attribute indicates the threshold above which a flow
     * meter (e.g. Gas or Water) shall detect an uncontrolled flow. A value of 0x0000 indicates
     * the feature in unused.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getUncontrolledFlowThreshold(final long refreshPeriod) {
        if (attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLD));
    }

    /**
     * Set reporting for the <i>Uncontrolled Flow Threshold</i> attribute [attribute ID <b>0x0B10</b>].
     * <p>
     * The Uncontrolled Flow Threshold attribute indicates the threshold above which a flow
     * meter (e.g. Gas or Water) shall detect an uncontrolled flow. A value of 0x0000 indicates
     * the feature in unused.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setUncontrolledFlowThresholdReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLD), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Uncontrolled Flow Threshold Unit Of Measure</i> attribute [attribute ID <b>0x0B11</b>].
     * <p>
     * The Uncontrolled Flow Threshold Unit of Measure attribute indicates the unit of
     * measure used in conjunction with the Uncontrolled Flow Threshold attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getUncontrolledFlowThresholdUnitOfMeasureAsync() {
        return read(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDUNITOFMEASURE));
    }

    /**
     * Synchronously get the <i>Uncontrolled Flow Threshold Unit Of Measure</i> attribute [attribute ID <b>0x0B11</b>].
     * <p>
     * The Uncontrolled Flow Threshold Unit of Measure attribute indicates the unit of
     * measure used in conjunction with the Uncontrolled Flow Threshold attribute.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getUncontrolledFlowThresholdUnitOfMeasure(final long refreshPeriod) {
        if (attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDUNITOFMEASURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDUNITOFMEASURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDUNITOFMEASURE));
    }

    /**
     * Set reporting for the <i>Uncontrolled Flow Threshold Unit Of Measure</i> attribute [attribute ID <b>0x0B11</b>].
     * <p>
     * The Uncontrolled Flow Threshold Unit of Measure attribute indicates the unit of
     * measure used in conjunction with the Uncontrolled Flow Threshold attribute.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setUncontrolledFlowThresholdUnitOfMeasureReporting(final int minInterval, final int maxInterval) {
        return setReporting(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDUNITOFMEASURE), minInterval, maxInterval);
    }

    /**
     * Get the <i>Uncontrolled Flow Threshold Multiplier</i> attribute [attribute ID <b>0x0B12</b>].
     * <p>
     * The Uncontrolled Flow Multiplier attribute indicates the multiplier, to be used in
     * conjunction with the Uncontrolled Flow Threshold and Uncontrolled Flow Divisor
     * attributes, to determine the true flow threshold value. A value of 0x0000 is not
     * allowed.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getUncontrolledFlowThresholdMultiplierAsync() {
        return read(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDMULTIPLIER));
    }

    /**
     * Synchronously get the <i>Uncontrolled Flow Threshold Multiplier</i> attribute [attribute ID <b>0x0B12</b>].
     * <p>
     * The Uncontrolled Flow Multiplier attribute indicates the multiplier, to be used in
     * conjunction with the Uncontrolled Flow Threshold and Uncontrolled Flow Divisor
     * attributes, to determine the true flow threshold value. A value of 0x0000 is not
     * allowed.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getUncontrolledFlowThresholdMultiplier(final long refreshPeriod) {
        if (attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDMULTIPLIER).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDMULTIPLIER).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDMULTIPLIER));
    }

    /**
     * Set reporting for the <i>Uncontrolled Flow Threshold Multiplier</i> attribute [attribute ID <b>0x0B12</b>].
     * <p>
     * The Uncontrolled Flow Multiplier attribute indicates the multiplier, to be used in
     * conjunction with the Uncontrolled Flow Threshold and Uncontrolled Flow Divisor
     * attributes, to determine the true flow threshold value. A value of 0x0000 is not
     * allowed.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setUncontrolledFlowThresholdMultiplierReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDMULTIPLIER), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Uncontrolled Flow Threshold Divisor</i> attribute [attribute ID <b>0x0B13</b>].
     * <p>
     * The Uncontrolled Flow Divisor attribute indicates the divisor, to be used in
     * conjunction with the Uncontrolled Flow Threshold and Uncontrolled Flow Multiplier
     * attributes, to determine the true flow threshold value. A value of 0x0000 is not
     * allowed.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getUncontrolledFlowThresholdDivisorAsync() {
        return read(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDDIVISOR));
    }

    /**
     * Synchronously get the <i>Uncontrolled Flow Threshold Divisor</i> attribute [attribute ID <b>0x0B13</b>].
     * <p>
     * The Uncontrolled Flow Divisor attribute indicates the divisor, to be used in
     * conjunction with the Uncontrolled Flow Threshold and Uncontrolled Flow Multiplier
     * attributes, to determine the true flow threshold value. A value of 0x0000 is not
     * allowed.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getUncontrolledFlowThresholdDivisor(final long refreshPeriod) {
        if (attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDDIVISOR).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDDIVISOR).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDDIVISOR));
    }

    /**
     * Set reporting for the <i>Uncontrolled Flow Threshold Divisor</i> attribute [attribute ID <b>0x0B13</b>].
     * <p>
     * The Uncontrolled Flow Divisor attribute indicates the divisor, to be used in
     * conjunction with the Uncontrolled Flow Threshold and Uncontrolled Flow Multiplier
     * attributes, to determine the true flow threshold value. A value of 0x0000 is not
     * allowed.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setUncontrolledFlowThresholdDivisorReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_UNCONTROLLEDFLOWTHRESHOLDDIVISOR), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Flow Stabilization Period</i> attribute [attribute ID <b>0x0B14</b>].
     * <p>
     * The Flow Stabilisation Period attribute indicates the time given to allow the flow to
     * stabilize. It is defined in units of tenths of a second.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getFlowStabilizationPeriodAsync() {
        return read(attributes.get(ATTR_FLOWSTABILIZATIONPERIOD));
    }

    /**
     * Synchronously get the <i>Flow Stabilization Period</i> attribute [attribute ID <b>0x0B14</b>].
     * <p>
     * The Flow Stabilisation Period attribute indicates the time given to allow the flow to
     * stabilize. It is defined in units of tenths of a second.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getFlowStabilizationPeriod(final long refreshPeriod) {
        if (attributes.get(ATTR_FLOWSTABILIZATIONPERIOD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_FLOWSTABILIZATIONPERIOD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_FLOWSTABILIZATIONPERIOD));
    }

    /**
     * Set reporting for the <i>Flow Stabilization Period</i> attribute [attribute ID <b>0x0B14</b>].
     * <p>
     * The Flow Stabilisation Period attribute indicates the time given to allow the flow to
     * stabilize. It is defined in units of tenths of a second.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setFlowStabilizationPeriodReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_FLOWSTABILIZATIONPERIOD), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Flow Measurement Period</i> attribute [attribute ID <b>0x0B15</b>].
     * <p>
     * The Flow Measurement Period attribute indicates the period over which the flow is
     * measured and compared against the Uncontrolled Flow Threshold attribute. It is
     * defined in units of 1 second.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getFlowMeasurementPeriodAsync() {
        return read(attributes.get(ATTR_FLOWMEASUREMENTPERIOD));
    }

    /**
     * Synchronously get the <i>Flow Measurement Period</i> attribute [attribute ID <b>0x0B15</b>].
     * <p>
     * The Flow Measurement Period attribute indicates the period over which the flow is
     * measured and compared against the Uncontrolled Flow Threshold attribute. It is
     * defined in units of 1 second.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getFlowMeasurementPeriod(final long refreshPeriod) {
        if (attributes.get(ATTR_FLOWMEASUREMENTPERIOD).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_FLOWMEASUREMENTPERIOD).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_FLOWMEASUREMENTPERIOD));
    }

    /**
     * Set reporting for the <i>Flow Measurement Period</i> attribute [attribute ID <b>0x0B15</b>].
     * <p>
     * The Flow Measurement Period attribute indicates the period over which the flow is
     * measured and compared against the Uncontrolled Flow Threshold attribute. It is
     * defined in units of 1 second.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setFlowMeasurementPeriodReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_FLOWMEASUREMENTPERIOD), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Alternative Instantaneous Demand</i> attribute [attribute ID <b>0x0C00</b>].
     * <p>
     * AlternativeInstantaneousDemand represents the current Demand delivered or
     * received at the premises. Positive values indicate demand delivered to the premises
     * where negative values indicate demand received from the premises.
     * AlternativeInstantaneousDemand is updated continuously as new measurements are
     * made. The frequency of updates to this field is specific to the metering device, but
     * should be within the range of once every second to once every 5 seconds.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getAlternativeInstantaneousDemandAsync() {
        return read(attributes.get(ATTR_ALTERNATIVEINSTANTANEOUSDEMAND));
    }

    /**
     * Synchronously get the <i>Alternative Instantaneous Demand</i> attribute [attribute ID <b>0x0C00</b>].
     * <p>
     * AlternativeInstantaneousDemand represents the current Demand delivered or
     * received at the premises. Positive values indicate demand delivered to the premises
     * where negative values indicate demand received from the premises.
     * AlternativeInstantaneousDemand is updated continuously as new measurements are
     * made. The frequency of updates to this field is specific to the metering device, but
     * should be within the range of once every second to once every 5 seconds.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getAlternativeInstantaneousDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_ALTERNATIVEINSTANTANEOUSDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_ALTERNATIVEINSTANTANEOUSDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_ALTERNATIVEINSTANTANEOUSDEMAND));
    }

    /**
     * Set reporting for the <i>Alternative Instantaneous Demand</i> attribute [attribute ID <b>0x0C00</b>].
     * <p>
     * AlternativeInstantaneousDemand represents the current Demand delivered or
     * received at the premises. Positive values indicate demand delivered to the premises
     * where negative values indicate demand received from the premises.
     * AlternativeInstantaneousDemand is updated continuously as new measurements are
     * made. The frequency of updates to this field is specific to the metering device, but
     * should be within the range of once every second to once every 5 seconds.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setAlternativeInstantaneousDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_ALTERNATIVEINSTANTANEOUSDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C01</b>].
     * <p>
     * CurrentDayAlternativeConsumptionDelivered represents the summed value delivered
     * to the premises since the Historical Freeze Time (HFT). If optionally provided,
     * CurrentDayAlternativeConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayAlternativeConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Day Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C01</b>].
     * <p>
     * CurrentDayAlternativeConsumptionDelivered represents the summed value delivered
     * to the premises since the Historical Freeze Time (HFT). If optionally provided,
     * CurrentDayAlternativeConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayAlternativeConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Day Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C01</b>].
     * <p>
     * CurrentDayAlternativeConsumptionDelivered represents the summed value delivered
     * to the premises since the Historical Freeze Time (HFT). If optionally provided,
     * CurrentDayAlternativeConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayAlternativeConsumptionDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Alternative Consumption Received</i> attribute [attribute ID <b>0x0C02</b>].
     * <p>
     * CurrentDayAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT). If optionally provided,
     * CurrentDayAlternativeConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayAlternativeConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Day Alternative Consumption Received</i> attribute [attribute ID <b>0x0C02</b>].
     * <p>
     * CurrentDayAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT). If optionally provided,
     * CurrentDayAlternativeConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayAlternativeConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONRECEIVED));
    }

    /**
     * Set reporting for the <i>Current Day Alternative Consumption Received</i> attribute [attribute ID <b>0x0C02</b>].
     * <p>
     * CurrentDayAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT). If optionally provided,
     * CurrentDayAlternativeConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayAlternativeConsumptionReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYALTERNATIVECONSUMPTIONRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C03</b>].
     * <p>
     * PreviousDayAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the
     * Alternative Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayAlternativeConsumptionDelivered is updated every HFT. If the optional
     * HFT attribute is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayAlternativeConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Previous Day Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C03</b>].
     * <p>
     * PreviousDayAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the
     * Alternative Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayAlternativeConsumptionDelivered is updated every HFT. If the optional
     * HFT attribute is not available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayAlternativeConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Previous Day Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C03</b>].
     * <p>
     * PreviousDayAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the
     * Alternative Historical Freeze Time (HFT). If optionally provided,
     * PreviousDayAlternativeConsumptionDelivered is updated every HFT. If the optional
     * HFT attribute is not available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayAlternativeConsumptionDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Alternative Consumption Received</i> attribute [attribute ID <b>0x0C04</b>].
     * <p>
     * PreviousDayAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If optionally provided, PreviousDayAlternativeConsumptionReceived is
     * updated every HFT. If the optional HFT attribute is not available, default to midnight
     * local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayAlternativeConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Previous Day Alternative Consumption Received</i> attribute [attribute ID <b>0x0C04</b>].
     * <p>
     * PreviousDayAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If optionally provided, PreviousDayAlternativeConsumptionReceived is
     * updated every HFT. If the optional HFT attribute is not available, default to midnight
     * local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayAlternativeConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONRECEIVED));
    }

    /**
     * Set reporting for the <i>Previous Day Alternative Consumption Received</i> attribute [attribute ID <b>0x0C04</b>].
     * <p>
     * PreviousDayAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If optionally provided, PreviousDayAlternativeConsumptionReceived is
     * updated every HFT. If the optional HFT attribute is not available, default to midnight
     * local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayAlternativeConsumptionReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYALTERNATIVECONSUMPTIONRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Alternative Partial Profile Interval Start Time Delivered</i> attribute [attribute ID <b>0x0C05</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalStartTimeDelivered represents the
     * start time of the current Load Profile interval being accumulated for commodity
     * delivered.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentAlternativePartialProfileIntervalStartTimeDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMEDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Alternative Partial Profile Interval Start Time Delivered</i> attribute [attribute ID <b>0x0C05</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalStartTimeDelivered represents the
     * start time of the current Load Profile interval being accumulated for commodity
     * delivered.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getCurrentAlternativePartialProfileIntervalStartTimeDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMEDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMEDELIVERED).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMEDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Alternative Partial Profile Interval Start Time Delivered</i> attribute [attribute ID <b>0x0C05</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalStartTimeDelivered represents the
     * start time of the current Load Profile interval being accumulated for commodity
     * delivered.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentAlternativePartialProfileIntervalStartTimeDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMEDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Alternative Partial Profile Interval Start Time Received</i> attribute [attribute ID <b>0x0C06</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalStartTimeReceived represents the
     * start time of the current Load Profile interval being accumulated for commodity
     * received.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentAlternativePartialProfileIntervalStartTimeReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMERECEIVED));
    }

    /**
     * Synchronously get the <i>Current Alternative Partial Profile Interval Start Time Received</i> attribute [attribute ID <b>0x0C06</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalStartTimeReceived represents the
     * start time of the current Load Profile interval being accumulated for commodity
     * received.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Calendar} attribute value, or null on error
     */
    public Calendar getCurrentAlternativePartialProfileIntervalStartTimeReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMERECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Calendar) attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMERECEIVED).getLastValue();
        }

        return (Calendar) readSync(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMERECEIVED));
    }

    /**
     * Set reporting for the <i>Current Alternative Partial Profile Interval Start Time Received</i> attribute [attribute ID <b>0x0C06</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalStartTimeReceived represents the
     * start time of the current Load Profile interval being accumulated for commodity
     * received.
     * <p>
     * The attribute is of type {@link Calendar}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentAlternativePartialProfileIntervalStartTimeReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALSTARTTIMERECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Alternative Partial Profile Interval Value Delivered</i> attribute [attribute ID <b>0x0C07</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalValueDelivered represents the value of
     * the current Load Profile interval being accumulated for commodity delivered.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentAlternativePartialProfileIntervalValueDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUEDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Alternative Partial Profile Interval Value Delivered</i> attribute [attribute ID <b>0x0C07</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalValueDelivered represents the value of
     * the current Load Profile interval being accumulated for commodity delivered.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentAlternativePartialProfileIntervalValueDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUEDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUEDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUEDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Alternative Partial Profile Interval Value Delivered</i> attribute [attribute ID <b>0x0C07</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalValueDelivered represents the value of
     * the current Load Profile interval being accumulated for commodity delivered.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentAlternativePartialProfileIntervalValueDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUEDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Alternative Partial Profile Interval Value Received</i> attribute [attribute ID <b>0x0C08</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalValueReceived represents the value of
     * the current Load Profile interval being accumulated for commodity received.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentAlternativePartialProfileIntervalValueReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUERECEIVED));
    }

    /**
     * Synchronously get the <i>Current Alternative Partial Profile Interval Value Received</i> attribute [attribute ID <b>0x0C08</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalValueReceived represents the value of
     * the current Load Profile interval being accumulated for commodity received.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentAlternativePartialProfileIntervalValueReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUERECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUERECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUERECEIVED));
    }

    /**
     * Set reporting for the <i>Current Alternative Partial Profile Interval Value Received</i> attribute [attribute ID <b>0x0C08</b>].
     * <p>
     * CurrentAlternativePartialProfileIntervalValueReceived represents the value of
     * the current Load Profile interval being accumulated for commodity received.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentAlternativePartialProfileIntervalValueReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTALTERNATIVEPARTIALPROFILEINTERVALVALUERECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Alternative Max Pressure</i> attribute [attribute ID <b>0x0C09</b>].
     * <p>
     * CurrentDayAlternativeMaxPressure is the maximum pressure reported during a day from
     * the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayAlternativeMaxPressureAsync() {
        return read(attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXPRESSURE));
    }

    /**
     * Synchronously get the <i>Current Day Alternative Max Pressure</i> attribute [attribute ID <b>0x0C09</b>].
     * <p>
     * CurrentDayAlternativeMaxPressure is the maximum pressure reported during a day from
     * the water or gas meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayAlternativeMaxPressure(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXPRESSURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXPRESSURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXPRESSURE));
    }

    /**
     * Set reporting for the <i>Current Day Alternative Max Pressure</i> attribute [attribute ID <b>0x0C09</b>].
     * <p>
     * CurrentDayAlternativeMaxPressure is the maximum pressure reported during a day from
     * the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayAlternativeMaxPressureReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXPRESSURE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Alternative Min Pressure</i> attribute [attribute ID <b>0x0C0A</b>].
     * <p>
     * CurrentDayAlternativeMinPressure is the minimum pressure reported during a day from
     * the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayAlternativeMinPressureAsync() {
        return read(attributes.get(ATTR_CURRENTDAYALTERNATIVEMINPRESSURE));
    }

    /**
     * Synchronously get the <i>Current Day Alternative Min Pressure</i> attribute [attribute ID <b>0x0C0A</b>].
     * <p>
     * CurrentDayAlternativeMinPressure is the minimum pressure reported during a day from
     * the water or gas meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayAlternativeMinPressure(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYALTERNATIVEMINPRESSURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYALTERNATIVEMINPRESSURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYALTERNATIVEMINPRESSURE));
    }

    /**
     * Set reporting for the <i>Current Day Alternative Min Pressure</i> attribute [attribute ID <b>0x0C0A</b>].
     * <p>
     * CurrentDayAlternativeMinPressure is the minimum pressure reported during a day from
     * the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayAlternativeMinPressureReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYALTERNATIVEMINPRESSURE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Alternative Max Pressure</i> attribute [attribute ID <b>0x0C0B</b>].
     * <p>
     * PreviousDayAlternativeMaxPressure represents the maximum pressure reported
     * during previous day from the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayAlternativeMaxPressureAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXPRESSURE));
    }

    /**
     * Synchronously get the <i>Previous Day Alternative Max Pressure</i> attribute [attribute ID <b>0x0C0B</b>].
     * <p>
     * PreviousDayAlternativeMaxPressure represents the maximum pressure reported
     * during previous day from the water or gas meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayAlternativeMaxPressure(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXPRESSURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXPRESSURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXPRESSURE));
    }

    /**
     * Set reporting for the <i>Previous Day Alternative Max Pressure</i> attribute [attribute ID <b>0x0C0B</b>].
     * <p>
     * PreviousDayAlternativeMaxPressure represents the maximum pressure reported
     * during previous day from the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayAlternativeMaxPressureReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXPRESSURE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Alternative Min Pressure</i> attribute [attribute ID <b>0x0C0C</b>].
     * <p>
     * PreviousDayAlternativeMinPressure represents the minimum pressure reported
     * during previous day from the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayAlternativeMinPressureAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMINPRESSURE));
    }

    /**
     * Synchronously get the <i>Previous Day Alternative Min Pressure</i> attribute [attribute ID <b>0x0C0C</b>].
     * <p>
     * PreviousDayAlternativeMinPressure represents the minimum pressure reported
     * during previous day from the water or gas meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayAlternativeMinPressure(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMINPRESSURE).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMINPRESSURE).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMINPRESSURE));
    }

    /**
     * Set reporting for the <i>Previous Day Alternative Min Pressure</i> attribute [attribute ID <b>0x0C0C</b>].
     * <p>
     * PreviousDayAlternativeMinPressure represents the minimum pressure reported
     * during previous day from the water or gas meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayAlternativeMinPressureReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMINPRESSURE), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Day Alternative Max Demand</i> attribute [attribute ID <b>0x0C0D</b>].
     * <p>
     * CurrentDayAlternativeMaxDemand represents the maximum demand or rate of delivered
     * value of Energy, Gas, or Water being utilized at the premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentDayAlternativeMaxDemandAsync() {
        return read(attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXDEMAND));
    }

    /**
     * Synchronously get the <i>Current Day Alternative Max Demand</i> attribute [attribute ID <b>0x0C0D</b>].
     * <p>
     * CurrentDayAlternativeMaxDemand represents the maximum demand or rate of delivered
     * value of Energy, Gas, or Water being utilized at the premises.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentDayAlternativeMaxDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXDEMAND));
    }

    /**
     * Set reporting for the <i>Current Day Alternative Max Demand</i> attribute [attribute ID <b>0x0C0D</b>].
     * <p>
     * CurrentDayAlternativeMaxDemand represents the maximum demand or rate of delivered
     * value of Energy, Gas, or Water being utilized at the premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentDayAlternativeMaxDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTDAYALTERNATIVEMAXDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day Alternative Max Demand</i> attribute [attribute ID <b>0x0C0E</b>].
     * <p>
     * PreviousDayAlternativeMaxDemand represents the maximum demand or rate of delivered
     * value of Energy, Gas, or Water being utilized at the premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayAlternativeMaxDemandAsync() {
        return read(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXDEMAND));
    }

    /**
     * Synchronously get the <i>Previous Day Alternative Max Demand</i> attribute [attribute ID <b>0x0C0E</b>].
     * <p>
     * PreviousDayAlternativeMaxDemand represents the maximum demand or rate of delivered
     * value of Energy, Gas, or Water being utilized at the premises.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayAlternativeMaxDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXDEMAND));
    }

    /**
     * Set reporting for the <i>Previous Day Alternative Max Demand</i> attribute [attribute ID <b>0x0C0E</b>].
     * <p>
     * PreviousDayAlternativeMaxDemand represents the maximum demand or rate of delivered
     * value of Energy, Gas, or Water being utilized at the premises.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDayAlternativeMaxDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAYALTERNATIVEMAXDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Month Alternative Max Demand</i> attribute [attribute ID <b>0x0C0F</b>].
     * <p>
     * CurrentMonthAlternativeMaxDemand is the maximum demand reported during a month from
     * the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMonthAlternativeMaxDemandAsync() {
        return read(attributes.get(ATTR_CURRENTMONTHALTERNATIVEMAXDEMAND));
    }

    /**
     * Synchronously get the <i>Current Month Alternative Max Demand</i> attribute [attribute ID <b>0x0C0F</b>].
     * <p>
     * CurrentMonthAlternativeMaxDemand is the maximum demand reported during a month from
     * the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMonthAlternativeMaxDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMONTHALTERNATIVEMAXDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMONTHALTERNATIVEMAXDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMONTHALTERNATIVEMAXDEMAND));
    }

    /**
     * Set reporting for the <i>Current Month Alternative Max Demand</i> attribute [attribute ID <b>0x0C0F</b>].
     * <p>
     * CurrentMonthAlternativeMaxDemand is the maximum demand reported during a month from
     * the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMonthAlternativeMaxDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMONTHALTERNATIVEMAXDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Year Alternative Max Demand</i> attribute [attribute ID <b>0x0C10</b>].
     * <p>
     * CurrentYearAlternativeMaxDemand is the maximum demand reported during a year from
     * the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentYearAlternativeMaxDemandAsync() {
        return read(attributes.get(ATTR_CURRENTYEARALTERNATIVEMAXDEMAND));
    }

    /**
     * Synchronously get the <i>Current Year Alternative Max Demand</i> attribute [attribute ID <b>0x0C10</b>].
     * <p>
     * CurrentYearAlternativeMaxDemand is the maximum demand reported during a year from
     * the meter.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentYearAlternativeMaxDemand(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTYEARALTERNATIVEMAXDEMAND).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTYEARALTERNATIVEMAXDEMAND).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTYEARALTERNATIVEMAXDEMAND));
    }

    /**
     * Set reporting for the <i>Current Year Alternative Max Demand</i> attribute [attribute ID <b>0x0C10</b>].
     * <p>
     * CurrentYearAlternativeMaxDemand is the maximum demand reported during a year from
     * the meter.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentYearAlternativeMaxDemandReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTYEARALTERNATIVEMAXDEMAND), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C20</b>].
     * <p>
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 7)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayAlternativeConsumptionDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 2 || arrayOffset > 7) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Day {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C20</b>].
     * <p>
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 7)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayAlternativeConsumptionDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Day {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C20</b>].
     * <p>
     * PreviousDayNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous 24 hour period starting at the Historical
     * Freeze Time (HFT). If the optional HFT attribute is not available, default to midnight
     * local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 7)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDay2AlternativeConsumptionDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONDELIVERED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Day {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C21</b>].
     * <p>
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 7)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousDayAlternativeConsumptionReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 2 || arrayOffset > 7) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Day {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C21</b>].
     * <p>
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 7)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousDayAlternativeConsumptionReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Day {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C21</b>].
     * <p>
     * PreviousDayNAlternativeConsumptionReceived represents the summed value received
     * from the premises within the previous 24 hour period starting at the Historical Freeze
     * Time (HFT). If the optional HFT attribute is not available, default to midnight local
     * time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (2 < arrayOffset < 7)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousDay2AlternativeConsumptionReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSDAY2ALTERNATIVECONSUMPTIONRECEIVED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Week Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C30</b>].
     * <p>
     * CurrentWeekAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises since the Historical Freeze Time (HFT) on Monday to the last
     * HFT read. If optionally provided, CurrentWeekAlternativeConsumptionDelivered is
     * updated continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentWeekAlternativeConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Week Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C30</b>].
     * <p>
     * CurrentWeekAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises since the Historical Freeze Time (HFT) on Monday to the last
     * HFT read. If optionally provided, CurrentWeekAlternativeConsumptionDelivered is
     * updated continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentWeekAlternativeConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Week Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C30</b>].
     * <p>
     * CurrentWeekAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises since the Historical Freeze Time (HFT) on Monday to the last
     * HFT read. If optionally provided, CurrentWeekAlternativeConsumptionDelivered is
     * updated continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentWeekAlternativeConsumptionDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Week Alternative Consumption Received</i> attribute [attribute ID <b>0x0C31</b>].
     * <p>
     * CurrentWeekAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT) on Monday to the last HFT read.
     * If optionally provided, CurrentWeekAlternativeConsumptionReceived is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentWeekAlternativeConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Week Alternative Consumption Received</i> attribute [attribute ID <b>0x0C31</b>].
     * <p>
     * CurrentWeekAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT) on Monday to the last HFT read.
     * If optionally provided, CurrentWeekAlternativeConsumptionReceived is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentWeekAlternativeConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONRECEIVED));
    }

    /**
     * Set reporting for the <i>Current Week Alternative Consumption Received</i> attribute [attribute ID <b>0x0C31</b>].
     * <p>
     * CurrentWeekAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT) on Monday to the last HFT read.
     * If optionally provided, CurrentWeekAlternativeConsumptionReceived is updated
     * continuously as new measurements are made. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentWeekAlternativeConsumptionReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTWEEKALTERNATIVECONSUMPTIONRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Week {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C32</b>].
     * <p>
     * PreviousWeekNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousWeekAlternativeConsumptionDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 5) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Week {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C32</b>].
     * <p>
     * PreviousWeekNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousWeekAlternativeConsumptionDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Week {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C32</b>].
     * <p>
     * PreviousWeekNAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousWeek1AlternativeConsumptionDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONDELIVERED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Week {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C33</b>].
     * <p>
     * PreviousWeekNAlternativeConsumptionReceived represents the summed value
     * received from the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousWeekAlternativeConsumptionReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 5) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Week {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C33</b>].
     * <p>
     * PreviousWeekNAlternativeConsumptionReceived represents the summed value
     * received from the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousWeekAlternativeConsumptionReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Week {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C33</b>].
     * <p>
     * PreviousWeekNAlternativeConsumptionReceived represents the summed value
     * received from the premises within the previous week period starting at the Historical
     * Freeze Time (HFT) on the Monday to the Sunday. If the optional HFT attribute is not
     * available, default to midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 5)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousWeek1AlternativeConsumptionReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSWEEK1ALTERNATIVECONSUMPTIONRECEIVED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Month Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C40</b>].
     * <p>
     * CurrentMonthAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises since the Historical Freeze Time (HFT) on the 1st of the month
     * to the last HFT read. If optionally provided,
     * CurrentMonthAlternativeConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMonthAlternativeConsumptionDeliveredAsync() {
        return read(attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONDELIVERED));
    }

    /**
     * Synchronously get the <i>Current Month Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C40</b>].
     * <p>
     * CurrentMonthAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises since the Historical Freeze Time (HFT) on the 1st of the month
     * to the last HFT read. If optionally provided,
     * CurrentMonthAlternativeConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMonthAlternativeConsumptionDelivered(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONDELIVERED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONDELIVERED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONDELIVERED));
    }

    /**
     * Set reporting for the <i>Current Month Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C40</b>].
     * <p>
     * CurrentMonthAlternativeConsumptionDelivered represents the summed value
     * delivered to the premises since the Historical Freeze Time (HFT) on the 1st of the month
     * to the last HFT read. If optionally provided,
     * CurrentMonthAlternativeConsumptionDelivered is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMonthAlternativeConsumptionDeliveredReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONDELIVERED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Current Month Alternative Consumption Received</i> attribute [attribute ID <b>0x0C41</b>].
     * <p>
     * CurrentMonthAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT) on the 1st of the month to the
     * last HFT read. If optionally provided,
     * CurrentMonthAlternativeConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getCurrentMonthAlternativeConsumptionReceivedAsync() {
        return read(attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONRECEIVED));
    }

    /**
     * Synchronously get the <i>Current Month Alternative Consumption Received</i> attribute [attribute ID <b>0x0C41</b>].
     * <p>
     * CurrentMonthAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT) on the 1st of the month to the
     * last HFT read. If optionally provided,
     * CurrentMonthAlternativeConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getCurrentMonthAlternativeConsumptionReceived(final long refreshPeriod) {
        if (attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONRECEIVED).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONRECEIVED).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONRECEIVED));
    }

    /**
     * Set reporting for the <i>Current Month Alternative Consumption Received</i> attribute [attribute ID <b>0x0C41</b>].
     * <p>
     * CurrentMonthAlternativeConsumptionReceived represents the summed value received
     * from the premises since the Historical Freeze Time (HFT) on the 1st of the month to the
     * last HFT read. If optionally provided,
     * CurrentMonthAlternativeConsumptionReceived is updated continuously as new
     * measurements are made. If the optional HFT attribute is not available, default to
     * midnight local time.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setCurrentMonthAlternativeConsumptionReceivedReporting(final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_CURRENTMONTHALTERNATIVECONSUMPTIONRECEIVED), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Month {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C42</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousMonthAlternativeConsumptionDeliveredAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 13) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Month {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C42</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousMonthAlternativeConsumptionDelivered(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONDELIVERED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Month {{count}} Alternative Consumption Delivered</i> attribute [attribute ID <b>0x0C42</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousMonth1AlternativeConsumptionDeliveredReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONDELIVERED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * Get the <i>Previous Month {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C43</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getPreviousMonthAlternativeConsumptionReceivedAsync(final int arrayOffset) {
        if (arrayOffset < 1 || arrayOffset > 13) {
            throw new IllegalArgumentException("arrayOffset out of bounds");
        }

        return read(attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Synchronously get the <i>Previous Month {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C43</b>].
     * <p>
     * This method can return cached data if the attribute has already been received.
     * The parameter <i>refreshPeriod</i> is used to control this. If the attribute has been received
     * within <i>refreshPeriod</i> milliseconds, then the method will immediately return the last value
     * received. If <i>refreshPeriod</i> is set to 0, then the attribute will always be updated.
     * <p>
     * This method will block until the response is received or a timeout occurs unless the current value is returned.
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @param refreshPeriod the maximum age of the data (in milliseconds) before an update is needed
     * @return the {@link Integer} attribute value, or null on error
     */
    public Integer getPreviousMonthAlternativeConsumptionReceived(final int arrayOffset, final long refreshPeriod) {
        if (attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset).isLastValueCurrent(refreshPeriod)) {
            return (Integer) attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset).getLastValue();
        }

        return (Integer) readSync(attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONRECEIVED + arrayOffset));
    }

    /**
     * Set reporting for the <i>Previous Month {{count}} Alternative Consumption Received</i> attribute [attribute ID <b>0x0C43</b>].
     * <p>
     * The attribute is of type {@link Integer}.
     * <p>
     * The implementation of this attribute by a device is MANDATORY
     *
     * @param arrayOffset attribute array offset (1 < arrayOffset < 13)
     * @param minInterval minimum reporting period
     * @param maxInterval maximum reporting period
     * @param reportableChange {@link Object} delta required to trigger report
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setPreviousMonth1AlternativeConsumptionReceivedReporting(final int arrayOffset, final int minInterval, final int maxInterval, final Object reportableChange) {
        return setReporting(attributes.get(ATTR_PREVIOUSMONTH1ALTERNATIVECONSUMPTIONRECEIVED + (arrayOffset - 1) * 2), minInterval, maxInterval, reportableChange);
    }

    /**
     * The Get Profile
     * <p>
     * The GetProfile command is generated when a client device wishes to retrieve a list of
     * captured Energy, Gas or water consumption for profiling purposes.
     *
     * @param intervalChannel {@link Integer} Interval Channel
     * @param endTime {@link Calendar} End Time
     * @param numberOfPeriods {@link Integer} Number Of Periods
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProfile(Integer intervalChannel, Calendar endTime, Integer numberOfPeriods) {
        GetProfile command = new GetProfile();

        // Set the fields
        command.setIntervalChannel(intervalChannel);
        command.setEndTime(endTime);
        command.setNumberOfPeriods(numberOfPeriods);

        return send(command);
    }

    /**
     * The Request Mirror Response
     * <p>
     * The Request Mirror Response Command allows the ESI to inform a sleepy Metering Device it
     * has the ability to store and mirror its data.
     *
     * @param endpointId {@link Integer} Endpoint ID
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> requestMirrorResponse(Integer endpointId) {
        RequestMirrorResponse command = new RequestMirrorResponse();

        // Set the fields
        command.setEndpointId(endpointId);

        return send(command);
    }

    /**
     * The Mirror Removed
     * <p>
     * The Mirror Removed Command allows the ESI to inform a sleepy Metering Device mirroring
     * support has been removed or halted.
     *
     * @param removedEndpointId {@link Integer} Removed Endpoint ID
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> mirrorRemoved(Integer removedEndpointId) {
        MirrorRemoved command = new MirrorRemoved();

        // Set the fields
        command.setRemovedEndpointId(removedEndpointId);

        return send(command);
    }

    /**
     * The Request Fast Poll Mode
     * <p>
     * The Request Fast Poll Mode command is generated when the metering client wishes to
     * receive near real-time updates of InstantaneousDemand.
     *
     * @param fastPollUpdatePeriod {@link Integer} Fast Poll Update Period
     * @param duration {@link Integer} Duration
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> requestFastPollMode(Integer fastPollUpdatePeriod, Integer duration) {
        RequestFastPollMode command = new RequestFastPollMode();

        // Set the fields
        command.setFastPollUpdatePeriod(fastPollUpdatePeriod);
        command.setDuration(duration);

        return send(command);
    }

    /**
     * The Schedule Snapshot
     * <p>
     * This command is used to set up a schedule of when the device shall create snapshot data.
     *
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param commandIndex {@link Integer} Command Index
     * @param totalNumberOfCommands {@link Integer} Total Number of Commands
     * @param snapshotSchedulePayload {@link SnapshotSchedulePayload} Snapshot Schedule Payload
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> scheduleSnapshot(Integer issuerEventId, Integer commandIndex, Integer totalNumberOfCommands, SnapshotSchedulePayload snapshotSchedulePayload) {
        ScheduleSnapshot command = new ScheduleSnapshot();

        // Set the fields
        command.setIssuerEventId(issuerEventId);
        command.setCommandIndex(commandIndex);
        command.setTotalNumberOfCommands(totalNumberOfCommands);
        command.setSnapshotSchedulePayload(snapshotSchedulePayload);

        return send(command);
    }

    /**
     * The Take Snapshot
     * <p>
     * This command is used to instruct the cluster server to take a single snapshot.
     *
     * @param snapshotCause {@link Integer} Snapshot Cause
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> takeSnapshot(Integer snapshotCause) {
        TakeSnapshot command = new TakeSnapshot();

        // Set the fields
        command.setSnapshotCause(snapshotCause);

        return send(command);
    }

    /**
     * The Get Snapshot
     * <p>
     * This command is used to request snapshot data from the cluster server.
     *
     * @param earliestStartTime {@link Calendar} Earliest Start Time
     * @param latestEndTime {@link Calendar} Latest End Time
     * @param snapshotOffset {@link Integer} Snapshot Offset
     * @param snapshotCause {@link Integer} Snapshot Cause
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSnapshot(Calendar earliestStartTime, Calendar latestEndTime, Integer snapshotOffset, Integer snapshotCause) {
        GetSnapshot command = new GetSnapshot();

        // Set the fields
        command.setEarliestStartTime(earliestStartTime);
        command.setLatestEndTime(latestEndTime);
        command.setSnapshotOffset(snapshotOffset);
        command.setSnapshotCause(snapshotCause);

        return send(command);
    }

    /**
     * The Start Sampling
     * <p>
     * The sampling mechanism allows a set of samples of the specified type of data to be taken,
     * commencing at the stipulated start time. This mechanism may run concurrently with the
     * capturing of profile data, and may refer the same parameters, albeit possibly at a
     * different sampling rate.
     *
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param startSamplingTime {@link Calendar} Start Sampling Time
     * @param sampleType {@link Integer} Sample Type
     * @param sampleRequestInterval {@link Integer} Sample Request Interval
     * @param maxNumberOfSamples {@link Integer} Max Number Of Samples
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> startSampling(Integer issuerEventId, Calendar startSamplingTime, Integer sampleType, Integer sampleRequestInterval, Integer maxNumberOfSamples) {
        StartSampling command = new StartSampling();

        // Set the fields
        command.setIssuerEventId(issuerEventId);
        command.setStartSamplingTime(startSamplingTime);
        command.setSampleType(sampleType);
        command.setSampleRequestInterval(sampleRequestInterval);
        command.setMaxNumberOfSamples(maxNumberOfSamples);

        return send(command);
    }

    /**
     * The Get Sampled Data
     * <p>
     * This command is used to request sampled data from the server. Note that it is the
     * responsibility of the client to ensure that it does not request more samples than can be
     * held in a single command payload.
     *
     * @param sampleId {@link Integer} Sample ID
     * @param earliestSampleTime {@link Calendar} Earliest Sample Time
     * @param sampleType {@link Integer} Sample Type
     * @param numberOfSamples {@link Integer} Number Of Samples
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSampledData(Integer sampleId, Calendar earliestSampleTime, Integer sampleType, Integer numberOfSamples) {
        GetSampledData command = new GetSampledData();

        // Set the fields
        command.setSampleId(sampleId);
        command.setEarliestSampleTime(earliestSampleTime);
        command.setSampleType(sampleType);
        command.setNumberOfSamples(numberOfSamples);

        return send(command);
    }

    /**
     * The Mirror Report Attribute Response
     * <p>
     * FIXME: This command is sent in response to the ReportAttribute command when the
     * MirrorReporting attribute is set.
     *
     * @param notificationScheme {@link Integer} Notification Scheme
     * @param notificationFlags {@link Integer} Notification Flags
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> mirrorReportAttributeResponse(Integer notificationScheme, Integer notificationFlags) {
        MirrorReportAttributeResponse command = new MirrorReportAttributeResponse();

        // Set the fields
        command.setNotificationScheme(notificationScheme);
        command.setNotificationFlags(notificationFlags);

        return send(command);
    }

    /**
     * The Reset Load Limit Counter
     * <p>
     * The ResetLoadLimitCounter command shall cause the LoadLimitCounter attribute to be
     * reset.
     *
     * @param providerId {@link Integer} Provider ID
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> resetLoadLimitCounter(Integer providerId, Integer issuerEventId) {
        ResetLoadLimitCounter command = new ResetLoadLimitCounter();

        // Set the fields
        command.setProviderId(providerId);
        command.setIssuerEventId(issuerEventId);

        return send(command);
    }

    /**
     * The Change Supply
     * <p>
     * This command is sent from the Head-end or ESI to the Metering Device to instruct it to
     * change the status of the valve or load switch, i.e. the supply.
     *
     * @param providerId {@link Integer} Provider ID
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param requestDateTime {@link Calendar} Request Date Time
     * @param implementationDateTime {@link Calendar} Implementation Date Time
     * @param proposedSupplyStatus {@link Integer} Proposed Supply Status
     * @param supplyControlBits {@link Integer} Supply Control Bits
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> changeSupply(Integer providerId, Integer issuerEventId, Calendar requestDateTime, Calendar implementationDateTime, Integer proposedSupplyStatus, Integer supplyControlBits) {
        ChangeSupply command = new ChangeSupply();

        // Set the fields
        command.setProviderId(providerId);
        command.setIssuerEventId(issuerEventId);
        command.setRequestDateTime(requestDateTime);
        command.setImplementationDateTime(implementationDateTime);
        command.setProposedSupplyStatus(proposedSupplyStatus);
        command.setSupplyControlBits(supplyControlBits);

        return send(command);
    }

    /**
     * The Local Change Supply
     * <p>
     * This command is a simplified version of the ChangeSupply command, intended to be sent
     * from an IHD to a meter as the consequence of a user action on the IHD. Its purpose is to
     * provide a local disconnection/reconnection button on the IHD in addition to the one on
     * the meter.
     *
     * @param proposedSupplyStatus {@link Integer} Proposed Supply Status
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> localChangeSupply(Integer proposedSupplyStatus) {
        LocalChangeSupply command = new LocalChangeSupply();

        // Set the fields
        command.setProposedSupplyStatus(proposedSupplyStatus);

        return send(command);
    }

    /**
     * The Set Supply Status
     * <p>
     * This command is used to specify the required status of the supply following the
     * occurance of certain events on the meter.
     *
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param supplyTamperState {@link Integer} Supply Tamper State
     * @param supplyDepletionState {@link Integer} Supply Depletion State
     * @param supplyUncontrolledFlowState {@link Integer} Supply Uncontrolled Flow State
     * @param loadLimitSupplyState {@link Integer} Load Limit Supply State
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setSupplyStatus(Integer issuerEventId, Integer supplyTamperState, Integer supplyDepletionState, Integer supplyUncontrolledFlowState, Integer loadLimitSupplyState) {
        SetSupplyStatus command = new SetSupplyStatus();

        // Set the fields
        command.setIssuerEventId(issuerEventId);
        command.setSupplyTamperState(supplyTamperState);
        command.setSupplyDepletionState(supplyDepletionState);
        command.setSupplyUncontrolledFlowState(supplyUncontrolledFlowState);
        command.setLoadLimitSupplyState(loadLimitSupplyState);

        return send(command);
    }

    /**
     * The Set Uncontrolled Flow Threshold
     * <p>
     * This command is used to update the 'Uncontrolled Flow Rate' configuration data used by
     * flow meters.
     *
     * @param providerId {@link Integer} Provider ID
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param uncontrolledFlowThreshold {@link Integer} Uncontrolled Flow Threshold
     * @param unitOfMeasure {@link Integer} Unit Of Measure
     * @param multiplier {@link Integer} Multiplier
     * @param divisor {@link Integer} Divisor
     * @param stabilisationPeriod {@link Integer} Stabilisation Period
     * @param measurementPeriod {@link Integer} Measurement Period
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> setUncontrolledFlowThreshold(Integer providerId, Integer issuerEventId, Integer uncontrolledFlowThreshold, Integer unitOfMeasure, Integer multiplier, Integer divisor, Integer stabilisationPeriod, Integer measurementPeriod) {
        SetUncontrolledFlowThreshold command = new SetUncontrolledFlowThreshold();

        // Set the fields
        command.setProviderId(providerId);
        command.setIssuerEventId(issuerEventId);
        command.setUncontrolledFlowThreshold(uncontrolledFlowThreshold);
        command.setUnitOfMeasure(unitOfMeasure);
        command.setMultiplier(multiplier);
        command.setDivisor(divisor);
        command.setStabilisationPeriod(stabilisationPeriod);
        command.setMeasurementPeriod(measurementPeriod);

        return send(command);
    }

    /**
     * The Get Profile Response
     * <p>
     * This command is sent when the Client command GetProfile is received.
     *
     * @param endTime {@link Calendar} End Time
     * @param status {@link Integer} Status
     * @param profileIntervalPeriod {@link Integer} Profile Interval Period
     * @param numberOfPeriodsDelivered {@link Integer} Number Of Periods Delivered
     * @param intervals {@link Integer} Intervals
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getProfileResponse(Calendar endTime, Integer status, Integer profileIntervalPeriod, Integer numberOfPeriodsDelivered, Integer intervals) {
        GetProfileResponse command = new GetProfileResponse();

        // Set the fields
        command.setEndTime(endTime);
        command.setStatus(status);
        command.setProfileIntervalPeriod(profileIntervalPeriod);
        command.setNumberOfPeriodsDelivered(numberOfPeriodsDelivered);
        command.setIntervals(intervals);

        return send(command);
    }

    /**
     * The Request Mirror
     * <p>
     * This command is used to request the ESI to mirror Metering Device data.
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> requestMirror() {
        return send(new RequestMirror());
    }

    /**
     * The Remove Mirror
     * <p>
     * This command is used to request the ESI to remove its mirror of Metering Device data.
     *
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> removeMirror() {
        return send(new RemoveMirror());
    }

    /**
     * The Request Fast Poll Mode Response
     * <p>
     * This command is generated when the client command Request Fast Poll Mode is received.
     *
     * @param appliedUpdatePeriod {@link Integer} Applied Update Period
     * @param fastPollModeEndtime {@link Calendar} Fast Poll Mode Endtime
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> requestFastPollModeResponse(Integer appliedUpdatePeriod, Calendar fastPollModeEndtime) {
        RequestFastPollModeResponse command = new RequestFastPollModeResponse();

        // Set the fields
        command.setAppliedUpdatePeriod(appliedUpdatePeriod);
        command.setFastPollModeEndtime(fastPollModeEndtime);

        return send(command);
    }

    /**
     * The Schedule Snapshot Response
     * <p>
     * This command is generated in response to a ScheduleSnapshot command, and is sent to
     * confirm whether the requested snapshot schedule has been set up.
     *
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param snapshotResponsePayload {@link SnapshotResponsePayload} Snapshot Response Payload
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> scheduleSnapshotResponse(Integer issuerEventId, SnapshotResponsePayload snapshotResponsePayload) {
        ScheduleSnapshotResponse command = new ScheduleSnapshotResponse();

        // Set the fields
        command.setIssuerEventId(issuerEventId);
        command.setSnapshotResponsePayload(snapshotResponsePayload);

        return send(command);
    }

    /**
     * The Take Snapshot Response
     * <p>
     * This command is generated in response to a TakeSnapshot command, and is sent to confirm
     * whether the requested snapshot has been accepted and successfully taken.
     *
     * @param snapshotId {@link Integer} Snapshot ID
     * @param snapshotConfirmation {@link Integer} Snapshot Confirmation
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> takeSnapshotResponse(Integer snapshotId, Integer snapshotConfirmation) {
        TakeSnapshotResponse command = new TakeSnapshotResponse();

        // Set the fields
        command.setSnapshotId(snapshotId);
        command.setSnapshotConfirmation(snapshotConfirmation);

        return send(command);
    }

    /**
     * The Publish Snapshot
     * <p>
     * This command is generated in response to a GetSnapshot command. It is used to return a
     * single snapshot to the client.
     *
     * @param snapshotId {@link Integer} Snapshot ID
     * @param snapshotTime {@link Calendar} Snapshot Time
     * @param totalSnapshotsFound {@link Integer} Total Snapshots Found
     * @param commandIndex {@link Integer} Command Index
     * @param totalNumberOfCommands {@link Integer} Total Number Of Commands
     * @param snapshotCause {@link Integer} Snapshot Cause
     * @param snapshotPayloadType {@link Integer} Snapshot Payload Type
     * @param snapshotPayload {@link Integer} Snapshot Payload
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> publishSnapshot(Integer snapshotId, Calendar snapshotTime, Integer totalSnapshotsFound, Integer commandIndex, Integer totalNumberOfCommands, Integer snapshotCause, Integer snapshotPayloadType, Integer snapshotPayload) {
        PublishSnapshot command = new PublishSnapshot();

        // Set the fields
        command.setSnapshotId(snapshotId);
        command.setSnapshotTime(snapshotTime);
        command.setTotalSnapshotsFound(totalSnapshotsFound);
        command.setCommandIndex(commandIndex);
        command.setTotalNumberOfCommands(totalNumberOfCommands);
        command.setSnapshotCause(snapshotCause);
        command.setSnapshotPayloadType(snapshotPayloadType);
        command.setSnapshotPayload(snapshotPayload);

        return send(command);
    }

    /**
     * The Get Sampled Data Response
     * <p>
     * FIXME: This command is used to send the requested sample data to the client. It is
     * generated in response to a GetSampledData command.
     *
     * @param sampleId {@link Integer} Sample ID
     * @param sampleStartTime {@link Calendar} Sample Start Time
     * @param sampleType {@link Integer} Sample Type
     * @param sampleRequestInterval {@link Integer} Sample Request Interval
     * @param numberOfSamples {@link Integer} Number Of Samples
     * @param samples {@link Integer} Samples
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getSampledDataResponse(Integer sampleId, Calendar sampleStartTime, Integer sampleType, Integer sampleRequestInterval, Integer numberOfSamples, Integer samples) {
        GetSampledDataResponse command = new GetSampledDataResponse();

        // Set the fields
        command.setSampleId(sampleId);
        command.setSampleStartTime(sampleStartTime);
        command.setSampleType(sampleType);
        command.setSampleRequestInterval(sampleRequestInterval);
        command.setNumberOfSamples(numberOfSamples);
        command.setSamples(samples);

        return send(command);
    }

    /**
     * The Configure Mirror
     * <p>
     * FIXME: ConfigureMirror is sent to the mirror once the mirror has been created. The
     * command deals with the operational configuration of the Mirror.
     *
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param reportingInterval {@link Integer} Reporting Interval
     * @param mirrorNotificationReporting {@link Boolean} Mirror Notification Reporting
     * @param notificationScheme {@link Integer} Notification Scheme
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> configureMirror(Integer issuerEventId, Integer reportingInterval, Boolean mirrorNotificationReporting, Integer notificationScheme) {
        ConfigureMirror command = new ConfigureMirror();

        // Set the fields
        command.setIssuerEventId(issuerEventId);
        command.setReportingInterval(reportingInterval);
        command.setMirrorNotificationReporting(mirrorNotificationReporting);
        command.setNotificationScheme(notificationScheme);

        return send(command);
    }

    /**
     * The Configure Notification Scheme
     * <p>
     * FIXME: The ConfigureNotificationScheme is sent to the mirror once the mirror has been
     * created. The command deals with the operational configuration of the Mirror and the
     * device that reports to the mirror. No default schemes are allowed to be overwritten.
     *
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param notificationScheme {@link Integer} Notification Scheme
     * @param notificationFlagOrder {@link Integer} Notification Flag Order
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> configureNotificationScheme(Integer issuerEventId, Integer notificationScheme, Integer notificationFlagOrder) {
        ConfigureNotificationScheme command = new ConfigureNotificationScheme();

        // Set the fields
        command.setIssuerEventId(issuerEventId);
        command.setNotificationScheme(notificationScheme);
        command.setNotificationFlagOrder(notificationFlagOrder);

        return send(command);
    }

    /**
     * The Configure Notification Flags
     * <p>
     * The ConfigureNotificationFlags command is used to set the commands relating to the bit
     * value for each NotificationFlags attribute that the scheme is proposing to use.
     *
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param notificationScheme {@link Integer} Notification Scheme
     * @param notificationFlagAttributeId {@link Integer} Notification Flag Attribute ID
     * @param subPayload {@link NotificationCommandSubPayload} Sub Payload
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> configureNotificationFlags(Integer issuerEventId, Integer notificationScheme, Integer notificationFlagAttributeId, NotificationCommandSubPayload subPayload) {
        ConfigureNotificationFlags command = new ConfigureNotificationFlags();

        // Set the fields
        command.setIssuerEventId(issuerEventId);
        command.setNotificationScheme(notificationScheme);
        command.setNotificationFlagAttributeId(notificationFlagAttributeId);
        command.setSubPayload(subPayload);

        return send(command);
    }

    /**
     * The Get Notified Message
     * <p>
     * The GetNotifiedMessage command is used only when a BOMD is being mirrored. This command
     * provides a method for the BOMD to notify the Mirror message queue that it wants to receive
     * commands that the Mirror has queued. The Notification flags set within the command
     * shall inform the mirror of the commands that the BOMD is requesting.
     *
     * @param notificationScheme {@link Integer} Notification Scheme
     * @param notificationFlagAttributeId {@link Integer} Notification Flag Attribute ID
     * @param notificationFlagsN {@link Integer} Notification Flags N
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> getNotifiedMessage(Integer notificationScheme, Integer notificationFlagAttributeId, Integer notificationFlagsN) {
        GetNotifiedMessage command = new GetNotifiedMessage();

        // Set the fields
        command.setNotificationScheme(notificationScheme);
        command.setNotificationFlagAttributeId(notificationFlagAttributeId);
        command.setNotificationFlagsN(notificationFlagsN);

        return send(command);
    }

    /**
     * The Supply Status Response
     * <p>
     * This command is transmitted by a Metering Device in response to a ChangeSupply command.
     *
     * @param providerId {@link Integer} Provider ID
     * @param issuerEventId {@link Integer} Issuer Event ID
     * @param implementationDateTime {@link Calendar} Implementation Date Time
     * @param supplyStatus {@link Integer} Supply Status
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> supplyStatusResponse(Integer providerId, Integer issuerEventId, Calendar implementationDateTime, Integer supplyStatus) {
        SupplyStatusResponse command = new SupplyStatusResponse();

        // Set the fields
        command.setProviderId(providerId);
        command.setIssuerEventId(issuerEventId);
        command.setImplementationDateTime(implementationDateTime);
        command.setSupplyStatus(supplyStatus);

        return send(command);
    }

    /**
     * The Start Sampling Response
     * <p>
     * This command is transmitted by a Metering Device in response to a StartSampling
     * command.
     *
     * @param sampleId {@link Integer} Sample ID
     * @return the {@link Future<CommandResult>} command result future
     */
    public Future<CommandResult> startSamplingResponse(Integer sampleId) {
        StartSamplingResponse command = new StartSamplingResponse();

        // Set the fields
        command.setSampleId(sampleId);

        return send(command);
    }
}
